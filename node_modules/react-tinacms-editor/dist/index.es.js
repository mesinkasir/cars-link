var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
import * as React from "react";
import React__default, { createContext, useContext, useState, useEffect, useRef, createRef } from "react";
import { useCMS, LoadingDots, wrapFieldsWithMeta } from "tinacms";
import { MarkdownIcon, Dismissible, HeadingIcon, CodeIcon, UndoIcon, RedoIcon, BoldIcon, ItalicIcon, StrikethroughIcon, UnorderedListIcon, OrderedListIcon, QuoteIcon, TableIcon, MediaIcon, LinkIcon, IconButton, AlignLeft, AlignCenter, AlignRight, TrashIcon, AddIcon } from "@tinacms/toolkit";
import styled, { css, keyframes } from "styled-components";
import { toggleMark, setBlockType, exitCode, wrapIn, chainCommands, baseKeymap, createParagraphNear, liftEmptyBlock, splitBlock } from "prosemirror-commands";
import * as ReactDOM from "react-dom";
import ReactDOM__default, { createPortal } from "react-dom";
import { TextSelection, Selection, PluginKey, Plugin, NodeSelection, EditorState } from "prosemirror-state";
import { undo, redo, undoDepth, redoDepth, history } from "prosemirror-history";
import { liftListItem, wrapInList, splitListItem, sinkListItem } from "prosemirror-schema-list";
import { findParentNodeOfType, forEachCellInColumn, setCellAttrs, addColumnAt, addRowAt, getCellsInRow } from "prosemirror-utils";
import { Decoration, DecorationSet, EditorView } from "prosemirror-view";
import * as TableCommands from "prosemirror-tables";
import { CellSelection, TableMap, tableNodes, tableEditing, deleteColumn, deleteRow, deleteTable } from "prosemirror-tables";
import debounce from "lodash.debounce";
import { Fragment, Slice, Schema, Mark, DOMSerializer as DOMSerializer$1, DOMParser as DOMParser$1 } from "prosemirror-model";
import { dropCursor } from "prosemirror-dropcursor";
import { gapCursor } from "prosemirror-gapcursor";
import { keymap } from "prosemirror-keymap";
import { undoInputRule, wrappingInputRule, textblockTypeInputRule, InputRule, inputRules as inputRules$1 } from "prosemirror-inputrules";
import { liftTarget } from "prosemirror-transform";
const BrowserFocusContext = createContext({
  browserFocused: true
});
const BrowserFocusProvider = ({
  children
}) => {
  const [browserFocused, setBrowserFocused] = useState(true);
  useEffect(() => {
    const setWindowFocused = () => setBrowserFocused(true);
    const setWindowBlurred = () => setBrowserFocused(false);
    window.addEventListener("focus", setWindowFocused);
    window.addEventListener("blur", setWindowBlurred);
    return () => {
      window.removeEventListener("focus", setWindowFocused);
      window.removeEventListener("blur", setWindowBlurred);
    };
  }, []);
  return /* @__PURE__ */ React.createElement(BrowserFocusContext.Provider, {
    value: { browserFocused }
  }, children);
};
BrowserFocusContext.Consumer;
const useBrowserFocusContext = () => __spreadValues({}, useContext(BrowserFocusContext));
const MenuButton = styled.button`
  padding: 8px !important;
  border: none;
  border-right: 1px solid var(--tina-color-grey-2);
  width: auto;
  height: auto;
  border-left: none;
  margin: 0 0 -1px 0;
  flex-grow: 1;
  max-width: 48px;
  transition: background 150ms ease-out;

  &:hover {
    background-color: rgba(53, 50, 50, 0.09);
  }
  &:active {
    color: var(--tina-color-primary);
    fill: var(--tina-color-primary);
    background-color: rgba(53, 50, 50, 0.05);
  }
  svg {
    width: 20px;
    height: 20px;
  }
  ${(props) => props.active && css`
      color: var(--tina-color-primary);
      fill: var(--tina-color-primary);
      background-color: rgba(53, 50, 50, 0.05);
    `};
  ${(props) => props.disabled && css`
      pointer-events: none;
      color: #d1d1d1;
      fill: #d1d1d1;
    `};
`;
const EditorModeContext = createContext({
  mode: "wysiwyg",
  setMode: () => {
  }
});
const EditorModeProvider = ({ children }) => {
  const [mode, setMode] = useState("wysiwyg");
  useEffect(() => {
    document.addEventListener("keydown", (event) => {
      if (event.altKey && event.shiftKey && event.metaKey && event.keyCode === 77)
        setMode(mode === "wysiwyg" ? "markdown" : "wysiwyg");
    });
  });
  return /* @__PURE__ */ React.createElement(EditorModeContext.Provider, {
    value: { mode, setMode }
  }, children);
};
const EditorModeConsumer = EditorModeContext.Consumer;
const useEditorModeContext = () => useContext(EditorModeContext);
const EditorModeMenu = () => {
  const { mode, setMode } = useEditorModeContext();
  const toggleMode = () => {
    if (mode === "markdown")
      setMode("wysiwyg");
    else
      setMode("markdown");
  };
  return /* @__PURE__ */ React.createElement(MenuButton, {
    "data-testid": "markdown-toggle",
    "data-tooltip": "Markdown mode",
    title: "Toggle Markdown mode",
    onClick: toggleMode
  }, /* @__PURE__ */ React.createElement(MarkdownIcon, null));
};
const EditorStateContext = createContext({
  editorView: void 0,
  translator: void 0
});
const EditorStateProvider = ({
  children,
  editorView,
  translator
}) => {
  return /* @__PURE__ */ React.createElement(EditorStateContext.Provider, {
    value: { editorView, translator }
  }, children);
};
EditorStateContext.Consumer;
const useEditorStateContext = () => __spreadValues({}, useContext(EditorStateContext));
const commandControl = (command, Icon, _title, tooltip, focusOnCreate = true) => () => {
  const { editorView } = useEditorStateContext();
  const onClick = () => {
    if (canDo()) {
      const view = editorView.view;
      command(view.state, view.dispatch);
      if (focusOnCreate) {
        view.focus();
      }
    }
  };
  const canDo = () => command(editorView.view.state);
  return /* @__PURE__ */ React__default.createElement(MenuButton, {
    "data-tooltip": tooltip,
    title: tooltip,
    onClick,
    disabled: !canDo(),
    onMouseDown: (evt) => {
      evt.preventDefault();
      evt.stopPropagation();
    }
  }, /* @__PURE__ */ React__default.createElement(Icon, null));
};
function markControl({
  mark,
  Icon,
  tooltip,
  defaultAttrs,
  selectionOnly = false,
  noMix = [],
  isDisabled,
  onClick,
  onMenuOptionClick
}) {
  return () => {
    const { editorView } = useEditorStateContext();
    const view = editorView.view;
    const markType = (markName) => {
      const schema = view.state.schema;
      return schema.marks[markName];
    };
    const isActive = () => markIsActive(mark);
    const markIsActive = (markName) => {
      const { state } = view;
      const mark2 = markType(markName);
      const { from, $from, to, empty } = state.selection;
      if (empty)
        return !!mark2.isInSet(state.storedMarks || $from.marks());
      else
        return state.doc.rangeHasMark(from, to, mark2);
    };
    const isOptionDisabled = () => {
      if (isDisabled)
        return isDisabled(view);
      if (mark === "image") {
        if (selectionOnly) {
          const { $cursor } = view.state.selection;
          return !!$cursor || isInCodeBlock() || isIncompatibleMarksAreActive();
        }
      }
      return isInCodeBlock() || isIncompatibleMarksAreActive();
    };
    const isInCodeBlock = () => {
      const node = view.state.selection.$from.node(view.state.selection.$from.depth);
      return node.type === view.state.schema.nodes.code_block;
    };
    const isIncompatibleMarksAreActive = () => {
      return noMix.map(markIsActive).reduce((someMarkActive, nextMarkActive) => nextMarkActive || someMarkActive, false);
    };
    const onOptionClick = () => {
      if (onClick) {
        onClick(view);
      }
      if (onMenuOptionClick) {
        return onMenuOptionClick(view);
      }
      if (isOptionDisabled())
        return;
      const { state, dispatch } = view;
      if (state.selection.$cursor && selectionOnly) {
        return;
      }
      toggleMark(markType(mark), defaultAttrs)(state, dispatch);
    };
    if (!markType(mark)) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(MenuButton, {
      "data-tooltip": tooltip,
      "data-side": "top",
      title: tooltip,
      onClick: onOptionClick,
      active: !isOptionDisabled() && isActive(),
      disabled: isOptionDisabled()
    }, /* @__PURE__ */ React.createElement(Icon, null));
  };
}
const MenuPortalContext = React.createContext(() => {
  return null;
});
function useMenuPortal() {
  return useContext(MenuPortalContext);
}
const MenuPortalProvider = ({ children }) => {
  const wrapperRef = React.useRef(null);
  const MenuPortal = React.useCallback((props) => {
    if (!wrapperRef.current)
      return null;
    return createPortal(props.children, wrapperRef.current);
  }, [wrapperRef]);
  return /* @__PURE__ */ React.createElement(MenuPortalContext.Provider, {
    value: MenuPortal
  }, /* @__PURE__ */ React.createElement("div", {
    ref: wrapperRef
  }, children));
};
const MenuDropdown = styled((_a) => {
  var _b = _a, { children, open, triggerRef, innerRef } = _b, styleProps = __objRest(_b, ["children", "open", "triggerRef", "innerRef"]);
  const MenuPortal = useMenuPortal();
  const menuPortalRef = React.useRef(null);
  const [menuOffset, setMenuOffset] = React.useState(0);
  React.useEffect(() => {
    if (triggerRef.current && menuPortalRef.current) {
      const menuDropdownBoundingBox = triggerRef.current.getBoundingClientRect();
      const menuPortalBoundingBox = menuPortalRef.current.getBoundingClientRect();
      setMenuOffset(menuDropdownBoundingBox.x - menuPortalBoundingBox.x);
    }
  }, [triggerRef.current, menuPortalRef.current]);
  return /* @__PURE__ */ React.createElement(MenuPortal, null, /* @__PURE__ */ React.createElement("div", {
    ref: menuPortalRef
  }, /* @__PURE__ */ React.createElement(Offset, {
    offset: menuOffset
  }, /* @__PURE__ */ React.createElement("div", __spreadValues({}, styleProps), children))));
})`
  border-radius: var(--tina-radius-small);
  border: 1px solid #efefef;
  display: block;
  position: absolute;
  bottom: -4px;
  left: 0;
  transform: translate3d(0, 100%, 0) scale3d(0.5, 0.5, 1);
  opacity: 0;
  pointer-events: none;
  transition: all 85ms ease-out;
  transform-origin: 0 0;
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12), 0px 4px 8px rgba(48, 48, 48, 0.1);
  background-color: white;
  overflow: hidden;
  z-index: 10;
  white-space: nowrap;

  ${(props) => props.open && css`
      opacity: 1;
      pointer-events: all;
      transform: translate3d(0, 100%, 0) scale3d(1, 1, 1);
    `};
`;
const Offset = styled.div`
  position: absolute;
  left: ${(props) => props.offset}px;
`;
const MenuOption = styled.div`
  display: block;
  padding: 8px 12px;
  transition: all 85ms ease-out;
  cursor: pointer;
  &:first-child {
    padding-top: var(--tina-padding-small);
  }
  &:last-child {
    padding-bottom: var(--tina-padding-small);
  }
  &:hover {
    background-color: var(--tina-color-grey-1);
    color: var(--tina-color-primary);
  }
  &:active {
    color: var(--tina-color-primary);
    fill: var(--tina-color-primary);
    background-color: rgba(53, 50, 50, 0.05);
  }
  ${(props) => props.active && css`
      color: var(--tina-color-primary);
      fill: var(--tina-color-primary);
      background-color: rgba(53, 50, 50, 0.05);
    `};
`;
const findElementOffsetTop = (element, parent) => {
  let target = element;
  let offsetTop = target.offsetTop;
  while (target.offsetParent && (!parent || target.offsetParent !== parent)) {
    target = target.offsetParent;
    offsetTop += target.offsetTop;
  }
  return offsetTop < 0 ? 0 : offsetTop;
};
const findElementOffsetLeft = (element, parent) => {
  let target = element;
  let offsetLeft = target.offsetLeft;
  while (target.offsetParent && (!parent || target.offsetParent !== parent)) {
    target = target.offsetParent;
    offsetLeft += target.offsetLeft;
  }
  return offsetLeft;
};
const isMarkPresent = (state, markType) => !!getMarkPresent(state, markType);
const getMarkPresent = (state, markType) => {
  const { selection } = state;
  const { anchor, head } = selection;
  let start;
  let end;
  if (anchor < head) {
    start = anchor;
    end = head;
  } else {
    start = head;
    end = anchor;
  }
  start = selection.empty ? start : start + 1;
  const mark = markType.isInSet(state.doc.resolve(start).marks());
  if (!mark)
    return false;
  let markPresent = mark;
  for (; start < end && markPresent; start += 1) {
    if (!markType.isInSet(state.doc.resolve(start).marks()))
      markPresent = void 0;
  }
  return markPresent;
};
const getOS = () => {
  if (typeof global["navigator"] === "undefined")
    return "Windows";
  const nAgt = navigator.userAgent;
  const clientStrings = [
    { s: "Windows", r: /Win16/ },
    { s: "Windows", r: /(Windows 95|Win95|Windows_95)/ },
    { s: "Windows", r: /(Win 9x 4.90|Windows ME)/ },
    { s: "Windows", r: /(Windows 98|Win98)/ },
    { s: "Windows", r: /Windows CE/ },
    { s: "Windows", r: /(Windows NT 5.0|Windows 2000)/ },
    { s: "Windows", r: /(Windows NT 5.1|Windows XP)/ },
    { s: "Windows", r: /Windows NT 5.2/ },
    { s: "Windows", r: /Windows NT 6.0/ },
    { s: "Windows", r: /(Windows 7|Windows NT 6.1)/ },
    { s: "Windows", r: /(Windows 8.1|Windows NT 6.3)/ },
    { s: "Windows", r: /(Windows 8|Windows NT 6.2)/ },
    { s: "Windows", r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },
    { s: "Linux", r: /(Linux|X11)/ },
    { s: "iOS", r: /(iPhone|iPad|iPod)/ },
    { s: "Mac OS X", r: /Mac OS X/ },
    { s: "Mac OS", r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },
    { s: "QNX", r: /QNX/ },
    { s: "UNIX", r: /UNIX/ },
    { s: "BeOS", r: /BeOS/ }
  ];
  const keys = Object.keys(clientStrings);
  for (let i = 0; i < clientStrings.length; i += 1) {
    const clientObj = clientStrings[keys[i]];
    if (clientObj.r.test(nAgt)) {
      return clientObj.s;
    }
  }
  return "";
};
const formatKeymap = (keymapStr) => {
  const os = getOS();
  const mod = os === "Windows" ? "^" : "\u2318";
  let formattedKeymap = keymapStr;
  formattedKeymap = formattedKeymap.replace("Mod", mod);
  formattedKeymap = formattedKeymap.replace("Shift", "\u21E7");
  formattedKeymap = formattedKeymap.replace("Alt", "\u2325");
  return formattedKeymap;
};
function deleteEmptyHeading(state, dispatch) {
  const { $cursor } = state.selection;
  if (!$cursor)
    return false;
  const node = state.doc.nodeAt(Math.max($cursor.pos - 1, 0));
  if (!node)
    return false;
  if (node.type != state.schema.nodes.heading)
    return false;
  if (node.textContent.length)
    return false;
  if (dispatch) {
    const { tr } = state;
    dispatch(tr.replaceRangeWith($cursor.pos - 1, $cursor.pos + node.nodeSize - 1, state.schema.nodes.paragraph.create()).setSelection(new TextSelection(tr.doc.resolve(state.selection.head))).scrollIntoView());
  }
  return true;
}
function toggleHeader(nodeType, attrs2, fallBackNodeType, fallbackAttrs) {
  return function(state, dispatch) {
    const { from, to } = state.selection;
    let firstTextblock = null;
    let firstPos = -1;
    state.doc.nodesBetween(from, to, (node, pos) => {
      if (firstTextblock)
        return false;
      if (node.isTextblock) {
        firstTextblock = node;
        firstPos = pos;
      }
      return true;
    });
    if (!firstTextblock || firstPos < 0)
      return false;
    const $firstPos = state.doc.resolve(firstPos);
    const index = $firstPos.index();
    const setAsParagraph = state.selection.$head.parent.attrs.level == attrs2.level;
    const nextNodeType = setAsParagraph ? fallBackNodeType : nodeType;
    const nextAttrs = setAsParagraph ? fallbackAttrs : attrs2;
    if (!$firstPos.parent.canReplaceWith(index, index + 1, nextNodeType))
      return false;
    if (dispatch) {
      dispatch(state.tr.setBlockType(from, to, nextNodeType, nextAttrs).scrollIntoView());
    }
    return true;
  };
}
function blockTool(options) {
  const { Component, children, command, typeName, attrs: attrs2, title } = options;
  return class extends React.Component {
    constructor() {
      super(...arguments);
      this.canDo = () => command(this.props.view.state);
      this.onClick = () => {
        command(this.props.view.state, this.props.view.dispatch);
        this.props.view.focus();
        this.props.onClick();
      };
    }
    get active() {
      if (!typeName)
        return false;
      const { state } = this.props.view;
      const $from = state.selection.$from;
      const node = $from.node($from.depth);
      const correctNodeType = node.type.name === typeName;
      const correctAttrs = attrs2 ? node.attrs.level === attrs2.level : true;
      return correctNodeType && correctAttrs;
    }
    render() {
      return /* @__PURE__ */ React.createElement(MenuOption, {
        onClick: this.onClick,
        disabled: !this.canDo(),
        active: this.active
      }, /* @__PURE__ */ React.createElement(Content, null, /* @__PURE__ */ React.createElement(Component, null, children), /* @__PURE__ */ React.createElement(TitleText, null, title)));
    }
  };
}
const Content = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
`;
const TitleText = styled.span`
  color: #d1d1d1;
  font-size: 12px;
`;
const ProsemirrorMenu$8 = () => {
  const [active, setActive] = useState(false);
  const menuButtonRef = useRef();
  const { editorView } = useEditorStateContext();
  const view = editorView.view;
  const toggle = () => setActive(!active);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Dismissible, {
    click: true,
    escape: true,
    disabled: !active,
    onDismiss: toggle
  }, /* @__PURE__ */ React.createElement(MenuButton, {
    ref: menuButtonRef,
    "data-tooltip": "Heading",
    title: "Heading",
    onClick: toggle,
    active
  }, /* @__PURE__ */ React.createElement(HeadingIcon, null)), /* @__PURE__ */ React.createElement(MenuDropdown, {
    triggerRef: menuButtonRef,
    open: active
  }, /* @__PURE__ */ React.createElement(H1, {
    view,
    onClick: toggle
  }), /* @__PURE__ */ React.createElement(H2, {
    view,
    onClick: toggle
  }), /* @__PURE__ */ React.createElement(H3, {
    view,
    onClick: toggle
  }), /* @__PURE__ */ React.createElement(H4, {
    view,
    onClick: toggle
  }), /* @__PURE__ */ React.createElement(H5, {
    view,
    onClick: toggle
  }), /* @__PURE__ */ React.createElement(H6, {
    view,
    onClick: toggle
  }))));
};
function makeToggleHeader(level) {
  return function toggleHeader$1(state, dispatch) {
    const tn = toggleHeader(state.schema.nodes.heading, { level }, state.schema.nodes.paragraph, null);
    return tn(state, dispatch);
  };
}
const BaseHeading = css`
  white-space: nowrap;
  line-height: 1;
  display: block;
  margin: 0;
`;
const HeadingOne = styled.h1`
  ${BaseHeading}
`;
const HeadingTwo = styled.h2`
  ${BaseHeading}
`;
const HeadingThree = styled.h3`
  ${BaseHeading}
`;
const HeadingFour = styled.h4`
  ${BaseHeading}
`;
const HeadingFive = styled.h5`
  ${BaseHeading}
`;
const HeadingSix = styled.h6`
  ${BaseHeading}
`;
const H1 = blockTool({
  Component: HeadingOne,
  children: "Heading 1",
  command: makeToggleHeader(1),
  typeName: "heading",
  attrs: { level: 1 },
  title: formatKeymap("Mod-Alt-1")
});
const H2 = blockTool({
  Component: HeadingTwo,
  children: "Heading 2",
  command: makeToggleHeader(2),
  typeName: "heading",
  attrs: { level: 2 },
  title: formatKeymap("Mod-Alt-2")
});
const H3 = blockTool({
  Component: HeadingThree,
  children: "Heading 3",
  command: makeToggleHeader(3),
  typeName: "heading",
  attrs: { level: 3 },
  title: formatKeymap("Mod-Alt-3")
});
const H4 = blockTool({
  Component: HeadingFour,
  children: "Heading 4",
  command: makeToggleHeader(4),
  typeName: "heading",
  attrs: { level: 4 },
  title: formatKeymap("Mod-Alt-4")
});
const H5 = blockTool({
  Component: HeadingFive,
  children: "Heading 5",
  command: makeToggleHeader(5),
  typeName: "heading",
  attrs: { level: 5 },
  title: formatKeymap("Mod-Alt-5")
});
const H6 = blockTool({
  Component: HeadingSix,
  children: "Heading 6",
  command: makeToggleHeader(6),
  typeName: "heading",
  attrs: { level: 6 },
  title: formatKeymap("Mod-Alt-6")
});
const MarkdownMenu$8 = () => /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Heading",
  disabled: true
}, /* @__PURE__ */ React.createElement(HeadingIcon, null));
function makeCodeBlock(state, dispatch) {
  const { code_block: code_block2, paragraph: paragraph2 } = state.schema.nodes;
  const { selection, tr } = state;
  const currentNode = selection.$to.node(selection.$to.depth);
  if (currentNode.type === code_block2)
    return setBlockType(paragraph2)(state, dispatch);
  if (!dispatch || selection.empty)
    return setBlockType(code_block2)(state, dispatch);
  let content = ``;
  let startPos = void 0;
  let endPos = void 0;
  state.doc.nodesBetween(selection.from, selection.to - 1, (node, pos) => {
    if (node.isTextblock) {
      if (startPos === void 0)
        startPos = pos;
      if (content.length)
        content += `
`;
      content += node.textContent;
      endPos = pos + node.textContent.length + 1;
    }
  });
  const codeBlock = code_block2.createChecked();
  return dispatch(tr.replaceRangeWith(startPos, endPos + 1, codeBlock).insertText(content, startPos + 1).setSelection(new TextSelection(tr.doc.resolve(startPos + content.length + 1))));
}
const ProsemirrorMenu$7 = commandControl(makeCodeBlock, CodeIcon, "Codeblock", formatKeymap("Codeblock Mod-Alt-0"), true);
const MarkdownMenu$7 = () => /* @__PURE__ */ React__default.createElement(MenuButton, {
  "data-tooltip": "Codeblock",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React__default.createElement(CodeIcon, null));
function exitCodeHard(state, dispatch) {
  const { $head } = state.selection;
  const above = $head.node(-1);
  const after = $head.indexAfter(-1);
  const type = above.defaultContentType(after);
  if (dispatch) {
    const pos = $head.before();
    const tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function exitCodeUp(state, dispatch) {
  const { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  const above = $head.node(-1);
  const after = $head.indexAfter(-1);
  const type = above.defaultContentType(after);
  if (!above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    const pos = $head.before();
    const tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), -1));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function deleteEmptyCodeblock(cm) {
  return (state, dispatch) => {
    const pos = cm.getCursor();
    const code2 = cm.getValue();
    const codeWithoutInvisibles = code2.replace(/[ \r\n]/g, "");
    const shouldRemove = !codeWithoutInvisibles;
    if (!(pos.line == 0 && pos.ch == 0 && shouldRemove)) {
      return false;
    }
    const { $from } = state.selection;
    if (dispatch) {
      const { schema, tr } = state;
      dispatch(tr.replaceRangeWith($from.pos - 1, $from.pos + code2.length + 1, schema.nodes.paragraph.create()).setSelection(new TextSelection(tr.doc.resolve($from.pos))));
    }
    return true;
  };
}
const ssr = typeof navigator == "undefined";
const mac$1 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
let CodeMirror = null;
if (!ssr) {
  CodeMirror = require("codemirror");
}
class CodeBlockView {
  constructor(node, view, getPos) {
    this.node = node;
    this.view = view;
    this.getPos = getPos;
    this.updating = false;
    this.onCursorActivity = () => {
      if (!this.updating) {
        this.forwardSelection();
      }
    };
    this.forwardSelection = () => {
      if (!this.cm.hasFocus())
        return;
      const state = this.view.state;
      const selection = this.asProseMirrorSelection(state.doc);
      if (!selection.eq(state.selection)) {
        this.view.dispatch(state.tr.setSelection(selection));
      }
    };
    this.onChange = () => {
      if (!this.updating) {
        this.valueChanged();
      }
    };
    if (ssr)
      return;
    this.cm = this.setupCodeMirror(node);
    this.dom = this.cm.getWrapperElement();
    setTimeout(() => this.cm.refresh(), 20);
    this.cm.on("cursorActivity", this.onCursorActivity);
    this.cm.on("changes", this.onChange);
    this.cm.on("focus", this.forwardSelection);
    const offset = this.getPos() + 1;
    const { anchor, head } = view.state.selection;
    this.setSelection(anchor - offset, head - offset);
  }
  valueChanged() {
    const change = computeChange(this.node.textContent, this.cm.getValue());
    if (change) {
      const codeBlockStart = this.getPos() + 1;
      const schema = this.view.state.schema;
      const tr = this.view.state.tr.replaceWith(codeBlockStart + change.from, codeBlockStart + change.to, change.text ? schema.text(change.text) : null);
      this.view.dispatch(tr);
    }
  }
  asProseMirrorSelection(doc2) {
    const offset = this.getPos() + 1;
    const anchor = this.cm.indexFromPos(this.cm.getCursor("anchor")) + offset;
    const head = this.cm.indexFromPos(this.cm.getCursor("head")) + offset;
    return TextSelection.create(doc2, anchor, head);
  }
  setSelection(anchor, head) {
    this.cm.focus();
    this.updating = true;
    this.cm.setSelection(this.cm.posFromIndex(anchor), this.cm.posFromIndex(head));
    this.updating = false;
  }
  setupCodeMirror(node) {
    return CodeMirror(null, {
      value: node.textContent,
      lineNumbers: true,
      extraKeys: this.codeMirrorKeymap(),
      mode: node.attrs.params,
      theme: "forestry"
    });
  }
  codeMirrorKeymap() {
    const view = this.view;
    const mod = mac$1 ? "Cmd" : "Ctrl";
    return CodeMirror.normalizeKeyMap({
      Up: () => this.maybeEscape("line", -1),
      Left: () => this.maybeEscape("char", -1),
      Down: () => this.maybeEscape("line", 1),
      Right: () => this.maybeEscape("char", 1),
      Backspace: () => {
        if (!deleteEmptyCodeblock(this.cm)(this.view.state, this.view.dispatch)) {
          return CodeMirror.Pass;
        }
        this.view.focus();
      },
      [`${mod}-Z`]: () => undo(view.state, view.dispatch),
      [`Shift-${mod}-Z`]: () => redo(view.state, view.dispatch),
      [`${mod}-Shift-Enter`]: () => {
        const pos = this.cm.getCursor();
        if (this.cm.somethingSelected() || pos.line != this.cm.firstLine()) {
          return CodeMirror.Pass;
        }
        if (view.state.selection.$anchor.parentOffset) {
          const pos2 = view.state.selection.$anchor.pos;
          view.dispatch(view.state.tr.setSelection(Selection.near(this.view.state.doc.resolve(pos2 - 1), -1)));
        }
        if (exitCodeUp(view.state, view.dispatch)) {
          view.focus();
        }
        return true;
      },
      ["Shift-Enter"]: () => {
        const pos = this.cm.getCursor();
        if (this.cm.somethingSelected() || pos.line != this.cm.lastLine()) {
          return CodeMirror.Pass;
        }
        if (view.state.selection.$anchor.parentOffset) {
          const pos2 = view.state.selection.$anchor.pos;
          view.dispatch(view.state.tr.setSelection(Selection.near(this.view.state.doc.resolve(pos2 - 1), -1)));
        }
        if (exitCode(view.state, view.dispatch)) {
          return view.focus();
        } else if (exitCodeHard(view.state, view.dispatch)) {
          return view.focus();
        }
      },
      [`${mod}-Alt-0`]: () => {
        const { state, dispatch } = view;
        const { paragraph: paragraph2 } = state.schema.nodes;
        setBlockType(paragraph2)(state, dispatch);
      }
    });
  }
  maybeEscape(unit, dir) {
    const pos = this.cm.getCursor();
    if (this.cm.somethingSelected() || pos.line != (dir < 0 ? this.cm.firstLine() : this.cm.lastLine()) || unit == "char" && pos.ch != (dir < 0 ? 0 : this.cm.getLine(pos.line).length)) {
      return CodeMirror.Pass;
    }
    const targetPos = this.getPos() + (dir < 0 ? 0 : this.node.nodeSize);
    const selection = Selection.near(this.view.state.doc.resolve(targetPos), dir);
    const atEndOfDocument = !(selection.$from.pos + 1 < this.view.state.doc.content.size);
    if (atEndOfDocument) {
      return CodeMirror.Pass;
    }
    this.view.dispatch(this.view.state.tr.setSelection(selection));
    this.view.focus();
  }
  update(node) {
    if (node.type != this.node.type)
      return false;
    this.node = node;
    const change = computeChange(this.cm.getValue(), node.textContent);
    if (change) {
      this.updating = true;
      this.cm.replaceRange(change.text, this.cm.posFromIndex(change.from), this.cm.posFromIndex(change.to));
      this.updating = false;
    }
    return true;
  }
  selectNode() {
    this.cm.focus();
  }
  stopEvent() {
    return true;
  }
}
function computeChange(oldVal, newVal) {
  if (oldVal == newVal)
    return null;
  let start = 0;
  let oldEnd = oldVal.length;
  let newEnd = newVal.length;
  while (start < oldEnd && oldVal.charCodeAt(start) == newVal.charCodeAt(start))
    ++start;
  while (oldEnd > start && newEnd > start && oldVal.charCodeAt(oldEnd - 1) == newVal.charCodeAt(newEnd - 1)) {
    oldEnd--;
    newEnd--;
  }
  return { from: start, to: oldEnd, text: newVal.slice(start, newEnd) };
}
const codeBlockPluginKey = new PluginKey("image");
const codeBlockPlugin = new Plugin({
  key: codeBlockPluginKey,
  props: {
    nodeViews: {
      code_block(node, view, getPos) {
        return new CodeBlockView(node, view, getPos);
      }
    }
  }
});
const ProsemirrorMenu$6 = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(UndoControl$1, null), /* @__PURE__ */ React.createElement(RedoControl$1, null));
const UndoControl$1 = () => {
  const { editorView } = useEditorStateContext();
  const undoChange = () => {
    const { state, dispatch } = editorView.view;
    undo(state, dispatch);
  };
  const tooltip = formatKeymap("Undo Mod-Z");
  return /* @__PURE__ */ React.createElement(MenuButton, {
    "data-tooltip": tooltip,
    title: tooltip,
    "data-side": "top",
    onClick: undoChange,
    disabled: undoDepth(editorView.view.state) < 1
  }, /* @__PURE__ */ React.createElement(UndoIcon, null));
};
const RedoControl$1 = () => {
  const { editorView } = useEditorStateContext();
  const redoChange = () => {
    const { state, dispatch } = editorView.view;
    redo(state, dispatch);
  };
  const tooltip = formatKeymap("Redo Mod-Shift-Z");
  return /* @__PURE__ */ React.createElement(MenuButton, {
    "data-tooltip": tooltip,
    title: tooltip,
    "data-side": "top",
    onClick: redoChange,
    disabled: redoDepth(editorView.view.state) < 1
  }, /* @__PURE__ */ React.createElement(RedoIcon, null));
};
const MarkdownMenu$6 = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(UndoControl, null), /* @__PURE__ */ React.createElement(RedoControl, null));
const UndoControl = () => /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Undo",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React.createElement(UndoIcon, null));
const RedoControl = () => /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Redo",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React.createElement(RedoIcon, null));
const exitCodeMarkOnArrowRight = (view, event) => {
  if (event.key !== "ArrowRight")
    return false;
  const { selection, schema } = view.state;
  const { code: code2 } = schema.marks;
  if (!code2.isInSet(selection.$to.marks()))
    return false;
  const selectionIsAtEnd = selection.$to.node().nodeSize - 2 === selection.$to.parentOffset;
  if (!selectionIsAtEnd)
    return false;
  const { state, dispatch } = view;
  dispatch(state.tr.insertText(" ", selection.$to.pos).removeMark(selection.$to.pos, selection.$to.pos + 1, code2));
  return true;
};
const inlinePluginKey = new PluginKey("inline");
const inlinePlugin = new Plugin({
  key: inlinePluginKey,
  props: {
    handleKeyDown(view, event) {
      return exitCodeMarkOnArrowRight(view, event);
    }
  }
});
const ProsemirrorMenu$5 = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(BoldControl, null), /* @__PURE__ */ React.createElement(ItalicControl, null), /* @__PURE__ */ React.createElement(StrikeControl, null));
const BoldControl = markControl({
  mark: "strong",
  Icon: BoldIcon,
  tooltip: formatKeymap("Bold Mod-B")
});
const ItalicControl = markControl({
  mark: "em",
  Icon: ItalicIcon,
  tooltip: formatKeymap("Italic Mod-I")
});
const StrikeControl = markControl({
  mark: "strike",
  Icon: StrikethroughIcon,
  tooltip: "Strike"
});
const MarkdownMenu$5 = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Bold",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React.createElement(BoldIcon, null)), /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Italic",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React.createElement(ItalicIcon, null)), /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Strike",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React.createElement(StrikethroughIcon, null)));
function toggleBulletList(state, dispatch) {
  const lift = liftListItem(state.schema.nodes.list_item);
  const wrap = wrapInList(state.schema.nodes.bullet_list);
  const canDo = wrap(state, dispatch) || lift(state, dispatch);
  return canDo;
}
function toggleOrderedList(state, dispatch) {
  const lift = liftListItem(state.schema.nodes.list_item);
  const wrap = wrapInList(state.schema.nodes.ordered_list);
  return wrap(state, dispatch) || lift(state, dispatch);
}
const ProsemirrorMenu$4 = (props) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(BulletList$1, __spreadValues({}, props)), /* @__PURE__ */ React.createElement(OrderedList$1, __spreadValues({}, props)));
const BulletList$1 = commandControl(toggleBulletList, UnorderedListIcon, "Unordered List", formatKeymap("Unordered List Mod-Alt-8"));
const OrderedList$1 = commandControl(toggleOrderedList, OrderedListIcon, "Ordered List", formatKeymap("Ordered List Mod-Alt-7"));
const MarkdownMenu$4 = (props) => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(BulletList, __spreadValues({}, props)), /* @__PURE__ */ React.createElement(OrderedList, __spreadValues({}, props)));
const BulletList = () => /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Unordered List",
  disabled: true
}, /* @__PURE__ */ React.createElement(UnorderedListIcon, null));
const OrderedList = () => /* @__PURE__ */ React.createElement(MenuButton, {
  "data-tooltip": "Ordered List",
  disabled: true
}, /* @__PURE__ */ React.createElement(OrderedListIcon, null));
function wrapInBlockquote(state, dispatch) {
  const { blockquote: blockquote2 } = state.schema.nodes;
  const { start, node } = findParentNodeOfType(blockquote2)(state.selection) || {};
  if (start && node) {
    const { tr } = state;
    const nodeRange = tr.doc.resolve(start + 1).blockRange(tr.doc.resolve(start + node.nodeSize - 2));
    if (nodeRange) {
      if (dispatch)
        return dispatch(tr.lift(nodeRange, 0));
      else
        return true;
    }
  }
  return wrapIn(state.schema.nodes.blockquote)(state, dispatch);
}
const ProsemirrorMenu$3 = commandControl(wrapInBlockquote, QuoteIcon, "Blockquote", "Blockquote");
const MarkdownMenu$3 = () => /* @__PURE__ */ React__default.createElement(MenuButton, {
  "data-tooltip": "Quote",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React__default.createElement(QuoteIcon, null));
const buildCellSelection = (pos, classes, tableMap, table, state) => {
  if (classes.includes("tina_table_header_ext_top_left"))
    return buildTableSelection(pos, tableMap, table, state.doc);
  if (classes.includes("tina_table_header_ext_left"))
    return buildColumnSelection(pos, tableMap, table, state.doc);
  if (classes.includes("tina_table_header_ext_top"))
    return buildRowSelection(pos, tableMap, table, state.doc);
};
const buildColumnSelection = (pos, tableMap, table, doc2) => {
  const { width: width2 } = tableMap;
  const colStart = tableMap.map.findIndex((c) => c === pos - table.start);
  return new CellSelection(doc2.resolve(tableMap.map[colStart + width2 - 1] + table.start), doc2.resolve(pos));
};
const buildRowSelection = (pos, tableMap, table, doc2) => {
  const { width: width2, height } = tableMap;
  const rowStart = tableMap.map.findIndex((c) => c === pos - table.start);
  return new CellSelection(doc2.resolve(tableMap.map[rowStart + width2 * (height - 1)] + table.start), doc2.resolve(pos));
};
const buildTableSelection = (pos, tableMap, table, doc2) => new CellSelection(doc2.resolve(tableMap.map[tableMap.map.length - 1] + table.start), doc2.resolve(pos));
const buildExtendedHeaders = (tableNode, selection) => {
  const tableMap = TableMap.get(tableNode.node);
  const colSelection = selection.isColSelection && selection.isColSelection();
  const rowSelection = selection.isRowSelection && selection.isRowSelection();
  let decorations = buildExtendedTableHeaders(tableNode, colSelection, rowSelection);
  decorations = [
    ...decorations,
    ...buildExtendedColumnHeaders(tableNode, tableMap, selection, colSelection)
  ];
  decorations = [
    ...decorations,
    ...buildExtendedRowHeaders(tableNode, tableMap, selection, rowSelection)
  ];
  return decorations;
};
const buildExtendedColumnHeaders = (tableNode, tableMap, selection, colSelection) => {
  const decorations = [];
  const cellMap = tableMap.map;
  for (let i = 0; i < tableMap.width; i++) {
    const div = document.createElement("div");
    div.classList.add("tina_table_header_ext_top");
    if (colSelection && selection.ranges.some((r) => r.$from.pos === tableNode.start + cellMap[i] + 1)) {
      div.classList.add("tina_table_header_ext_top_selected");
    }
    decorations.push(Decoration.widget(tableNode.start + cellMap[i] + 1, div));
  }
  return decorations;
};
const buildExtendedRowHeaders = (tableNode, tableMap, selection, rowSelection) => {
  const decorations = [];
  const cellMap = tableMap.map;
  for (let i = 0; i < tableMap.height; i++) {
    const div = document.createElement("div");
    div.classList.add("tina_table_header_ext_left");
    if (rowSelection && selection.ranges.some((r) => r.$from.pos === tableNode.start + cellMap[i * tableMap.width] + 1)) {
      div.classList.add("tina_table_header_ext_left_selected");
    }
    decorations.push(Decoration.widget(tableNode.start + cellMap[i * tableMap.width] + 1, div));
  }
  return decorations;
};
const buildExtendedTableHeaders = (tableNode, colSelection, rowSelection) => {
  const decorations = [];
  const div = document.createElement("div");
  div.classList.add("tina_table_header_ext_top_left");
  if (colSelection && rowSelection) {
    div.classList.add("tina_table_header_ext_top_left_selected");
  }
  decorations.push(Decoration.widget(tableNode.start + 2, div));
  return decorations;
};
const tablePluginKey = new PluginKey("table");
const tablePlugin = new Plugin({
  key: tablePluginKey,
  state: {
    init: () => {
      return { deco: DecorationSet.empty };
    },
    apply(tr, prev, oldState, newState) {
      if (tr.getMeta("image_clicked") === false)
        return prev;
      const { selection } = newState;
      if (selection) {
        const { table } = newState.schema.nodes;
        const tableNode = findParentNodeOfType(table)(selection);
        if (tableNode) {
          const selectionNotChanged = selection === oldState.selection;
          const tableNotChanged = (tableNode && tableNode.node.nodeSize) === (prev.selectedTable && prev.selectedTable.node.nodeSize) && (tableNode && tableNode.start) === (prev.selectedTable && prev.selectedTable.start);
          if (selectionNotChanged && tableNotChanged)
            return prev;
          const decorations = buildExtendedHeaders(tableNode, selection);
          if (decorations.length)
            return {
              deco: DecorationSet.create(newState.doc, decorations),
              tableMap: TableMap.get(tableNode.node),
              selectedTable: tableNode
            };
        }
      }
      return { deco: DecorationSet.empty };
    }
  },
  props: {
    decorations(state) {
      return this.getState(state).deco;
    },
    handleClickOn(view, _1, _2, nodePos, event, direct) {
      if (!direct)
        return false;
      const targetClasses = event.target.classList;
      const { state, dispatch } = view;
      const tablePluginState = tablePluginKey.getState(state);
      const { tableMap, selectedTable } = tablePluginState;
      const cellSelection = buildCellSelection(nodePos, targetClasses.value, tableMap, selectedTable, state);
      if (cellSelection)
        dispatch(state.tr.setSelection(cellSelection));
      return false;
    }
  }
});
const createCell = (cellType, cellContent) => {
  if (cellContent)
    return cellType.createChecked(null, cellContent);
  return cellType.createAndFill();
};
const insertTable = (state, dispatch) => {
  if (!dispatch)
    return true;
  const {
    table_cell: tableCell,
    table_header: tableHeader,
    table_row: tableRow,
    table
  } = state.schema.nodes;
  const rowsCount = 3;
  const colsCount = 3;
  const cells = [];
  const headerCells = [];
  for (let i = 0; i < colsCount; i += 1) {
    headerCells.push(createCell(tableHeader));
    cells.push(createCell(tableCell));
  }
  const rows = [];
  for (let i = 0; i < rowsCount; i += 1) {
    rows.push(tableRow.createChecked(null, i === 0 ? headerCells : cells));
  }
  const newTable = table.createChecked(null, rows);
  const { selection, tr } = state;
  const { $from, $to } = selection;
  const start = $from.pos - 1;
  const end = $to.pos < state.doc.content.size ? $to.pos + 1 : $to.pos;
  dispatch(tr.replaceWith(start, end, newTable).setSelection(new TextSelection(tr.doc.resolve($from.pos + 1))).scrollIntoView());
  return true;
};
function insertTableCmd(state, dispatch) {
  const { table, code_block: code_block2 } = state.schema.nodes;
  const { selection } = state;
  const currentNode = selection.$to.node(selection.$to.depth);
  if (currentNode && currentNode.type === code_block2)
    return false;
  const tableParent = findParentNodeOfType(table)(selection);
  if (tableParent)
    return false;
  return insertTable(state, dispatch);
}
const ProsemirrorMenu$2 = commandControl(insertTableCmd, TableIcon, "Table", "Table");
const MarkdownMenu$2 = () => /* @__PURE__ */ React__default.createElement(MenuButton, {
  "data-tooltip": "Table",
  disabled: true
}, /* @__PURE__ */ React__default.createElement(TableIcon, null));
function insertImage(state, dispatch, src) {
  const nodeType = state.schema.nodes["image"];
  const image2 = nodeType.createAndFill({ src, alt: "", title: "" });
  if (dispatch) {
    dispatch(state.tr.replaceSelectionWith(image2).scrollIntoView());
  }
  return true;
}
function insertImageList(state, dispatch, imageSrc) {
  if (dispatch) {
    const nodeType = state.schema.nodes["image"];
    const { tr } = state;
    imageSrc.forEach((src) => {
      const image2 = nodeType.createAndFill({ src, alt: "", title: "" });
      tr.replaceSelectionWith(image2);
    });
    dispatch(tr.scrollIntoView());
  }
  return true;
}
const Identity = (str) => str;
class ImageView {
  constructor(node, view, previewSrc = Identity) {
    this.previewSrc = previewSrc;
    this.selectNode = () => {
      if (this.img) {
        this.img.style.outline = "4px solid #0084FF";
        this.img.classList.add("tina-selected-image");
      }
    };
    this.deselectNode = () => {
      if (this.img) {
        this.img.style.outline = "";
        this.img.classList.remove("tina-selected-image");
      }
    };
    this.destroy = () => {
      this.deselectNode();
    };
    this.node = node;
    this.view = view;
    this.dom = document.createElement("span");
    this.dom.classList.add("tinacms-image-wrapper");
    this.img = document.createElement("img");
    const { src, align, alt, title, width: width2, height } = node.attrs;
    this.updateImgSrc(src);
    if (height)
      this.img.style.height = height;
    if (width2)
      this.img.style.width = width2;
    if (align)
      this.img.classList.add(`align-${align}`);
    if (alt)
      this.img.alt = alt;
    if (title)
      this.img.title = title;
    this.dom.appendChild(this.img);
  }
  async updateImgSrc(src) {
    if (!this.img)
      return;
    try {
      this.img.src = await this.previewSrc(src);
    } catch {
      this.img.src = src;
    }
  }
  update(node) {
    if (this.img) {
      const { alt, title } = node.attrs;
      if (alt)
        this.img.alt = alt;
      if (title)
        this.img.title = title;
    }
    return true;
  }
}
const imagePluginKey = new PluginKey("image");
const setSelectionAtPos = (state, dispatch, pos) => {
  dispatch(state.tr.setSelection(new NodeSelection(state.tr.doc.resolve(pos))));
};
const insertImageFiles = (editorView, data, uploadImages) => {
  const files = [];
  for (let i = 0; i < data.files.length; i++) {
    const file = data.files[i];
    if (file.type.match("image.*"))
      files.push(file);
  }
  if (files.length) {
    const { state, dispatch } = editorView;
    dispatch(state.tr.setMeta("loading_images", files.length));
    const uploadPromise = uploadImages(files);
    uploadPromise.then((urls = []) => {
      dispatch(state.tr.setMeta("loading_images", 0));
      insertImageList(state, dispatch, urls);
      editorView.focus();
    });
    return true;
  }
  return false;
};
const imagePlugin = ({ previewSrc, upload: uploadImages }) => new Plugin({
  key: imagePluginKey,
  state: {
    init: () => {
      return { selectedImage: void 0 };
    },
    apply(tr, prev, _, newState) {
      if (tr.getMeta("loading_images") > 0) {
        const loadingImagesCount = tr.getMeta("loading_images");
        const div = document.createElement("div");
        for (let i = 0; i < loadingImagesCount; i++) {
          const childElement = document.createElement("div");
          childElement.classList.add("image_loading_indicator");
          div.appendChild(childElement);
        }
        return __spreadProps(__spreadValues({}, prev), {
          deco: DecorationSet.create(newState.doc, [
            Decoration.widget(newState.selection.$to.pos, div)
          ])
        });
      }
      if (tr.getMeta("loading_images") === 0) {
        return __spreadProps(__spreadValues({}, prev), {
          deco: void 0
        });
      }
      if (prev && prev.selectedImage) {
        const { pos } = prev.selectedImage;
        if (!tr.doc.nodeAt(pos))
          return __spreadProps(__spreadValues({}, prev), {
            selectedImage: void 0
          });
      }
      const selectedImage = tr.getMeta("image_clicked");
      if (selectedImage)
        return __spreadProps(__spreadValues({}, prev), { selectedImage });
      if (selectedImage === false)
        return __spreadProps(__spreadValues({}, prev), { selectedImage: void 0 });
      return prev;
    }
  },
  props: {
    nodeViews: {
      image(node, view) {
        return new ImageView(node, view, previewSrc);
      }
    },
    decorations(state) {
      return this.getState(state).deco;
    },
    handleKeyDown(view, event) {
      const { state, dispatch } = view;
      const { selection, schema } = state;
      if (event.key === "Escape") {
        dispatch(state.tr.setMeta("image_clicked", false));
      } else if (event.key === "Backspace" && selection.$to.nodeBefore && selection.$to.nodeBefore.type === schema.nodes.image) {
        setSelectionAtPos(state, dispatch, selection.$to.pos - 1);
        return true;
      } else if (event.key === "Delete" && selection.$to.nodeAfter && selection.$to.nodeAfter.type === schema.nodes.image) {
        setSelectionAtPos(state, dispatch, selection.$to.pos);
        return true;
      }
      return false;
    },
    handleClickOn(view, _1, node, nodePos, _2, direct) {
      if (!direct)
        return false;
      const { state, dispatch } = view;
      const { image: image2 } = view.state.schema.nodes;
      if (node.type === image2) {
        dispatch(state.tr.setMeta("image_clicked", { pos: nodePos, node }));
      } else {
        dispatch(state.tr.setMeta("image_clicked", false));
      }
      return false;
    },
    handleDrop(editorView, event, _, moved) {
      if (moved || !uploadImages)
        return false;
      event.preventDefault();
      const dataTransfer = event.dataTransfer;
      if (!dataTransfer)
        return false;
      return insertImageFiles(editorView, dataTransfer, uploadImages);
    },
    handlePaste(editorView, event) {
      if (!uploadImages)
        return false;
      event.preventDefault();
      const clipboardData = event.clipboardData;
      if (!clipboardData)
        return false;
      return insertImageFiles(editorView, clipboardData, uploadImages);
    }
  }
});
const ProsemirrorMenu$1 = ({ imageProps }) => {
  const cms = useCMS();
  const menuButtonRef = useRef();
  const { editorView } = useEditorStateContext();
  if (!imageProps || !imageProps.upload)
    return null;
  const { parse, mediaDir } = imageProps;
  const insertImageInEditor = (src) => {
    if (!editorView)
      return;
    const { state, dispatch } = editorView.view;
    insertImage(state, dispatch, src);
    editorView.view.focus();
  };
  async function onMediaSelect(media) {
    var _a, _b;
    if (media) {
      const parseFunc = ((_b = (_a = cms.media) == null ? void 0 : _a.store) == null ? void 0 : _b.parse) || parse;
      insertImageInEditor(parseFunc(media));
    }
  }
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(MenuButton, {
    title: "Image",
    ref: menuButtonRef,
    onClick: () => {
      cms.media.open({
        directory: mediaDir || "/",
        onSelect: onMediaSelect
      });
    }
  }, /* @__PURE__ */ React__default.createElement(MediaIcon, null)));
};
const MarkdownMenu$1 = ({ uploadImages }) => uploadImages ? /* @__PURE__ */ React__default.createElement(MenuButton, {
  "data-testid": "image-menu",
  "data-tooltip": "Image",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React__default.createElement(MediaIcon, null)) : null;
const ImageEdit = () => {
  const { editorView } = useEditorStateContext();
  const view = editorView.view;
  const imagePluginState = imagePluginKey.getState(view.state);
  if (!imagePluginState || !imagePluginState.selectedImage)
    return null;
  const { node, pos } = imagePluginState.selectedImage;
  const { link: link2 } = view.state.schema.marks;
  const linkMark = node.marks.find((mark) => mark.type === link2);
  const [title, setTitle] = useState(node.attrs.title);
  const [alt, setAlt] = useState(node.attrs.alt);
  const [linkTitle, setLinkTitle] = useState(linkMark && linkMark.attrs.title);
  const [linkSrc, setLinkSrc] = useState(linkMark && linkMark.attrs.href);
  const { top, left } = view.coordsAtPos(pos);
  const [modalTop, setModalTop] = useState(top);
  const [modalLeft, setModalLeft] = useState(left);
  const wrapperRef = useRef();
  const inputRef = useRef();
  const imageRef = useRef();
  const [linked, toggleLinked] = useState(!!linkMark);
  function positionImage(scroll) {
    const image2 = document.getElementsByClassName("tina-selected-image")[0];
    const wysiwygWrapper = document.getElementsByClassName("wysiwyg-wrapper")[0];
    if (image2 && (imageRef.current !== image2 || scroll) && wrapperRef.current) {
      imageRef.current = image2;
      const wrapperDimensions = wrapperRef.current.getBoundingClientRect();
      setModalLeft(image2.clientWidth / 2 + findElementOffsetLeft(image2, wysiwygWrapper) - wrapperDimensions.width / 2);
      setModalTop(findElementOffsetTop(image2, wysiwygWrapper));
    }
  }
  useEffect(() => {
    const debouncedPositionImage = debounce(() => positionImage(true), 10);
    window.addEventListener("scroll", debouncedPositionImage);
    return () => {
      window.removeEventListener("scroll", debouncedPositionImage);
    };
  });
  useEffect(() => {
    setLinkTitle(linkMark ? linkMark.attrs.title : "");
    setLinkSrc(linkMark ? linkMark.attrs.href : "");
    toggleLinked(!!linkMark);
  }, [linkMark]);
  useEffect(() => {
    setTitle(node.attrs.title);
    setAlt(node.attrs.alt);
  }, [imagePluginState.selectedImage.node]);
  useEffect(() => {
    setTimeout(() => {
      if (inputRef.current)
        inputRef.current.focus();
    });
  }, [inputRef]);
  useEffect(positionImage);
  const updateNodeAttrs = () => {
    const { dispatch, state } = view;
    const { image: image2 } = state.schema.nodes;
    const { link: link22 } = state.schema.marks;
    const { tr } = state;
    if (linked && (linkSrc || linkTitle)) {
      tr.addMark(pos, pos + 1, link22.create({ href: linkSrc, title: linkTitle }));
    } else {
      tr.removeMark(pos, pos + 1, link22);
    }
    tr.setNodeMarkup(pos, image2, __spreadProps(__spreadValues({}, node.attrs), {
      alt,
      title
    })).setSelection(new NodeSelection(tr.doc.resolve(pos)));
    dispatch(tr);
    closeImageSettings();
    view.focus();
  };
  const closeImageSettings = () => {
    const { dispatch, state } = view;
    dispatch(state.tr.setMeta("image_clicked", false));
    setTitle("");
    setAlt("");
    setLinkTitle("");
    setLinkSrc("");
    view.focus();
  };
  const handleKeyPress = (evt) => {
    if (evt.key === "Escape")
      closeImageSettings();
    if (evt.key === "Enter")
      updateNodeAttrs();
  };
  return /* @__PURE__ */ React__default.createElement(LinkPopup$1, {
    top: modalTop,
    left: modalLeft,
    ref: wrapperRef,
    onKeyDown: handleKeyPress
  }, /* @__PURE__ */ React__default.createElement(LinkLabel$1, null, "Title"), /* @__PURE__ */ React__default.createElement(LinkInput$1, {
    placeholder: "Enter Title",
    type: "text",
    ref: inputRef,
    value: title,
    onChange: (evt) => setTitle(evt.target.value)
  }), /* @__PURE__ */ React__default.createElement(LinkLabel$1, null, "Alt"), /* @__PURE__ */ React__default.createElement(LinkInput$1, {
    placeholder: "Enter Alt Text",
    type: "text",
    value: alt,
    onChange: (evt) => setAlt(evt.target.value)
  }), /* @__PURE__ */ React__default.createElement(ToggleElement, null, /* @__PURE__ */ React__default.createElement(ToggleInput, {
    id: "toggleImageLink",
    onChange: () => {
      toggleLinked(!linked);
      if (!linked) {
        setLinkTitle("");
        setLinkSrc("");
      }
    },
    type: "checkbox"
  }), /* @__PURE__ */ React__default.createElement(ToggleLabel, {
    htmlFor: "toggleImageLink",
    role: "switch"
  }, "Insert Link", /* @__PURE__ */ React__default.createElement(ToggleSwitch, {
    checked: linked
  }, /* @__PURE__ */ React__default.createElement("span", null)))), linked && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(LinkLabel$1, null, "Link Title"), /* @__PURE__ */ React__default.createElement(LinkInput$1, {
    placeholder: "Enter Link Title",
    type: "text",
    value: linkTitle,
    onChange: (evt) => setLinkTitle(evt.target.value)
  }), /* @__PURE__ */ React__default.createElement(LinkLabel$1, null, "Link URL"), /* @__PURE__ */ React__default.createElement(LinkInput$1, {
    placeholder: "Enter Link URL",
    type: "text",
    value: linkSrc,
    onChange: (evt) => setLinkSrc(evt.target.value)
  })), /* @__PURE__ */ React__default.createElement(LinkActions$1, null, /* @__PURE__ */ React__default.createElement(CancelLink, {
    onClick: closeImageSettings
  }, "Cancel"), /* @__PURE__ */ React__default.createElement(SaveLink$1, {
    onClick: updateNodeAttrs
  }, "Save")));
};
const LinkPopup$1 = styled.span`
  background-color: #f6f6f9;
  position: absolute;
  border-radius: var(--tina-radius-small);
  border: 1px solid var(--tina-color-grey-2);
  filter: drop-shadow(0px 4px 8px rgba(48, 48, 48, 0.1))
    drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.12));
  transform-origin: 50% 0;
  overflow: visible;
  padding: 12px;
  z-index: 10;
  width: 256px;
  left: ${({ left }) => `${left}px`};
  top: ${({ top }) => `${top}px`};
`;
const LinkLabel$1 = styled.label`
  display: block;
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  color: var(--tina-color-grey-8);
  margin-bottom: 3px;
`;
const LinkInput$1 = styled.input`
  position: relative;
  background-color: white;
  border-radius: var(--tina-radius-small);
  font-size: var(--tina-font-size-1);
  line-height: 1.35;
  transition: all 85ms ease-out;
  padding: 8px 12px;
  border: 1px solid var(--tina-color-grey-2);
  width: 100%;
  margin: 0 0 8px 0;
  outline: none;
  box-shadow: 0 0 0 2px transparent;

  &:hover {
    box-shadow: 0 0 0 2px var(--tina-color-grey-3);
  }

  &:focus {
    box-shadow: 0 0 0 2px var(--tina-color-primary);
  }

  &::placeholder {
    font-size: var(--tina-font-size-2);
    color: #cfd3d7;
  }
`;
const LinkActions$1 = styled.div`
  display: flex;
  justify-content: flex-end;
  padding-top: 4px;
`;
const SaveLink$1 = styled.button`
  text-align: center;
  border: 0;
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: var(--tina-color-primary);
  color: white;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: var(--tina-color-primary-light);
  }
  &:active {
    background-color: var(--tina-color-primary-dark);
  }
`;
const CancelLink = styled.button`
  text-align: center;
  border: 1px solid var(--tina-color-grey-2);
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: white;
  color: var(--tina-color-primary);
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: var(--tina-color-grey-1);
    opacity: 1;
  }
  &:active {
    background-color: var(--tina-color-primary-dark);
  }
`;
const ToggleElement = styled.div`
  display: block;
  position: relative;
  margin: 0 0 8px 0;
`;
const ToggleLabel = styled.label`
  background: none;
  padding: 0;
  opacity: ${(props) => props.disabled ? "0.4" : "1"};
  outline: none;
  height: 28px;
  pointer-events: ${(props) => props.disabled ? "none" : "inherit"};
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  line-height: 1.35;
  color: var(--tina-color-grey-8);
`;
const ToggleSwitch = styled.div`
  position: relative;
  width: 48px;
  height: 28px;
  border-radius: var(--tina-radius-big);
  background-color: white;
  border: 1px solid var(--tina-color-grey-2);
  pointer-events: none;
  margin-left: -2px;
  span {
    position: absolute;
    border-radius: var(--tina-radius-big);
    left: 2px;
    top: 50%;
    width: calc(28px - 6px);
    height: calc(28px - 6px);
    background: ${(p) => p.checked ? "var(--tina-color-primary)" : "var(--tina-color-grey-3)"};
    transform: translate3d(${(p) => p.checked ? "20px" : "0"}, -50%, 0);
    transition: all 150ms ease-out;
  }
`;
const ToggleInput = styled.input`
  position: absolute;
  left: 0;
  top: 0;
  width: 48px;
  height: 28px;
  opacity: 0;
  margin: 0;
  cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
`;
const Loader = () => {
  const markerImageLoader = document.getElementsByClassName("image_loading_indicator");
  if (!markerImageLoader.length)
    return null;
  const loaders = [];
  for (let i = 0; i < markerImageLoader.length; i++) {
    loaders.push(ReactDOM__default.createPortal(/* @__PURE__ */ React__default.createElement(ImagePlaceholder, null), markerImageLoader[0]));
  }
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, loaders);
};
const ImagePlaceholder = styled((_c) => {
  var styleProps = __objRest(_c, []);
  return /* @__PURE__ */ React__default.createElement("div", __spreadValues({}, styleProps), /* @__PURE__ */ React__default.createElement(LoadingDots, {
    color: "var(--tina-color-primary)"
  }));
})`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: center;
  padding: 64px;
  background-color: rgba(100, 100, 100, 0.07);
`;
const IMG_REGEX = /\.(jpe?g|png)/;
const HTTP_LINK_REGEX = /\bhttps?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:;%_\+.,~#?&//=]*)/g;
const linkify = function(fragment) {
  const linkified = [];
  fragment.forEach(function(child) {
    if (child.isText) {
      const text2 = child.text;
      let pos = 0;
      let match;
      const link2 = child.type.schema.marks["link"];
      const img = child.type.schema.nodes["image"];
      const matches = [];
      while (match = HTTP_LINK_REGEX.exec(text2)) {
        const start = match.index;
        const end = start + match[0].length;
        matches.push({ start, end });
      }
      matches.forEach(({ start, end }) => {
        if (start > 0) {
          linkified.push(child.cut(pos, start));
        }
        let attrs2;
        const urlText = text2.slice(start, end);
        if (IMG_REGEX.test(urlText)) {
          attrs2 = { src: urlText, title: "", alt: "" };
          linkified.push(img.create(attrs2));
        } else {
          attrs2 = { href: urlText, title: urlText };
          linkified.push(child.cut(start, end).mark(link2.create(attrs2).addToSet(child.marks)));
        }
        pos = end;
      });
      if (pos < text2.length) {
        linkified.push(child.cut(pos));
      }
    } else {
      linkified.push(child.copy(linkify(child.content)));
    }
  });
  return Fragment.fromArray(linkified);
};
const linkPluginKey = new PluginKey("image");
function linkPlugin() {
  let shiftKey;
  return new Plugin({
    key: linkPluginKey,
    state: {
      init: () => {
        return { showLinkForm: false };
      },
      apply(tr, prev, _) {
        if (tr.getMeta("show_link_toolbar") === false) {
          return {
            show_link_toolbar: false
          };
        }
        if (tr.getMeta("show_link_toolbar")) {
          return {
            show_link_toolbar: true
          };
        }
        return prev;
      }
    },
    props: {
      transformPasted(slice) {
        if (shiftKey) {
          return slice;
        }
        return new Slice(linkify(slice.content), slice.openStart, slice.openEnd);
      },
      handleKeyDown(_x, e) {
        shiftKey = e.shiftKey;
        return false;
      },
      handleClickOn(view, _1) {
        const { dispatch, state } = view;
        const { tr } = state;
        dispatch(tr.setMeta("show_link_toolbar", false));
      }
    }
  });
}
function markExtend($cursor, markType) {
  window.$cursor = $cursor;
  let startIndex = $cursor.index();
  let endIndex = $cursor.indexAfter();
  if (startIndex === $cursor.parent.childCount) {
    startIndex--;
    endIndex--;
  }
  const mark = markType.isInSet($cursor.parent.child(startIndex).marks);
  if (!mark)
    return;
  const hasMark = (index) => mark.isInSet($cursor.parent.child(index).marks);
  while (startIndex > 0 && hasMark(startIndex - 1)) {
    startIndex--;
  }
  while (endIndex < $cursor.parent.childCount && hasMark(endIndex)) {
    endIndex++;
  }
  let startPos = $cursor.start();
  let endPos = startPos;
  for (let i = 0; i < endIndex; i++) {
    const size = $cursor.parent.child(i).nodeSize;
    if (i < startIndex)
      startPos += size;
    endPos += size;
  }
  return { from: startPos, to: endPos, mark };
}
function unmountLinkForm(view) {
  const { dispatch, state } = view;
  dispatch(state.tr.setMeta("show_link_toolbar", false));
}
function updateLinkBeingEdited(state, dispatch, attrs2) {
  if (dispatch) {
    const { selection, schema, tr } = state;
    const mark = markExtend(selection.$anchor, schema.marks.link);
    if (mark) {
      tr.addMark(mark.from, mark.to, schema.marks.link.create(attrs2));
    }
    tr.setMeta("show_link_toolbar", false);
    dispatch(tr);
  }
  return true;
}
function removeLinkBeingEdited(state, dispatch) {
  if (dispatch) {
    const { selection, schema, tr } = state;
    const mark = markExtend(selection.$anchor, schema.marks.link);
    if (mark) {
      tr.removeMark(mark.from, mark.to, mark.mark);
    }
    tr.setMeta("show_link_toolbar", false);
    dispatch(tr);
  }
  return true;
}
const openLinkPopup = (state, dispatch) => {
  const { schema, selection } = state;
  const { marks: marks2 } = schema;
  if (selection.empty && !isMarkPresent(state, marks2.link))
    return false;
  const tr = state.tr.setMeta("show_link_toolbar", true);
  if (!isMarkPresent(state, marks2.link)) {
    const { $to, $from } = selection;
    tr.addMark($from.pos, $to.pos, marks2.link.create({
      href: "",
      title: ""
    }));
  }
  return dispatch(tr);
};
const ProsemirrorMenu = markControl({
  mark: "link",
  Icon: LinkIcon,
  tooltip: formatKeymap("Link Mod-K"),
  selectionOnly: true,
  noMix: ["code"],
  isDisabled: (view) => {
    const { schema, selection } = view.state;
    const { marks: marks2, nodes: nodes2 } = schema;
    if (selection.empty && !isMarkPresent(view.state, marks2.link))
      return true;
    const selectedNode = selection.$from.node();
    const imagePluginState = imagePluginKey.getState(view.state);
    return !!(imagePluginState == null ? void 0 : imagePluginState.selectedImage) || selectedNode && selectedNode.type === nodes2.code_block;
  },
  onMenuOptionClick: (view) => {
    const { state, dispatch } = view;
    return openLinkPopup(state, dispatch);
  }
});
const MarkdownMenu = () => /* @__PURE__ */ React__default.createElement(MenuButton, {
  "data-tooltip": "Link",
  "data-side": "top",
  disabled: true
}, /* @__PURE__ */ React__default.createElement(LinkIcon, null));
class InnerForm extends React.Component {
  constructor() {
    super(...arguments);
    this.state = {
      href: this.props.href || ""
    };
    this.inputRef = React.createRef();
    this.setHref = ({ target: { value } }) => this.setState(() => ({ href: value }));
    this.save = () => this.props.onChange(this.state);
    this.onEnterSave = (e) => {
      if (e.key === "Enter") {
        this.save();
      }
    };
    this.onEscapeCancel = (e) => {
      if (e.keyCode === 27) {
        this.closeModal();
      }
    };
  }
  componentDidMount() {
    document.addEventListener("keydown", this.onEscapeCancel);
    if (this.inputRef.current)
      this.inputRef.current.focus();
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.onEscapeCancel);
  }
  componentDidUpdate(prevProps) {
    const { href } = this.props;
    if (href !== prevProps.href)
      this.setState(() => ({ href }));
  }
  closeModal() {
    const { href } = this.state;
    const { cancel, removeLink, href: originalHref } = this.props;
    if (!href && !originalHref)
      removeLink();
    cancel();
  }
  render() {
    const { removeLink, style = {} } = this.props;
    const { href } = this.state;
    return /* @__PURE__ */ React.createElement(LinkPopup, {
      style: __spreadValues({}, style)
    }, /* @__PURE__ */ React.createElement(LinkLabel, null, "URL"), /* @__PURE__ */ React.createElement(LinkInput, {
      ref: this.inputRef,
      placeholder: "Enter URL",
      type: "text",
      value: href,
      onChange: this.setHref,
      onKeyPress: this.onEnterSave
    }), /* @__PURE__ */ React.createElement(LinkActions, null, /* @__PURE__ */ React.createElement(DeleteLink, {
      onClick: removeLink
    }, "Delete"), /* @__PURE__ */ React.createElement(SaveLink, {
      onClick: this.save,
      disabled: !href
    }, "Save")));
  }
}
const LinkPopupKeyframes = keyframes`
  0% {
    transform: scale3d(0.5,0.5,1)
  }
  100% {
    transform: scale3d(1, 1, 1);
  }
`;
const LinkPopup = styled.div`
  background-color: #f6f6f9;
  position: relative;
  height: max-content;
  border-radius: var(--tina-radius-small);
  border: 1px solid var(--tina-color-grey-2);
  filter: drop-shadow(0px 4px 8px rgba(48, 48, 48, 0.1))
    drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.12));
  transform-origin: 50% 0;
  animation: ${LinkPopupKeyframes} 85ms ease-out both 1;
  overflow: visible;
  padding: 12px;
  z-index: 10;
`;
const LinkLabel = styled.label`
  display: block;
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  color: var(--tina-color-grey-8);
  margin-bottom: 3px;
`;
const LinkInput = styled.input`
  position: relative;
  background-color: white;
  border-radius: var(--tina-radius-small);
  font-size: var(--tina-font-size-1);
  line-height: 1.35;
  transition: all 85ms ease-out;
  padding: 8px 12px;
  border: 1px solid var(--tina-color-grey-2);
  width: 100%;
  margin: 0 0 8px 0;
  outline: none;
  box-shadow: 0 0 0 2px transparent;

  &:hover {
    box-shadow: 0 0 0 2px var(--tina-color-grey-3);
  }

  &:focus {
    box-shadow: 0 0 0 2px #0084ff;
  }

  &::placeholder {
    font-size: var(--tina-font-size-2);
    color: #cfd3d7;
  }
`;
const LinkActions = styled.div`
  display: flex;
  justify-content: flex-end;
  padding-top: 4px;
`;
const SaveLink = styled.button`
  text-align: center;
  border: 0;
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: #0084ff;
  color: white;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: #2296fe;
  }
  &:active {
    background-color: #0574e4;
  }
  &:disabled {
    background-color: #d1d1d1;
    box-shadow: none;
  }
`;
const DeleteLink = styled.button`
  text-align: center;
  border: 1px solid var(--tina-color-grey-2);
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: white;
  color: #0084ff;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: #f6f6f9;
    opacity: 1;
  }
  &:active {
    background-color: #0574e4;
  }
`;
const width = 240;
const LinkForm = () => {
  const { editorView } = useEditorStateContext();
  const [position, setPosition] = useState(void 0);
  if (!editorView)
    return null;
  const { view } = editorView;
  const linkPluginState = linkPluginKey.getState(view.state);
  const { anchor, head } = view.state.selection;
  const selState = anchor < head ? anchor : head;
  const node = view.state.selection.empty ? view.domAtPos(selState).node : view.domAtPos(selState + 1).node;
  const clickTarget = node.parentNode;
  const onChange = (attrs2) => {
    updateLinkBeingEdited(view.state, view.dispatch, attrs2);
    view.focus();
  };
  const onCancel = () => {
    unmountLinkForm(view);
    view.focus();
  };
  const wrapperRef = createRef();
  useEffect(() => {
    if (!clickTarget || !wrapperRef.current) {
      setPosition(void 0);
      return;
    }
    const left2 = calcLeftOffset(clickTarget, wrapperRef.current, width);
    const top2 = `calc(32px + ${findElementOffsetTop(clickTarget) - findElementOffsetTop(wrapperRef.current)}px)`;
    const arrowOffset2 = calcArrowLeftOffset(clickTarget, wrapperRef.current);
    setPosition({ arrowOffset: arrowOffset2, left: left2, top: top2 });
  }, [linkPluginState]);
  if (!linkPluginState.show_link_toolbar) {
    return null;
  }
  const { arrowOffset, left, top } = position || {};
  const { state, dispatch } = view;
  let href = "";
  const linkMark = getMarkPresent(state, state.schema.marks.link);
  if (linkMark) {
    href = linkMark.attrs.href;
  }
  return /* @__PURE__ */ React.createElement("div", {
    ref: wrapperRef,
    style: { position: "absolute" }
  }, position && /* @__PURE__ */ React.createElement(LinkFormWrapper, null, /* @__PURE__ */ React.createElement(LinkArrow, {
    offset: arrowOffset,
    top
  }), /* @__PURE__ */ React.createElement(InnerForm, {
    style: {
      left,
      top,
      width: `${width}px`
    },
    removeLink: () => removeLinkBeingEdited(state, dispatch),
    onChange,
    href,
    cancel: onCancel
  })));
};
const LinkFormWrapper = styled.div`
  position: relative;
`;
const LinkArrow = styled.div`
  position: absolute;
  top: ${(p) => p.top};
  left: ${(p) => p.offset};
  margin-top: 3px;
  transform: translate3d(-50%, -100%, 0);
  width: 16px;
  height: 13px;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  background-color: #f6f6f9;
  z-index: 100;
`;
function calcLeftOffset(clickTarget, renderTarget, minWidth) {
  const ow_ct = clickTarget.offsetWidth;
  const ol_ct = findElementOffsetLeft(clickTarget);
  const ow_rt = renderTarget.parentElement.offsetWidth;
  const ol_rt = findElementOffsetLeft(renderTarget);
  const ol = ol_ct - ol_rt + ow_ct / 2 - minWidth / 2;
  const leftEdgeOutsideView = ol < -ol_rt;
  if (leftEdgeOutsideView) {
    return `-8px`;
  }
  const rightEdgeOutsideView = ol + minWidth > ow_rt;
  if (rightEdgeOutsideView) {
    return `calc(${ol - (ol + minWidth - ow_rt)}px + 8px)`;
  }
  return `${ol}px`;
}
function calcArrowLeftOffset(clickTarget, renderTarget, _minWidth) {
  const ow_ct = clickTarget.offsetWidth;
  const ol_ct = findElementOffsetLeft(clickTarget);
  const ol_rt = findElementOffsetLeft(renderTarget);
  const ol = ol_ct - ol_rt + ow_ct / 2;
  return `${ol}px`;
}
const MenuPlaceholder = styled.div`
  color: transparent;
  background: transparent;
  pointer-events: none;
  position: relative;
  display: block;
  height: ${(props) => props.menuBoundingBox.height}px;
  width: ${(props) => props.menuBoundingBox.width}px;
`;
const MenuWrapper = styled.div`
  position: relative;
  margin-bottom: 14px;
  z-index: var(--tina-z-index-1);

  ${(props) => props.menuFixed && css`
      position: fixed;
      width: ${props.menuBoundingBox.width}px;
      top: ${props.menuFixedTopOffset};
    `};
`;
const MenuContainer = styled.div`
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  flex-wrap: wrap;
  justify-content: space-between;
  position: relative;
  top: 0;
  width: 100%;
  background-color: white;
  border-radius: var(--tina-radius-small);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  border: 1px solid var(--tina-color-grey-2);
  overflow: hidden;
  z-index: var(--tina-z-index-0);
`;
const BaseMenubar = ({
  sticky = true,
  menus,
  plugins,
  popups
}) => {
  const [menuFixed, setMenuFixed] = useState(false);
  const isBrowser = typeof window !== `undefined`;
  const menuRef = useRef(null);
  const [menuBoundingBox, setMenuBoundingBox] = useState(null);
  const [menuOffsetTop, setMenuOffsetTop] = useState(null);
  const stickyOffset = typeof sticky === "string" ? sticky : "0";
  const scrollY = useRef(0);
  const scrollAnimationRef = useRef(0);
  const { editorView } = useEditorStateContext();
  const { mode } = useEditorModeContext();
  useEffect(() => {
    if (menuRef.current && sticky) {
      setMenuBoundingBox(menuRef.current.getBoundingClientRect());
    }
  }, [menuRef, editorView, mode]);
  useEffect(() => {
    if (!isBrowser || !menuRef.current || !sticky) {
      return;
    }
    const wysiwygWrapper = menuRef.current.parentElement;
    let ticking = false;
    const handleStickyMenu = () => {
      if (typeof menuOffsetTop === "number") {
        const btmBound = menuOffsetTop + ((wysiwygWrapper == null ? void 0 : wysiwygWrapper.offsetHeight) || 0);
        if (scrollY.current > menuOffsetTop && scrollY.current < btmBound) {
          setMenuFixed(true);
        } else {
          setMenuFixed(false);
        }
      }
      scrollAnimationRef.current = window.requestAnimationFrame(handleStickyMenu);
    };
    const handleResize = () => {
      if (menuRef.current) {
        const wasMenuFixed = menuFixed;
        setMenuFixed(false);
        setMenuBoundingBox(menuRef.current.getBoundingClientRect());
        setMenuFixed(wasMenuFixed);
      }
    };
    const handleScrollStart = debounce(() => {
      scrollY.current = window.scrollY;
      requestTick();
    }, 10, { leading: true, trailing: false });
    const handleScrollStop = debounce(() => {
      cancelAnimationFrame(scrollAnimationRef.current);
      ticking = false;
    }, 10);
    function requestTick() {
      if (!ticking) {
        scrollAnimationRef.current = window.requestAnimationFrame(handleStickyMenu);
      }
      ticking = true;
    }
    function calculateOffset() {
      if (wysiwygWrapper) {
        const stickyOffsetInt = parseInt(stickyOffset, 10);
        const offsetTop = findElementOffsetTop(wysiwygWrapper) - stickyOffsetInt;
        setMenuOffsetTop(offsetTop);
      }
    }
    document.readyState !== "complete" ? window.addEventListener("load", calculateOffset) : setTimeout(calculateOffset, 10);
    window.addEventListener("scroll", handleScrollStart);
    window.addEventListener("scroll", handleScrollStop);
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("scroll", handleScrollStart);
      window.removeEventListener("scroll", handleScrollStop);
      window.removeEventListener("resize", handleResize);
      cancelAnimationFrame(scrollAnimationRef.current);
    };
  }, [menuRef, menuBoundingBox, menuOffsetTop]);
  const preventProsemirrorFocusLoss = React__default.useCallback((e) => {
    e.stopPropagation();
    e.preventDefault();
  }, []);
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, menuFixed && /* @__PURE__ */ React__default.createElement(MenuPlaceholder, {
    menuBoundingBox
  }), /* @__PURE__ */ React__default.createElement(MenuWrapper, {
    menuFixedTopOffset: stickyOffset,
    menuFixed,
    menuBoundingBox,
    ref: menuRef,
    "data-testid": "base-menubar"
  }, /* @__PURE__ */ React__default.createElement(MenuPortalProvider, null, /* @__PURE__ */ React__default.createElement(MenuContainer, {
    onMouseDown: preventProsemirrorFocusLoss
  }, menus, plugins == null ? void 0 : plugins.map(({ name, MenuItem }) => /* @__PURE__ */ React__default.createElement(MenuItem, {
    key: name,
    mode,
    editorView
  }))))), popups);
};
const Menubar$1 = (_d) => {
  var _e = _d, { plugins, uploadImages } = _e, rest = __objRest(_e, ["plugins", "uploadImages"]);
  return /* @__PURE__ */ React__default.createElement(BaseMenubar, __spreadProps(__spreadValues({}, rest), {
    menus: [
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$8, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$5, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$1, {
        uploadImages
      }),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$2, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$3, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$7, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$4, null),
      /* @__PURE__ */ React__default.createElement(MarkdownMenu$6, null)
    ],
    plugins
  }));
};
const inputLineHeight = 20;
const MarkdownEditor = ({
  imageProps,
  onChange,
  value,
  plugins,
  sticky
}) => {
  const inputRef = useRef(null);
  const [val, setVal] = useState(value);
  const { browserFocused } = useBrowserFocusContext();
  useEffect(() => {
    const inputElm = inputRef.current;
    if (!inputElm)
      return;
    inputElm.focus({ preventScroll: true });
    inputElm.setSelectionRange(inputElm.value.length, inputElm.value.length);
  }, []);
  useEffect(() => {
    const inputElm = inputRef.current;
    if (!inputElm)
      return;
    inputElm.style.height = "0";
    inputElm.style.height = inputElm.scrollHeight + inputLineHeight + "px";
  });
  useEffect(() => {
    const editorElementFocused = inputRef.current === document.activeElement;
    if (browserFocused && editorElementFocused)
      return;
    setVal(value);
  }, [value]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Menubar$1, {
    sticky,
    uploadImages: imageProps == null ? void 0 : imageProps.upload,
    plugins
  }), /* @__PURE__ */ React.createElement("textarea", {
    "data-testid": "markdown-editing-textarea",
    ref: inputRef,
    value: val,
    onChange: (evt) => {
      const v = evt.target.value;
      setVal(v);
      onChange(v);
    },
    onFocus: (e) => {
      e.preventDefault();
      e.target.focus({ preventScroll: true });
    },
    className: "w-full shadow-inner focus:shadow-outline focus:border-blue-500 block bg-white border border-gray-200 text-gray-600 focus:text-gray-900 rounded-md p-5 mb-5",
    style: { minHeight: "100px" }
  }));
};
const code = {
  parseDOM: [{ tag: "code" }],
  toDOM() {
    return ["code"];
  },
  excludes: "em strong strike"
};
const em = {
  parseDOM: [
    { tag: "i" },
    { tag: "em" },
    {
      style: "font-style",
      getAttrs: (value) => value === "italic" && null
    }
  ],
  toDOM() {
    return ["em"];
  },
  excludes: "code"
};
const link$1 = {
  attrs: {
    href: {},
    title: { default: null }
  },
  inclusive: false,
  parseDOM: [
    {
      tag: "a[href]",
      getAttrs(dom) {
        return {
          href: dom.getAttribute("href"),
          title: dom.getAttribute("title")
        };
      }
    }
  ],
  toDOM(node) {
    return ["a", node.attrs];
  },
  toDocument(node) {
    return ["a", node.attrs];
  }
};
const strike = {
  parseDOM: [
    { tag: "strike" },
    { tag: "s" },
    { tag: "del" },
    {
      style: "text-decoration",
      getAttrs: (value) => value === "line-through" && null
    }
  ],
  toDOM: () => ["s", 0],
  excludes: "code"
};
const strong = {
  parseDOM: [
    { tag: "strong" },
    {
      tag: "b",
      getAttrs: (node) => {
        return node.style.fontWeight != "normal" && null;
      }
    },
    {
      style: "font-weight",
      getAttrs: (value) => {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
      }
    }
  ],
  toDOM() {
    return ["strong"];
  },
  excludes: "code"
};
const doc = {
  content: "block+"
};
const blockquote = {
  content: "block+",
  group: "block",
  defining: true,
  parseDOM: [{ tag: "blockquote" }],
  toDOM() {
    return ["blockquote", 0];
  }
};
const bullet_list = {
  content: "list_item+",
  group: "block",
  attrs: { tight: { default: false } },
  parseDOM: [
    {
      tag: "ul",
      getAttrs: (dom) => ({ tight: dom.hasAttribute("data-tight") })
    }
  ],
  toDOM(node) {
    return ["ul", { "data-tight": node.attrs.tight ? "true" : null }, 0];
  }
};
const code_block = {
  content: "text*",
  attrs: { params: { default: "" } },
  group: "block",
  code: true,
  defining: true,
  parseDOM: [
    {
      tag: "pre",
      preserveWhitespace: "full",
      getAttrs: (dom) => ({
        params: dom.getAttribute("data-params")
      })
    }
  ],
  toDOM(node) {
    return ["pre", { "data-params": node.attrs.params }, ["code", 0]];
  }
};
const hard_break = {
  inline: true,
  group: "inline",
  selectable: false,
  parseDOM: [{ tag: "br" }],
  toDOM() {
    return ["br"];
  }
};
function domAttrs(attrs2) {
  const domAttrs2 = {};
  for (const key in attrs2) {
    if (attrs2[key]) {
      domAttrs2[`forestry-${key}`] = attrs2[key];
    }
  }
  return domAttrs2;
}
function docAttrs(attrs2) {
  const domAttrs2 = {};
  for (const key in attrs2) {
    if (attrs2[key]) {
      domAttrs2[key] = attrs2[key];
    }
  }
  return domAttrs2;
}
function getAttrsWith(attrs2) {
  return function(dom) {
    return __spreadValues(__spreadValues({}, attrs2), getAttrs(dom));
  };
}
function getAttrs(dom) {
  const attrs2 = {};
  const attributes = dom.attributes;
  for (let i = 0; i < attributes.length; i++) {
    const attribute = attributes[i];
    if (attribute.value) {
      const name = attribute.name.startsWith("forestry-") ? attribute.name.slice(9) : attribute.name;
      attrs2[name] = attribute.value;
    }
  }
  return attrs2;
}
const heading = {
  attrs: {
    level: { default: 1 },
    class: { default: "" },
    id: { default: "" }
  },
  content: "inline*",
  marks: "_",
  group: "block",
  defining: true,
  parseDOM: [
    { tag: "h1", getAttrs: getAttrsWith({ level: 1 }) },
    { tag: "h2", getAttrs: getAttrsWith({ level: 2 }) },
    { tag: "h3", getAttrs: getAttrsWith({ level: 3 }) },
    { tag: "h4", getAttrs: getAttrsWith({ level: 4 }) },
    { tag: "h5", getAttrs: getAttrsWith({ level: 5 }) },
    { tag: "h6", getAttrs: getAttrsWith({ level: 6 }) }
  ],
  toDocument(node) {
    const _a = node.attrs, { level } = _a, other = __objRest(_a, ["level"]);
    return ["h" + level, docAttrs(other), 0];
  },
  toDOM(node) {
    const _a = node.attrs, { level } = _a, other = __objRest(_a, ["level"]);
    return ["h" + level, domAttrs(other), 0];
  }
};
const horizontal_rule = {
  group: "block",
  allowGapCursor: true,
  parseDOM: [{ tag: "hr" }],
  toDOM() {
    return ["hr"];
  }
};
const image = {
  inline: true,
  attrs: {
    src: {},
    align: { default: null },
    alt: { default: null },
    title: { default: null },
    width: { default: null },
    height: { default: null }
  },
  group: "inline",
  draggable: true,
  allowGapCursor: true,
  parseDOM: [
    {
      tag: "img[src]",
      getAttrs(dom) {
        return {
          src: dom.getAttribute("src"),
          title: dom.getAttribute("title"),
          alt: dom.getAttribute("alt"),
          align: getAlignFromDOM(dom),
          width: dom.getAttribute("width"),
          height: dom.getAttribute("height")
        };
      }
    }
  ],
  toDOM(node) {
    const attrs2 = {
      src: node.attrs.src
    };
    if (node.attrs.title)
      attrs2.title = node.attrs.title;
    if (node.attrs.alt)
      attrs2.alt = node.attrs.alt;
    if (node.attrs.width)
      attrs2.width = node.attrs.width;
    if (node.attrs.height)
      attrs2.height = node.attrs.height;
    if (node.attrs.align)
      attrs2["class"] = `align-${node.attrs.align}`;
    return ["img", attrs2];
  }
};
const alignRegex = /align-([a-z]*)/;
function getAlignFromDOM(image2) {
  const className = image2.getAttribute("class") || "";
  const match = alignRegex.exec(className);
  if (match && match.length > 1) {
    return match[1];
  }
  return null;
}
const list_item = {
  content: "paragraph block*",
  defining: true,
  parseDOM: [{ tag: "li" }],
  toDOM() {
    return ["li", 0];
  }
};
const ordered_list = {
  content: "list_item+",
  group: "block",
  attrs: { order: { default: 1 }, tight: { default: false } },
  parseDOM: [
    {
      tag: "ol",
      getAttrs(dom) {
        return {
          order: dom.hasAttribute("start") ? +(dom.getAttribute("start") || 0) : 1,
          tight: dom.hasAttribute("data-tight")
        };
      }
    }
  ],
  toDOM(node) {
    return [
      "ol",
      {
        start: node.attrs.order == 1 ? null : node.attrs.order,
        "data-tight": node.attrs.tight ? "true" : null
      },
      0
    ];
  }
};
const paragraph = {
  content: "inline*",
  marks: "_",
  attrs: {
    class: { default: "" },
    id: { default: "" }
  },
  group: "block",
  parseDOM: [{ tag: "p", getAttrs }],
  toDocument(node) {
    return ["p", docAttrs(node.attrs), 0];
  },
  toDOM(node) {
    return ["p", domAttrs(node.attrs), 0];
  }
};
const text = {
  group: "inline"
};
const tables = tableNodes({
  tableGroup: "block",
  cellContent: "inline*",
  cellAttributes: {}
});
tables.table_cell = __spreadProps(__spreadValues({}, tables.table_cell), {
  marks: "_",
  attrs: __spreadProps(__spreadValues({}, tables.table_cell.attrs), { align: { default: null } }),
  toDOM(node) {
    const attrs2 = {};
    if (node.attrs.align) {
      attrs2.style = `text-align: ${node.attrs.align};`;
    }
    return ["td", attrs2, 0];
  }
});
tables.table_header = __spreadProps(__spreadValues({}, tables.table_header), {
  marks: "_",
  attrs: __spreadProps(__spreadValues({}, tables.table_header.attrs), { align: { default: null } }),
  toDOM(node) {
    const attrs2 = {};
    if (node.attrs.align) {
      attrs2.style = `text-align: ${node.attrs.align};`;
    }
    return ["th", attrs2, 0];
  }
});
const marks = { code, em, link: link$1, strike, strong };
const nodes = __spreadValues({
  doc,
  paragraph,
  blockquote,
  bullet_list,
  code_block,
  hard_break,
  heading,
  horizontal_rule,
  image,
  list_item,
  ordered_list,
  text
}, tables);
const buildSchema = () => {
  return new Schema({
    nodes,
    marks
  });
};
class TranslatorClass {
}
class MarkdownSerializer {
  constructor(nodes2, marks2) {
    this.nodes = nodes2;
    this.marks = marks2;
  }
  serialize(content, options = {}) {
    const state = new MarkdownSerializerState(this.nodes, this.marks, options);
    state.renderContent(content);
    return state.out;
  }
}
class MarkdownSerializerState {
  constructor(nodes2, marks2, options) {
    this.nodes = nodes2;
    this.marks = marks2;
    this.delim = this.out = "";
    this.closed = false;
    this.inTightList = false;
    this.options = options || {};
    if (typeof this.options.tightLists == "undefined")
      this.options.tightLists = false;
  }
  flushClose(size) {
    if (this.closed) {
      if (!this.atBlank())
        this.out += "\n";
      if (size == null)
        size = 2;
      if (size > 1) {
        let delimMin = this.delim;
        const trim = /\s+$/.exec(delimMin);
        if (trim)
          delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
        for (let i = 1; i < size; i++)
          this.out += delimMin + "\n";
      }
      this.closed = false;
    }
  }
  wrapBlock(delim, firstDelim, node, f) {
    const old = this.delim;
    this.write(firstDelim || delim);
    this.delim += delim;
    f();
    this.delim = old;
    this.closeBlock(node);
  }
  atBlank() {
    return /(^|\n)$/.test(this.out);
  }
  ensureNewLine() {
    if (!this.atBlank())
      this.out += "\n";
  }
  write(content) {
    this.flushClose();
    if (this.delim && this.atBlank())
      this.out += this.delim;
    if (content)
      this.out += content;
  }
  closeBlock(node) {
    this.closed = node;
  }
  text(text2, escape, escFn) {
    const lines = text2.split("\n");
    for (let i = 0; i < lines.length; i++) {
      const startOfLine = this.atBlank() || this.closed;
      this.write();
      let escapedString = escape !== false ? this.esc(lines[i], startOfLine) : lines[i];
      escapedString = escFn ? escFn(escapedString) : escapedString;
      this.out += escapedString;
      if (i != lines.length - 1)
        this.out += "\n";
    }
  }
  render(node, parent, index, escFn) {
    if (typeof parent == "number")
      throw new Error("!");
    this.nodes[node.type.name](this, node, parent, index, escFn);
  }
  renderContent(parent) {
    parent.forEach((node, _, i) => this.render(node, parent, i));
  }
  renderInline(parent, escFn) {
    const active = [];
    let trailing = "";
    const progress = (node, _, index = 0) => {
      let marks2 = node ? node.marks : [];
      const indexOfCode = marks2.findIndex((p) => p.type.name === "code");
      if (indexOfCode >= 0 && marks2.length > 1) {
        marks2 = [
          ...marks2.slice(0, indexOfCode),
          ...marks2.slice(indexOfCode + 1, marks2.length),
          marks2[indexOfCode]
        ];
      }
      let leading = trailing;
      trailing = "";
      if (node && node.isText && marks2.some((mark, _i, _a) => {
        const info = this.marks[mark.type.name];
        return !!(info && info.expelEnclosingWhitespace);
      }) && /^(\s*)(.*?)(\s*)$/.test(node.text || "")) {
        const [, lead, inner2, trail] = Array.from(/^(\s*)(.*?)(\s*)$/.exec(node.text || "") || []);
        leading += lead;
        trailing = trail;
        if (lead || trail) {
          node = inner2 ? node.withText(inner2) : null;
          if (!node)
            marks2 = active;
        }
      }
      const inner = marks2.length && marks2[marks2.length - 1];
      const noEsc = inner && this.marks[inner.type.name].escape === false;
      const len = marks2.length - (noEsc ? 1 : 0);
      outer:
        for (let i = 0; i < len; i++) {
          const mark = marks2[i];
          if (!this.marks[mark.type.name].mixable)
            break;
          for (let j = 0; j < active.length; j++) {
            const other = active[j];
            if (!this.marks[other.type.name].mixable)
              break;
            if (mark.eq(other)) {
              if (i > j)
                marks2 = marks2.slice(0, j).concat(mark).concat(marks2.slice(j, i)).concat(marks2.slice(i + 1, len));
              else if (j > i)
                marks2 = marks2.slice(0, i).concat(marks2.slice(i + 1, j)).concat(mark).concat(marks2.slice(j, len));
              continue outer;
            }
          }
        }
      let keep = 0;
      while (keep < Math.min(active.length, len) && marks2[keep].eq(active[keep]))
        ++keep;
      while (keep < active.length)
        this.text(this.markString(active.pop(), false, node), false);
      if (leading)
        this.text(leading);
      if (node) {
        while (active.length < len) {
          const add = marks2[active.length];
          active.push(add);
          this.text(this.markString(add, true, node), false);
        }
        if (noEsc && node.isText && inner)
          this.text(this.markString(inner, false, node) + node.text + this.markString(inner, true, node), false, escFn);
        else
          this.render(node, parent, index, escFn);
      }
    };
    parent.forEach(progress);
    progress(null);
  }
  renderList(node, delim, firstDelim) {
    if (this.closed && this.closed.type == node.type)
      this.flushClose(3);
    else if (this.inTightList)
      this.flushClose(1);
    const isTight = this.options.tightLists;
    const prevTight = this.inTightList;
    this.inTightList = !!isTight;
    node.forEach((child, _, i) => {
      if (i && isTight)
        this.flushClose(1);
      this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));
    });
    this.inTightList = prevTight;
  }
  esc(str, startOfLine) {
    str = str.replace(/[`\\~\[\]]/g, "\\$&");
    if (startOfLine)
      str = str.replace(/^[#\-*+]/, "\\$&").replace(/^(\d+)\./, "$1\\.");
    return str;
  }
  quote(str) {
    const wrap = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
    return wrap[0] + str + wrap[1];
  }
  repeat(str, n) {
    let out = "";
    for (let i = 0; i < n; i++)
      out += str;
    return out;
  }
  markString(mark, open, node) {
    const info = this.marks[mark.type.name];
    const value = open ? info.open : info.close;
    return typeof value == "string" ? value : value(this, mark, node);
  }
  getEnclosingWhitespace(text2) {
    return {
      leading: (text2.match(/^(\s+)/) || [])[0],
      trailing: (text2.match(/(\s+)$/) || [])[0]
    };
  }
}
const get = require("lodash.get");
const ALIGN_STYLES = {
  ["text-align:left"]: "left",
  ["text-align:center"]: "center",
  ["text-align:right"]: "right"
};
const ALIGN_DASHES = {
  left: ":---",
  center: ":---:",
  right: "---:"
};
const TOKENS = {
  blockquote: { block: "blockquote" },
  paragraph: { block: "paragraph" },
  list_item: { block: "list_item" },
  bullet_list: { block: "bullet_list" },
  ordered_list: {
    block: "ordered_list",
    getAttrs: (tok) => ({ order: +tok.attrGet("order") || 1 })
  },
  heading: {
    block: "heading",
    getAttrs: (tok) => ({ level: +tok.tag.slice(1) })
  },
  code_block: { block: "code_block" },
  fence: {
    block: "code_block",
    getAttrs: (tok) => ({ params: tok.info || "" })
  },
  hr: { node: "horizontal_rule" },
  image: {
    node: "image",
    getAttrs: (tok) => ({
      src: tok.attrGet("src"),
      title: tok.attrGet("title") || null,
      alt: tok.children[0] && tok.children[0].content || null,
      width: tok.attrGet("width") || null,
      height: tok.attrGet("height") || null
    })
  },
  table: {
    block: "table"
  },
  table_row: { block: "table_row" },
  table_cell: {
    block: "table_cell",
    getAttrs(tok) {
      let style = "";
      if (tok.attrs) {
        for (let i = 0; i < tok.attrs.length; i++) {
          if (tok.attrs[i][0] === "style") {
            style = tok.attrs[i][1];
          }
        }
      }
      return { align: ALIGN_STYLES[style] };
    }
  },
  table_header: {
    block: "table_header",
    getAttrs(tok) {
      let style = "";
      if (tok.attrs) {
        for (let i = 0; i < tok.attrs.length; i++) {
          if (tok.attrs[i][0] === "style") {
            style = tok.attrs[i][1];
          }
        }
      }
      return { align: ALIGN_STYLES[style] };
    }
  },
  hardbreak: { node: "hard_break" },
  em: { mark: "em" },
  strike: { mark: "strike" },
  strong: { mark: "strong" },
  link: {
    mark: "link",
    getAttrs: (tok) => ({
      href: tok.attrGet("href"),
      title: tok.attrGet("title") || null
    })
  },
  code_inline: { mark: "code" }
};
const NODES = {
  blockquote(state, node) {
    state.wrapBlock("> ", null, node, () => state.renderContent(node));
  },
  code_block(state, node) {
    if (!node.attrs.params) {
      state.wrapBlock("    ", null, node, () => state.text(node.textContent, false));
    } else {
      state.write("```" + node.attrs.params + "\n");
      state.text(node.textContent, false);
      state.ensureNewLine();
      state.write("```");
      state.closeBlock(node);
    }
  },
  heading(state, node) {
    if (/\n/.test(node.textContent) && node.attrs.level < 3) {
      state.renderInline(node);
      state.write("\n");
      state.write(node.attrs.level === 1 ? "=" : "-");
    } else {
      state.write(state.repeat("#", node.attrs.level) + " ");
      state.renderInline(node);
    }
    state.closeBlock(node);
  },
  horizontal_rule(state, node) {
    state.write(node.attrs.markup || "***");
    state.closeBlock(node);
  },
  bullet_list(state, node) {
    state.renderList(node, "  ", () => (node.attrs.bullet || "*") + " ");
  },
  ordered_list(state, node) {
    const start = node.attrs.order || 1;
    const maxW = String(start + node.childCount - 1).length;
    const space = state.repeat(" ", maxW + 2);
    state.renderList(node, space, (i) => {
      const nStr = String(start + i);
      return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
    });
  },
  list_item(state, node) {
    state.renderContent(node);
  },
  paragraph(state, node, _parent, _index) {
    state.renderInline(node);
    state.closeBlock(node);
  },
  image(state, node) {
    let size = "";
    if (node.attrs.height || node.attrs.width) {
      size = ` =${node.attrs.width || ""}x${node.attrs.height || ""}`;
    }
    const alt = state.esc(node.attrs.alt || "");
    const src = state.esc(node.attrs.src);
    const title = node.attrs.title ? " " + state.quote(node.attrs.title) : "";
    state.write(`![${alt}](${src}${title}${size})`);
  },
  hard_break(state, node, parent, index) {
    if (!parent || typeof index !== "number")
      return;
    for (let i = index + 1; i < parent.childCount; i++)
      if (parent.child(i).type != node.type) {
        state.write("  \n");
        return;
      }
  },
  text(state, node, _1, _2, escFn) {
    if (typeof node.text !== "string")
      return;
    state.text(node.text, true, escFn);
  },
  table(state, node) {
    let inHead = true;
    node.forEach((row) => {
      const nextRowIsInBody = row.content.child(0).type.name === "table_cell";
      if (inHead && nextRowIsInBody) {
        state.write("|");
        for (let i = 0; i < row.childCount; i++) {
          const align = row.content.child(i).attrs.align;
          const dash = ALIGN_DASHES[align] || "---";
          state.write(` ${dash} |`);
        }
        state.write("\n");
        inHead = false;
      }
      NODES.table_row(state, row);
    });
    state.closeBlock(node);
  },
  table_row(state, node) {
    state.write("|");
    state.renderContent(node);
    state.write("\n");
  },
  table_cell(state, node) {
    state.write(" ");
    state.renderInline(node, (str) => str.replace(/[\|]/g, "\\$&"));
    state.write(" |");
  },
  table_header(state, node) {
    NODES.table_cell(state, node);
  }
};
const MARKS = {
  em: {
    open: "_",
    close: "_",
    mixable: true,
    expelEnclosingWhitespace: true
  },
  strong: {
    open(_state, mark, node) {
      if (get(node, "text", "").endsWith("*"))
        return mark.openedWith = "__";
      return "**";
    },
    close(_state, mark, node) {
      if (mark.openedWith) {
        const closeWith = mark.openedWith;
        mark.openedWith = null;
        return closeWith;
      }
      if (get(node, "text", "").endsWith("*"))
        return "__";
      return "**";
    },
    mixable: true,
    expelEnclosingWhitespace: true
  },
  link: {
    open: "[",
    close(state, mark) {
      return "](" + state.esc(mark.attrs.href) + (mark.attrs.title ? " " + state.quote(mark.attrs.title) : "") + ")";
    }
  },
  strike: {
    open: "~~",
    close: "~~",
    mixable: true,
    expelEnclosingWhitespace: true
  },
  code: { open: "`", close: "`", escape: false }
};
function buildTokensForSchema(schema) {
  const tokens = {};
  if (schema.nodes.blockquote)
    tokens.blockquote = TOKENS.blockquote;
  if (schema.nodes.paragraph)
    tokens.paragraph = TOKENS.paragraph;
  if (schema.nodes.list_item)
    tokens.list_item = TOKENS.list_item;
  if (schema.nodes.bullet_list)
    tokens.bullet_list = TOKENS.bullet_list;
  if (schema.nodes.ordered_list)
    tokens.ordered_list = TOKENS.ordered_list;
  if (schema.nodes.heading)
    tokens.heading = TOKENS.heading;
  if (schema.nodes.code_block) {
    tokens.code_block = TOKENS.code_block;
    tokens.fence = TOKENS.fence;
  }
  if (schema.nodes.horizontal_rule)
    tokens.hr = TOKENS.hr;
  if (schema.nodes.image)
    tokens.image = TOKENS.image;
  if (schema.nodes.hard_break)
    tokens.hardbreak = TOKENS.hardbreak;
  if (schema.nodes.ordered_list)
    tokens.ordered_list = TOKENS.ordered_list;
  if (schema.nodes.bullet_list)
    tokens.bullet_list = TOKENS.bullet_list;
  if (schema.nodes.list_item)
    tokens.list_item = TOKENS.list_item;
  if (schema.nodes.table) {
    tokens.table = TOKENS.table;
    tokens.thead = { ignore: true };
    tokens.th = TOKENS.table_header;
    tokens.tbody = { ignore: true };
    tokens.tr = TOKENS.table_row;
    tokens.td = TOKENS.table_cell;
  }
  if (schema.marks.em)
    tokens.em = TOKENS.em;
  if (schema.marks.strong)
    tokens.strong = TOKENS.strong;
  if (schema.marks.link)
    tokens.link = TOKENS.link;
  if (schema.marks.code)
    tokens.code_inline = TOKENS.code_inline;
  if (schema.marks.strike)
    tokens.strike = TOKENS.strike;
  return tokens;
}
function buildNodesFromSchema(schema) {
  const nodes2 = {};
  if (schema.nodes.blockquote)
    nodes2.blockquote = NODES.blockquote;
  if (schema.nodes.paragraph)
    nodes2.paragraph = NODES.paragraph;
  if (schema.nodes.list_item)
    nodes2.list_item = NODES.list_item;
  if (schema.nodes.bullet_list)
    nodes2.bullet_list = NODES.bullet_list;
  if (schema.nodes.ordered_list)
    nodes2.ordered_list = NODES.ordered_list;
  if (schema.nodes.heading)
    nodes2.heading = NODES.heading;
  if (schema.nodes.code_block)
    nodes2.code_block = NODES.code_block;
  if (schema.nodes.horizontal_rule)
    nodes2.horizontal_rule = NODES.horizontal_rule;
  if (schema.nodes.image)
    nodes2.image = NODES.image;
  if (schema.nodes.hard_break)
    nodes2.hard_break = NODES.hard_break;
  if (schema.nodes.ordered_list)
    nodes2.ordered_list = NODES.ordered_list;
  if (schema.nodes.bullet_list)
    nodes2.bullet_list = NODES.bullet_list;
  if (schema.nodes.list_item)
    nodes2.list_item = NODES.list_item;
  if (schema.nodes.table) {
    nodes2.table = NODES.table;
    nodes2.table_header = NODES.table_header;
    nodes2.table_row = NODES.table_row;
    nodes2.table_cell = NODES.table_cell;
  }
  nodes2.text = NODES.text;
  return nodes2;
}
function buildMarksFromSchema(schema) {
  if (schema.marks.em)
    ;
  if (schema.marks.strong)
    ;
  if (schema.marks.link)
    ;
  if (schema.marks.code)
    ;
  return MARKS;
}
function CommonMarkSerializer(schema) {
  return new MarkdownSerializer(buildNodesFromSchema(schema), buildMarksFromSchema(schema));
}
function parseNextNumber(str, pos, max) {
  let code2;
  const start = pos;
  const result = {
    ok: false,
    pos
  };
  code2 = str.charCodeAt(pos);
  while (pos < max && code2 >= 48 && code2 <= 57 || code2 === 37) {
    code2 = str.charCodeAt(++pos);
  }
  result.ok = true;
  result.pos = pos;
  result.value = Number(str.slice(start, pos));
  return result;
}
function parseImageSize(str, pos, max) {
  let code2;
  const result = {
    ok: false,
    pos: 0
  };
  if (pos >= max) {
    return result;
  }
  code2 = str.charCodeAt(pos);
  if (code2 !== 61) {
    return result;
  }
  pos++;
  code2 = str.charCodeAt(pos);
  if (code2 !== 120 && (code2 < 48 || code2 > 57)) {
    return result;
  }
  const resultW = parseNextNumber(str, pos, max);
  pos = resultW.pos;
  code2 = str.charCodeAt(pos);
  if (code2 !== 120) {
    return result;
  }
  pos++;
  const resultH = parseNextNumber(str, pos, max);
  pos = resultH.pos;
  result.width = resultW.value;
  result.height = resultH.value;
  result.pos = pos;
  result.ok = true;
  return result;
}
function parseLinkDestination(md, state, pos) {
  const isSpace = md.utils.isSpace;
  const unescapeAll = md.utils.unescapeAll;
  const str = state.src;
  const max = state.posMax;
  let code2;
  let level;
  const lines = 0;
  const start = pos;
  const result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 === 10 || isSpace(code2)) {
        return result;
      }
      if (code2 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  level = 0;
  while (pos < max) {
    code2 = str.charCodeAt(pos);
    if (code2 == 61 || code2 == 34 || code2 == 39) {
      pos--;
      break;
    }
    if (code2 < 32 || code2 === 127) {
      break;
    }
    if (code2 === 92 && pos + 1 < max) {
      pos += 2;
      continue;
    }
    if (code2 === 40) {
      level++;
    }
    if (code2 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
}
function image_with_size(md) {
  return function(state, silent) {
    let attrs2, code2, label, pos, ref, res, title, width2 = null, height = null, token, tokens, start, href = "";
    const oldPos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    const labelStart = state.pos + 2;
    const labelEnd = md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = parseLinkDestination(md, state, pos);
      if (res.ok) {
        href = res.str;
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
          break;
        }
      }
      res = md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (code2 !== 32 && code2 !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos - 1 >= 0) {
        code2 = state.src.charCodeAt(pos - 1);
        if (code2 === 32) {
          res = parseImageSize(state.src, pos, state.posMax);
          if (res.ok) {
            width2 = res.width;
            height = res.height;
            pos = res.pos;
            for (; pos < max; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (code2 !== 32 && code2 !== 10) {
                break;
              }
            }
          }
        }
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        state.pos = oldPos;
        return false;
      }
      pos++;
    } else {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (code2 !== 32 && code2 !== 10) {
          break;
        }
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[md.utils.normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      const newState = new state.md.inline.State(state.src.slice(labelStart, labelEnd), state.md, state.env, tokens = []);
      newState.md.inline.tokenize(newState);
      token = state.push("image", "img", 0);
      token.attrs = attrs2 = [
        ["src", href],
        ["alt", ""]
      ];
      token.children = tokens;
      if (title) {
        attrs2.push(["title", title]);
      }
      if (width2 !== null) {
        attrs2.push(["width", width2]);
      }
      if (height !== null) {
        attrs2.push(["height", height]);
      }
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
}
function imsize(md) {
  md.inline.ruler.before("emphasis", "image", image_with_size(md));
}
function _link(md) {
  return function(state, silent) {
    const normalizeReference = state.md.utils.normalizeReference;
    const isSpace = state.md.utils.isSpace;
    let attrs2, code2, label, pos, res, ref, title, token, href = "", start = state.pos, parseReference = true;
    const oldPos = state.pos, max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    const labelStart = state.pos + 1;
    const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (labelEnd < 0) {
      return false;
    }
    pos = labelEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      parseReference = false;
      pos++;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      if (pos >= max) {
        return false;
      }
      start = pos;
      res = parseLinkDestination(md, state, pos);
      if (res.ok) {
        href = res.str;
        if (state.md.validateLink(href)) {
          pos = res.pos;
        } else {
          href = "";
        }
      }
      start = pos;
      for (; pos < max; pos++) {
        code2 = state.src.charCodeAt(pos);
        if (!isSpace(code2) && code2 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
      } else {
        title = "";
      }
      if (pos >= max || state.src.charCodeAt(pos) !== 41) {
        parseReference = true;
      }
      pos++;
    }
    if (parseReference) {
      if (typeof state.env.references === "undefined") {
        return false;
      }
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          label = state.src.slice(start, pos++);
        } else {
          pos = labelEnd + 1;
        }
      } else {
        pos = labelEnd + 1;
      }
      if (!label) {
        label = state.src.slice(labelStart, labelEnd);
      }
      ref = state.env.references[normalizeReference(label)];
      if (!ref) {
        state.pos = oldPos;
        return false;
      }
      href = ref.href;
      title = ref.title;
    }
    if (!silent) {
      state.pos = labelStart;
      state.posMax = labelEnd;
      token = state.push("link_open", "a", 1);
      token.attrs = attrs2 = [["href", href]];
      if (title) {
        attrs2.push(["title", title]);
      }
      state.md.inline.tokenize(state);
      token = state.push("link_close", "a", -1);
    }
    state.pos = pos;
    state.posMax = max;
    return true;
  };
}
function link(md) {
  md.inline.ruler.before("emphasis", "link", _link(md));
}
const MarkMapping = {
  strike: "s"
};
function maybeMerge(a, b) {
  if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks))
    return a.copy(a.text + b.text);
}
class MarkdownParseState {
  constructor(schema, tokenHandlers2) {
    this.schema = schema;
    this.stack = [{ type: schema.topNodeType, content: [] }];
    this.marks = Mark.none;
    this.tokenHandlers = tokenHandlers2;
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  push(elt) {
    if (this.stack.length)
      this.top().content.push(elt);
  }
  addText(text2) {
    if (!text2)
      return;
    const nodes2 = this.top().content, last = nodes2[nodes2.length - 1], node = this.schema.text(text2, this.marks);
    let merged;
    if (last && (merged = maybeMerge(last, node)))
      nodes2[nodes2.length - 1] = merged;
    else
      nodes2.push(node);
  }
  openMark(mark) {
    this.marks = mark.addToSet(this.marks);
  }
  closeMark(mark) {
    this.marks = mark.removeFromSet(this.marks);
  }
  parseTokens(toks) {
    for (let i = 0; i < toks.length; i++) {
      const tok = toks[i];
      const handler = this.tokenHandlers[tok.type];
      if (!handler)
        throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
      handler(this, tok);
    }
  }
  addNode(type, attrs2, content) {
    const node = type.createAndFill(attrs2, content, this.marks);
    if (!node)
      return null;
    this.push(node);
    return node;
  }
  openNode(type, attrs2) {
    this.stack.push({ type, attrs: attrs2, content: [] });
  }
  closeNode() {
    if (this.marks.length)
      this.marks = Mark.none;
    const info = this.stack.pop();
    if (!info)
      return;
    return this.addNode(info.type, info.attrs, info.content);
  }
}
function attrs(spec, token) {
  if (spec.getAttrs)
    return spec.getAttrs(token);
  else if (spec.attrs instanceof Function)
    return spec.attrs(token);
  else
    return spec.attrs;
}
function noOpenClose(type) {
  return type == "code_inline" || type == "code_block" || type == "fence";
}
function withoutTrailingNewline(str) {
  return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
}
function noOp() {
}
function tokenHandlers(schema, tokens) {
  const handlers = Object.create(null);
  for (const type in tokens) {
    const spec = tokens[type];
    if (spec.block) {
      const nodeType = schema.nodeType(spec.block);
      if (noOpenClose(type)) {
        handlers[type] = (state, tok) => {
          state.openNode(nodeType, attrs(spec, tok));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeNode();
        };
      } else {
        handlers[type + "_open"] = (state, tok) => state.openNode(nodeType, attrs(spec, tok));
        handlers[type + "_close"] = (state) => state.closeNode();
      }
    } else if (spec.node) {
      const nodeType = schema.nodeType(spec.node);
      handlers[type] = (state, tok) => state.addNode(nodeType, attrs(spec, tok));
    } else if (spec.mark) {
      const markType = schema.marks[spec.mark];
      if (noOpenClose(type)) {
        handlers[type] = (state, tok) => {
          state.openMark(markType.create(attrs(spec, tok)));
          state.addText(withoutTrailingNewline(tok.content));
          state.closeMark(markType);
        };
      } else {
        handlers[(MarkMapping[type] || type) + "_open"] = (state, tok) => state.openMark(markType.create(attrs(spec, tok)));
        handlers[(MarkMapping[type] || type) + "_close"] = (state) => state.closeMark(markType);
      }
    } else if (spec.ignore) {
      if (noOpenClose(type)) {
        handlers[type] = noOp;
      } else {
        handlers[type + "_open"] = noOp;
        handlers[type + "_close"] = noOp;
      }
    } else {
      throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
    }
  }
  handlers.text = (state, tok) => state.addText(tok.content);
  handlers.inline = (state, tok) => state.parseTokens(tok.children);
  handlers.softbreak = (state) => state.addText("\n");
  return handlers;
}
class MarkdownParser {
  constructor(schema, tokenizer, tokens) {
    this.tokens = tokens;
    this.schema = schema;
    this.tokenizer = tokenizer;
    this.tokenHandlers = tokenHandlers(schema, tokens);
  }
  parse(text2) {
    const state = new MarkdownParseState(this.schema, this.tokenHandlers);
    let doc2;
    state.parseTokens(this.tokenizer.parse(text2, {}));
    do {
      doc2 = state.closeNode();
    } while (state.stack.length);
    return doc2;
  }
}
const markdownit = require("markdown-it");
function CommonMarkParser(schema) {
  const parser = markdownit({ html: false });
  parser.use(imsize);
  parser.use(link);
  return new MarkdownParser(schema, parser, buildTokensForSchema(schema));
}
class MarkdownTranslator extends TranslatorClass {
  constructor(schema) {
    super();
    this.parser = null;
    this.serializer = null;
    this.schema = schema;
  }
  static fromSchema(schema) {
    return MarkdownTranslator.commonMarkFromSchema(schema);
  }
  static commonMarkFromSchema(schema) {
    const translator = new MarkdownTranslator(schema);
    translator.parser = CommonMarkParser(schema);
    translator.serializer = CommonMarkSerializer(schema);
    return translator;
  }
  nodeFromString(value) {
    return this.parser.parse(value);
  }
  stringFromNode(node) {
    return this.serializer.serialize(node, {
      tightLists: true
    });
  }
}
class DOMSerializer extends DOMSerializer$1 {
  static nodesFromSchema(schema) {
    const result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  const result = {};
  for (const name in obj) {
    const toDocument = obj[name].spec.toDocument;
    const toDOM = obj[name].spec.toDOM;
    if (toDocument)
      result[name] = toDocument;
    else if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
class DOMTranslator extends TranslatorClass {
  constructor(schema) {
    super();
    this.schema = schema;
    this.parser = DOMParser$1.fromSchema(schema);
    this.serializer = DOMSerializer.fromSchema(schema);
  }
  static fromSchema(schema) {
    return new DOMTranslator(schema);
  }
  nodeFromString(value) {
    let al;
    try {
      al = window.document.createRange().createContextualFragment(value);
    } catch (e) {
      al = new DOMParser().parseFromString(value, "text/html");
    }
    return this.parser.parse(al);
  }
  stringFromNode(node) {
    const el = document.createElement("div");
    el.appendChild(this.serializer.serializeFragment(node.content));
    return el.innerHTML;
  }
}
const buildTranslator = (schema, format = "markdown") => {
  if (format === "html")
    return DOMTranslator.fromSchema(schema);
  return MarkdownTranslator.fromSchema(schema);
};
const commonPluginKey = new PluginKey("common");
const commonPlugin = new Plugin({
  key: commonPluginKey,
  state: {
    init: () => {
      return { editorFocused: false };
    },
    apply(tr, prev) {
      if (tr.getMeta("editor_focused") === false) {
        return {
          editorFocused: false
        };
      }
      if (tr.getMeta("editor_focused")) {
        return {
          editorFocused: true
        };
      }
      return prev;
    }
  },
  props: {
    handleScrollToSelection() {
      return true;
    },
    handleDOMEvents: {
      focus(view) {
        const { state, dispatch } = view;
        dispatch(state.tr.setMeta("editor_focused", true));
        return false;
      },
      blur(view) {
        const { state, dispatch } = view;
        dispatch(state.tr.setMeta("editor_focused", false));
        return false;
      }
    }
  }
});
function byType(__type) {
  return (plugin) => plugin.__type === __type;
}
function findPlugins(type, plugins) {
  return plugins.filter(byType(type));
}
function liftBlockquote(state, dispatch) {
  const range = getRangeForType(state, state.schema.nodes.blockquote);
  if (!range)
    return false;
  const target = liftTarget(range);
  if (!target)
    return false;
  if (dispatch) {
    dispatch(state.tr.lift(range, target));
  }
  return true;
}
const getRangeForType = (state, listType) => {
  const { $from, $to } = state.selection;
  const range = $from.blockRange($to, (node) => {
    return node.type == listType;
  });
  return range;
};
function insertHr(state, dispatch) {
  const type = state.schema.nodes.horizontal_rule;
  if (dispatch) {
    dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());
  }
  return true;
}
const hardBreakCmd = (schema) => {
  const br = schema.nodes.hard_break;
  return chainCommands(exitCode, (state, dispatch) => {
    dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
    return true;
  });
};
const headingCmd = (level) => (schema) => {
  const heading2 = schema.nodes.heading;
  return toggleHeader(heading2, { level }, schema.nodes.paragraph, null);
};
const KEYMAP_PLUGINS = [
  { __type: "wysiwyg:keymap", name: "Mod-z", command: () => undo },
  { __type: "wysiwyg:keymap", name: "Backspace", command: () => undoInputRule },
  { __type: "wysiwyg:keymap", name: "Mod-Shift-z", command: () => redo },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-y",
    command: () => redo,
    unlessMac: true
  },
  { __type: "wysiwyg:keymap", name: "Tab", command: () => tab },
  { __type: "wysiwyg:keymap", name: "Shift-Tab", command: () => shiftTab },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-b",
    ifMark: "strong",
    command: (schema) => toggleMark(schema.marks.strong)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-i",
    ifMark: "em",
    command: (schema) => toggleMark(schema.marks.em)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-k",
    ifMark: "link",
    command: () => {
      return function(state, dispatch) {
        return openLinkPopup(state, dispatch);
      };
    }
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Enter",
    command: hardBreakCmd,
    ifNode: "hard_break"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Shift-Enter",
    command: hardBreakCmd,
    ifNode: "hard_break"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Ctrl-Enter",
    command: hardBreakCmd,
    ifNode: "hard_break",
    ifMac: true
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-1",
    command: headingCmd(1),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-2",
    command: headingCmd(2),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-3",
    command: headingCmd(3),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-4",
    command: headingCmd(4),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-5",
    command: headingCmd(5),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-6",
    command: headingCmd(6),
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Backspace",
    command: () => deleteEmptyHeading,
    ifNode: "heading"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-7",
    command: () => toggleOrderedList,
    ifNode: "ordered_list"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-8",
    command: () => toggleBulletList,
    ifNode: "bullet_list"
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-9",
    command: (schema) => liftListItem(schema.nodes.list_item),
    onCondition(schema) {
      return !!(schema.nodes.bullet_list || schema.nodes.ordered_list);
    }
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-0",
    command: (schema) => setBlockType(schema.nodes.code_block),
    ifNode: "code_block"
  },
  {
    __type: "wysiwyg:keymap",
    name: "ArrowLeft",
    command: () => arrowHandler("left"),
    ifNodes: ["code_block", "table"]
  },
  {
    __type: "wysiwyg:keymap",
    name: "ArrowRight",
    command: () => arrowHandler("right"),
    ifNodes: ["code_block", "table"]
  },
  {
    __type: "wysiwyg:keymap",
    name: "ArrowUp",
    command: () => arrowHandler("up"),
    ifNodes: ["code_block", "table"]
  },
  {
    __type: "wysiwyg:keymap",
    name: "ArrowDown",
    command: () => arrowHandler("down"),
    ifNodes: ["code_block", "table"]
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-0",
    ifMark: "code",
    command: (schema) => toggleMark(schema.marks.code)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod->",
    ifNode: "blockquote",
    command: (schema) => wrapIn(schema.nodes.blockquote)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-<",
    ifNode: "blockquote",
    command: () => liftBlockquote
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Alt-9",
    ifNode: "paragraph",
    command: (schema) => setBlockType(schema.nodes.paragraph)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Shift-Ctrl-0",
    ifNode: "paragraph",
    command: (schema) => setBlockType(schema.nodes.paragraph)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Mod-Enter",
    ifNode: "horizontal_rule",
    command: () => insertHr
  },
  {
    __type: "wysiwyg:keymap",
    name: "Enter",
    ifNode: "list_item",
    command: (schema) => splitListItem(schema.nodes.list_item)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Tab",
    ifNode: "list_item",
    command: (schema) => sinkListItem(schema.nodes.list_item)
  },
  {
    __type: "wysiwyg:keymap",
    name: "Shift-Tab",
    ifNode: "list_item",
    command: (schema) => liftListItem(schema.nodes.list_item)
  }
];
function arrowHandler(dir) {
  return (state, dispatch, view) => {
    if (view.endOfTextblock(dir)) {
      const side = dir == "left" || dir == "up" ? -1 : 1;
      const $head = state.selection.$head;
      const nextPos = Selection.near(state.doc.resolve(side > 0 ? $head.after() : $head.before()), side);
      if (nextPos.$head) {
        const { name } = nextPos.$head.parent.type;
        if (name == "code_block" || name === "table_header" || name === "table_cell") {
          dispatch(state.tr.setSelection(nextPos));
          return true;
        }
      }
    }
    return false;
  };
}
const tab = goToCell(1);
const shiftTab = goToCell(-1);
function goToCell(dir) {
  return (state, dispatch) => {
    const { table } = state.schema.nodes;
    const parentTable = findParentNodeOfType(table)(state.selection);
    if (parentTable) {
      TableCommands.goToNextCell(1 * dir)(state, dispatch);
      return true;
    }
    return false;
  };
}
const mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
function buildKeymap(schema) {
  const keys = __spreadValues({}, baseKeymap);
  function bind(key, cmd) {
    if (keys[key]) {
      cmd = chainCommands(cmd, keys[key]);
    }
    keys[key] = cmd;
  }
  bind("Enter", chainCommands(createParagraphNear, liftEmptyBlock, splitBlock));
  findPlugins("wysiwyg:keymap", KEYMAP_PLUGINS).forEach((plugin) => {
    let skip = false;
    if (plugin.unlessMac && mac)
      skip = true;
    if (plugin.ifMark && !schema.marks[plugin.ifMark])
      skip = true;
    if (plugin.ifNode && !schema.nodes[plugin.ifNode])
      skip = true;
    if (plugin.ifNodes && !plugin.ifNodes.some((n) => schema.nodes[n]))
      skip = true;
    if (plugin.onCondition && !plugin.onCondition(schema))
      skip = true;
    if (!skip)
      bind(plugin.name, plugin.command(schema));
  });
  return keys;
}
function singleMarkCommand(markType, getAttrs2) {
  return function command(state, dispatch, match, start, end) {
    const attrs2 = getAttrs2 instanceof Function ? getAttrs2(match) : getAttrs2;
    const tr = state.tr;
    const offset = match[1].length;
    const textGroup = 2;
    if (match[textGroup]) {
      const textStart = start + 1 + offset;
      const textEnd = textStart + match[textGroup].length;
      const deleteStart = [textStart - 1, textStart];
      const nextChar = getNextChar(state, textEnd);
      const deleteEndEnd = nextChar ? 0 : 1;
      const deleteEnd = [textEnd, textEnd + deleteEndEnd];
      tr.delete(...deleteEnd);
      tr.delete(...deleteStart);
      end = start + match[textGroup].length + offset;
    }
    tr.addMark(start + offset, end, markType.create(attrs2));
    tr.removeStoredMark(markType);
    if (dispatch) {
      dispatch(tr);
    }
    return tr;
  };
}
function getNextChar(state, textEnd) {
  try {
    return state.doc.textBetween(textEnd + 1, textEnd + 2);
  } catch (e) {
    return "";
  }
}
const star = "\\*";
const double = (boundary) => new RegExp(`${boundary}${boundary}([^\r
	\f${boundary}} ](.*[^\r
	\f${boundary} ])?)${boundary}${boundary}`);
const single = (boundary) => new RegExp(`(^|[^${boundary}])${boundary}([^\r
	\f${boundary} ](.*[^\r
	\f${boundary} ])?)${boundary}`);
const STRONG = double(star);
const EM = single(star);
const S = double("~");
const EM_UNDERSCORE = single("_");
const CODE = single("`");
function buildInputRules(schema) {
  const rules = [];
  let type;
  if (type = schema.nodes.blockquote)
    rules.push(blockQuoteRule(type));
  if (type = schema.nodes.ordered_list)
    rules.push(orderedListRule(type));
  if (type = schema.nodes.bullet_list)
    rules.push(bulletListRule(type));
  if (type = schema.nodes.code_block)
    rules.push(codeBlockRule(type));
  if (type = schema.nodes.heading)
    rules.push(headingRule(type, 6));
  if (type = schema.nodes.horizontal_rule)
    rules.push(horizontalRuleRule(type));
  let mark;
  if (mark = schema.marks.strong) {
    rules.push(strongStarRule(mark));
    rules.push(strongUnderRule(mark));
  }
  if (mark = schema.marks.strike) {
    rules.push(strikethroughRule(mark));
  }
  if (mark = schema.marks.em) {
    rules.push(emStarRule(mark));
    rules.push(emUnderRule(mark));
  }
  if (mark = schema.marks.code)
    rules.push(codeRule(mark));
  return rules;
}
function markInputRule(regexp, markType, getAttrs2) {
  return new InputRule(regexp, (state, match, start, end) => {
    const attrs2 = getAttrs2 instanceof Function ? getAttrs2(match) : getAttrs2;
    const tr = state.tr;
    if (match[1]) {
      const textStart = start + match[0].indexOf(match[1]);
      const textEnd = textStart + match[1].length;
      if (textEnd < end)
        tr.delete(textEnd, end);
      if (textStart > start)
        tr.delete(start, textStart);
      end = start + match[1].length;
    }
    tr.addMark(start, end, markType.create(attrs2));
    tr.removeStoredMark(markType);
    return tr;
  });
}
function singleMarkInputRule(regexp, markType, getAttrs2) {
  const command = singleMarkCommand(markType, getAttrs2);
  return new InputRule(regexp, (state, match, start, end) => {
    return command(state, null, match, start, end);
  });
}
function strongStarRule(markType) {
  return markInputRule(STRONG, markType, {});
}
function strikethroughRule(markType) {
  return markInputRule(S, markType, {});
}
function strongUnderRule(markType) {
  return markInputRule(double("_"), markType, {});
}
function emStarRule(markType) {
  return singleMarkInputRule(EM, markType, {});
}
function emUnderRule(markType) {
  return singleMarkInputRule(EM_UNDERSCORE, markType, {});
}
function codeRule(markType) {
  return singleMarkInputRule(CODE, markType, {});
}
function blockQuoteRule(nodeType) {
  return wrappingInputRule(/^\s*>\s$/, nodeType);
}
function orderedListRule(nodeType) {
  return wrappingInputRule(/^(\d+)\.\s$/, nodeType, (match) => ({ order: +match[1] }), (match, node) => node.childCount + node.attrs.order == +match[1]);
}
function horizontalRuleRule(nodeType) {
  return new InputRule(/^(---|___|\*\*\*)$/, (state, _match, start, end) => {
    return state.tr.replaceRangeWith(start, end, nodeType.create());
  });
}
function bulletListRule(nodeType) {
  return wrappingInputRule(/^\s*([-+*])\s$/, nodeType);
}
function codeBlockRule(nodeType) {
  return textblockTypeInputRule(/^```([a-zA-Z]*)? $/, nodeType, (match) => {
    const language = match[1];
    if (language) {
      return { params: language };
    }
    return {};
  });
}
function headingRule(nodeType, maxLevel) {
  return textblockTypeInputRule(new RegExp("^(#{1," + maxLevel + "})\\s$"), nodeType, (match) => ({
    level: match[1].length
  }));
}
function inputRules(schema) {
  return inputRules$1({ rules: buildInputRules(schema) });
}
function buildEditorState(schema, translator, value, imageProps) {
  const plugins = [
    commonPlugin,
    inlinePlugin,
    inputRules(schema),
    keymap(buildKeymap(schema)),
    history(),
    linkPlugin(),
    dropCursor({ width: 2, color: "rgb(0, 132, 255)" }),
    gapCursor(),
    tableEditing(),
    tablePlugin,
    codeBlockPlugin
  ];
  if (imageProps) {
    plugins.push(imagePlugin(imageProps));
  }
  return EditorState.create({
    schema,
    doc: translator.nodeFromString(value),
    plugins
  });
}
const buildEditor = (input, el, setEditorView, imageProps, format) => {
  const schema = buildSchema();
  const translator = buildTranslator(schema, format);
  if (!el)
    return {};
  const view = new EditorView(el, {
    state: buildEditorState(schema, translator, input.value, imageProps),
    dispatchTransaction(tr2) {
      const nextState = view.state.apply(tr2);
      view.updateState(nextState);
      setEditorView({ view });
      if (tr2.docChanged && !tr2.getMeta("input-update")) {
        input.onChange(translator.stringFromNode(tr2.doc));
      }
    }
  });
  const { state, dispatch } = view;
  const { tr, doc: doc2 } = state;
  dispatch(tr.setSelection(new TextSelection(doc2.resolve(doc2.content.size) || 0)));
  view.focus();
  setEditorView({ view });
  return { translator };
};
function updateEditorState(view, translator, value) {
  const doc2 = translator.nodeFromString(value);
  if (!doc2)
    return;
  const { state, dispatch } = view;
  const { tr } = state;
  dispatch(tr.setSelection(new TextSelection(tr.doc.resolve(0), tr.doc.resolve(state.doc.nodeSize - 2))).replaceSelectionWith(doc2).setMeta("input-update", true));
}
const alignColumn = (view, alignValue) => {
  const { state, dispatch } = view;
  const { selection } = state;
  const { table, table_cell, table_header } = state.schema.nodes;
  const tableCell = findParentNodeOfType(table_cell)(state.selection);
  const tableHeader = findParentNodeOfType(table_header)(state.selection);
  const cellNode = tableCell || tableHeader;
  if (!cellNode)
    return;
  const align = cellNode.node.attrs.align === alignValue ? void 0 : alignValue;
  const tableNode = findParentNodeOfType(table)(state.selection);
  if (!tableNode)
    return;
  const tableMap = TableMap.get(tableNode.node);
  const pos = Object.entries(tableMap.map).find((entry) => entry[1] > selection.head - tableNode.start);
  if (!pos)
    return;
  const cellPos = parseInt(pos[0]) - 1;
  const columnPos = cellPos % tableMap.width;
  dispatch(forEachCellInColumn(columnPos, (cell, tr) => {
    return setCellAttrs(cell, { align })(tr);
  })(state.tr));
  view.focus();
};
var ColumnPopup = () => {
  const { editorView } = useEditorStateContext();
  if (!editorView)
    return null;
  const { state, dispatch } = editorView.view;
  const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left_selected")[0];
  if (markerDivTable)
    return null;
  const markerDivCol = document.getElementsByClassName("tina_table_header_ext_top_selected")[0];
  const markerDivRows = document.getElementsByClassName("tina_table_header_ext_left");
  let markerDivRow;
  for (let i = 1; i < markerDivRows.length; i++) {
    if (markerDivRows[i].classList.contains("tina_table_header_ext_left_selected"))
      markerDivRow = markerDivRows[i];
  }
  if (!markerDivCol && !markerDivRow)
    return null;
  const { view } = editorView;
  return /* @__PURE__ */ React.createElement(React.Fragment, null, markerDivCol && ReactDOM.createPortal(/* @__PURE__ */ React.createElement(IconWrapperCol$1, null, /* @__PURE__ */ React.createElement(IconButton, {
    onClick: () => alignColumn(view, "left"),
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React.createElement(AlignLeft, {
    className: "w-5/6 h-auto"
  })), /* @__PURE__ */ React.createElement(IconButton, {
    onClick: () => alignColumn(view, "center"),
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React.createElement(AlignCenter, {
    className: "w-5/6 h-auto"
  })), /* @__PURE__ */ React.createElement(IconButton, {
    onClick: () => alignColumn(view, "right"),
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React.createElement(AlignRight, {
    className: "w-5/6 h-auto"
  })), /* @__PURE__ */ React.createElement(IconButton, {
    onClick: () => {
      deleteColumn(state, dispatch);
      view.focus();
    },
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React.createElement(TrashIcon, {
    className: "w-5/6 h-auto"
  }))), markerDivCol), markerDivRow && ReactDOM.createPortal(/* @__PURE__ */ React.createElement(IconWrapperRow$1, null, /* @__PURE__ */ React.createElement(IconButton, {
    onClick: () => {
      deleteRow(state, dispatch);
      view.focus();
    },
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React.createElement(TrashIcon, {
    className: "w-5/6 h-auto"
  }))), markerDivRow));
};
const IconWrapperCol$1 = styled.span`
  display: flex;
  left: 50%;
  position: absolute;
  top: -8px;
  transform: translate3d(-50%, -100%, 0);
  button:not(:first-of-type) {
    margin-left: 10px;
  }
`;
const IconWrapperRow$1 = styled.span`
  position: absolute;
  top: 50%;
  left: -8px;
  transform: translate3d(-100%, -50%, 0);
`;
const borderWidth$2 = 1;
const controlSize$2 = 12;
var AddColumn = ({ index, marker, tableHeight, view }) => {
  const { state, dispatch } = view;
  const addColumn = (pos) => {
    dispatch(addColumnAt(pos)(state.tr));
    view.focus();
  };
  const [hovered, setHovered] = useState(false);
  useEffect(() => {
    if (hovered)
      marker.style.zIndex = "1000";
    else
      marker.style.zIndex = "1";
  }, [hovered]);
  return ReactDOM.createPortal(/* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Wrapper$2, {
    onMouseEnter: () => setHovered(true),
    onMouseLeave: () => setHovered(false)
  }, hovered ? /* @__PURE__ */ React__default.createElement(IconWrapperCol, null, /* @__PURE__ */ React__default.createElement(IconButton, {
    onClick: () => {
      addColumn(index);
      setHovered(false);
    },
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React__default.createElement(AddIcon, null))) : /* @__PURE__ */ React__default.createElement(Pointer$1, null)), hovered && /* @__PURE__ */ React__default.createElement(ColumnDivider$1, {
    height: tableHeight
  })), marker);
};
const Wrapper$2 = styled.div`
  top: -7px;
  position: absolute;
  right: 0;
  padding: 8px;
  transform: translate3d(50%, -100%, 0);
  user-select: none;
`;
const Pointer$1 = styled.div`
  background: #e1ddec;
  border-radius: 50%;
  height: 4px;
  width: 4px;
`;
const IconWrapperCol = styled.span`
  position: absolute;
  top: 0;
  left: 50%;
  transform: translate3d(-50%, -50%, 0);
`;
const ColumnDivider$1 = styled.div`
  position: absolute;
  background: #0574e4;
  top: ${-1 * borderWidth$2}px;
  z-index: 1000;
  right: ${-1 * borderWidth$2}px;
  width: ${2 * borderWidth$2}px;
  height: ${({ height }) => `${height + controlSize$2 - borderWidth$2}px`};
`;
const borderWidth$1 = 1;
const controlSize$1 = 12;
var AddRow = ({ index, marker, tableWidth, view }) => {
  const { state, dispatch } = view;
  const addRow = (pos) => {
    if (pos > 1)
      dispatch(addRowAt(pos, true)(state.tr));
    else {
      const { table, table_cell, table_row } = state.schema.nodes;
      const tableNode = findParentNodeOfType(table)(state.selection);
      if (!tableNode)
        return;
      const tableMap = TableMap.get(tableNode.node);
      const position = tableNode.start + tableMap.map[tableMap.width] - 1;
      const cellInNextRow = getCellsInRow(0)(state.selection);
      if (!cellInNextRow)
        return;
      const cells = cellInNextRow == null ? void 0 : cellInNextRow.map((cell) => table_cell.createAndFill(__spreadValues({}, cell.node.attrs)));
      dispatch(state.tr.insert(position, table_row.create(null, cells)));
    }
    view.focus();
  };
  const [hovered, setHovered] = useState(false);
  useEffect(() => {
    if (hovered)
      marker.style.zIndex = "1000";
    else
      marker.style.zIndex = "1";
  }, [hovered]);
  return ReactDOM.createPortal(/* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(Wrapper$1, {
    onMouseEnter: () => setHovered(true),
    onMouseLeave: () => setHovered(false)
  }, hovered && index > 0 ? /* @__PURE__ */ React__default.createElement(IconWrapperRow, null, /* @__PURE__ */ React__default.createElement(IconButton, {
    onClick: () => addRow(index),
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React__default.createElement(AddIcon, {
    className: "w-5/6 h-auto"
  }))) : /* @__PURE__ */ React__default.createElement(Pointer, null)), hovered && /* @__PURE__ */ React__default.createElement(ColumnDivider, {
    width: tableWidth
  })), marker);
};
const Wrapper$1 = styled.div`
  left: -7px;
  position: absolute;
  bottom: 0;
  padding: 8px;
  transform: translate3d(-100%, 50%, 0);
  user-select: none;
`;
const Pointer = styled.div`
  background: #e1ddec;
  border-radius: 50%;
  height: 4px;
  width: 4px;
`;
const IconWrapperRow = styled.span`
  position: absolute;
  top: 50%;
  left: 0;
  transform: translate3d(-50%, -50%, 0);
`;
const ColumnDivider = styled.div`
  position: absolute;
  background: #0574e4;
  left: ${-1 * borderWidth$1}px;
  z-index: var(--tina-z-index-1);
  bottom: ${-1 * borderWidth$1}px;
  height: ${2 * borderWidth$1}px;
  width: ${({ width: width2 }) => `${width2 + controlSize$1 - borderWidth$1}px`};
`;
var AddPopup = () => {
  const { editorView } = useEditorStateContext();
  if (!editorView)
    return null;
  const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left");
  if (!markerDivTable.length)
    return null;
  const tableElm = markerDivTable[0].closest("table");
  if (!tableElm)
    return null;
  const { height, width: width2 } = tableElm.getBoundingClientRect();
  const markerDivCol = document.getElementsByClassName("tina_table_header_ext_top");
  const markerCols = [markerDivTable[0]];
  for (let i = 0; i < markerDivCol.length; i++) {
    markerCols.push(markerDivCol[i]);
  }
  const markerDivRow = document.getElementsByClassName("tina_table_header_ext_left");
  const markerRows = [markerDivTable[0]];
  for (let i = 0; i < markerDivRow.length; i++) {
    markerRows.push(markerDivRow[i]);
  }
  const { view } = editorView;
  return /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, markerCols.map((marker, index) => /* @__PURE__ */ React__default.createElement(AddColumn, {
    key: `add-column-menu-${index}`,
    index,
    marker,
    tableHeight: height,
    view
  })), markerRows.map((marker, index) => /* @__PURE__ */ React__default.createElement(AddRow, {
    key: `add-row-menu-${index}`,
    index,
    marker,
    tableWidth: width2,
    view
  })));
};
var OptionsPopup = () => {
  const { editorView } = useEditorStateContext();
  if (!editorView)
    return null;
  const { view } = editorView;
  const deleteSelectedTable = () => {
    const { state, dispatch } = view;
    deleteTable(state, dispatch);
    view.focus();
  };
  const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left_selected");
  if (!markerDivTable.length)
    return null;
  const tableElm = markerDivTable[0].closest("table");
  if (!tableElm)
    return null;
  const { height, width: width2 } = tableElm.getBoundingClientRect();
  return ReactDOM__default.createPortal(/* @__PURE__ */ React__default.createElement(Wrapper, {
    height,
    width: width2
  }, /* @__PURE__ */ React__default.createElement(IconButton, {
    onClick: deleteSelectedTable,
    size: "small",
    variant: "primary"
  }, /* @__PURE__ */ React__default.createElement(TrashIcon, null))), markerDivTable[0]);
};
const Wrapper = styled.div`
  background-color: #ffffff;
  border-radius: 2px;
  cursor: default;
  padding: 0px 4px;
  position: absolute;
  top: ${({ height }) => `${height + 24}px`};
  left: ${({ width: width2 }) => `${width2 / 2 - 8}px`};
`;
const TablePopups = () => /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(ColumnPopup, null), /* @__PURE__ */ React.createElement(AddPopup, null), /* @__PURE__ */ React.createElement(OptionsPopup, null));
const Menubar = (_f) => {
  var _g = _f, { plugins, imageProps } = _g, rest = __objRest(_g, ["plugins", "imageProps"]);
  const { editorView } = useEditorStateContext();
  if (!editorView)
    return null;
  return /* @__PURE__ */ React__default.createElement(BaseMenubar, __spreadProps(__spreadValues({}, rest), {
    menus: [
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$8, {
        key: "BlockMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$5, {
        key: "InlineMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu, {
        key: "LinkMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$1, {
        key: "ImageMenu",
        imageProps
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$2, {
        key: "TableMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$3, {
        key: "QuoteMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$7, {
        key: "CodeBlockMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$4, {
        key: "ListMenu"
      }),
      /* @__PURE__ */ React__default.createElement(ProsemirrorMenu$6, {
        key: "HistoryMenu"
      })
    ],
    popups: [
      /* @__PURE__ */ React__default.createElement(TablePopups, {
        key: "TablePopups"
      }),
      /* @__PURE__ */ React__default.createElement(ImageEdit, {
        key: "ImageEditPopup"
      }),
      /* @__PURE__ */ React__default.createElement(LinkForm, {
        key: "LinkFormPopup"
      }),
      /* @__PURE__ */ React__default.createElement(Loader, {
        key: "ImageLoader"
      })
    ],
    plugins
  }));
};
const CodeMirrorCss = css`
  white-space: pre-wrap;

  .CodeMirror {
    font-family: monospace;
    height: auto;
    width: 100%;
    border-radius: 5px;
    margin-bottom: 16px;
    color: black;
    direction: ltr;
  }

  .CodeMirror-lines {
    padding: 4px 0; /* Vertical padding around content */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    padding: 0 4px; /* Horizontal padding of content */
  }

  .CodeMirror-scrollbar-filler,
  .CodeMirror-gutter-filler {
    background-color: white; /* The little square between H and V scrollbars */
  }

  /* GUTTER */

  .CodeMirror-gutters {
    border-right: 1px solid #ddd;
    background-color: #f7f7f7;
    white-space: nowrap;
  }
  .CodeMirror-linenumbers {
  }
  .CodeMirror-linenumber {
    padding: 0 3px 0 5px;
    min-width: 20px;
    text-align: right;
    color: #999;
    white-space: nowrap;
  }

  .CodeMirror-guttermarker {
    color: black;
  }
  .CodeMirror-guttermarker-subtle {
    color: #999;
  }

  /* CURSOR */

  .CodeMirror-cursor {
    border-left: 1px solid black;
    border-right: none;
    width: 0;
  }
  /* Shown when moving in bi-directional text */
  .CodeMirror div.CodeMirror-secondarycursor {
    border-left: 1px solid silver;
  }
  .cm-fat-cursor .CodeMirror-cursor {
    width: auto;
    border: 0 !important;
    background: #7e7;
  }
  .cm-fat-cursor div.CodeMirror-cursors {
    z-index: 1;
  }
  .cm-fat-cursor-mark {
    background-color: rgba(20, 255, 20, 0.5);
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
  }
  .cm-animate-fat-cursor {
    width: auto;
    border: 0;
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
    background-color: #7e7;
  }
  @-moz-keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }
  @-webkit-keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }
  @keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }

  /* Can style cursor different in overwrite (non-insert) mode */
  .CodeMirror-overwrite .CodeMirror-cursor {
  }

  .cm-tab {
    display: inline-block;
    text-decoration: inherit;
  }

  .CodeMirror-rulers {
    position: absolute;
    left: 0;
    right: 0;
    top: -50px;
    bottom: 0;
    overflow: hidden;
  }
  .CodeMirror-ruler {
    border-left: 1px solid #ccc;
    top: 0;
    bottom: 0;
    position: absolute;
  }

  /* DEFAULT THEME */

  .cm-s-default .cm-header {
    color: blue;
  }
  .cm-s-default .cm-quote {
    color: #090;
  }
  .cm-negative {
    color: #d44;
  }
  .cm-positive {
    color: #292;
  }
  .cm-header,
  .cm-strong {
    font-weight: bold;
  }
  .cm-em {
    font-style: italic;
  }
  .cm-link {
    text-decoration: underline;
  }
  .cm-strikethrough {
    text-decoration: line-through;
  }

  .cm-s-default .cm-keyword {
    color: #708;
  }
  .cm-s-default .cm-atom {
    color: #219;
  }
  .cm-s-default .cm-number {
    color: #164;
  }
  .cm-s-default .cm-def {
    color: #00f;
  }
  .cm-s-default .cm-variable,
  .cm-s-default .cm-punctuation,
  .cm-s-default .cm-property,
  .cm-s-default .cm-operator {
  }
  .cm-s-default .cm-variable-2 {
    color: #05a;
  }
  .cm-s-default .cm-variable-3,
  .cm-s-default .cm-type {
    color: #085;
  }
  .cm-s-default .cm-comment {
    color: #a50;
  }
  .cm-s-default .cm-string {
    color: #a11;
  }
  .cm-s-default .cm-string-2 {
    color: #f50;
  }
  .cm-s-default .cm-meta {
    color: #555;
  }
  .cm-s-default .cm-qualifier {
    color: #555;
  }
  .cm-s-default .cm-builtin {
    color: #30a;
  }
  .cm-s-default .cm-bracket {
    color: #997;
  }
  .cm-s-default .cm-tag {
    color: #170;
  }
  .cm-s-default .cm-attribute {
    color: #00c;
  }
  .cm-s-default .cm-hr {
    color: #999;
  }
  .cm-s-default .cm-link {
    color: #00c;
  }

  .cm-s-default .cm-error {
    color: #f00;
  }
  .cm-invalidchar {
    color: #f00;
  }

  .CodeMirror-composing {
    border-bottom: 2px solid;
  }

  /* Default styles for common addons */

  div.CodeMirror span.CodeMirror-matchingbracket {
    color: #0b0;
  }
  div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: #a22;
  }
  .CodeMirror-matchingtag {
    background: rgba(255, 150, 0, 0.3);
  }
  .CodeMirror-activeline-background {
    background: #e8f2ff;
  }

  /* STOP */

  /* The rest of this file contains styles related to the mechanics of
    the editor. You probably shouldn't touch them. */

  .CodeMirror {
    position: relative;
    overflow: hidden;
    background: white;
  }

  .CodeMirror-scroll {
    overflow: scroll !important; /* Things will break if this is overridden */
    /* 30px is the magic margin used to hide the element's real scrollbars */
    /* See overflow: hidden in .CodeMirror */
    margin-bottom: -30px;
    margin-right: -30px;
    padding-bottom: 30px;
    height: 100%;
    outline: none; /* Prevent dragging from highlighting the element */
    position: relative;
  }
  .CodeMirror-sizer {
    position: relative;
    min-height: auto;
    border-right: 30px solid transparent;
  }

  /* The fake, visible scrollbars. Used to force redraw during scrolling
    before actual scrolling happens, thus preventing shaking and
    flickering artifacts. */
  .CodeMirror-vscrollbar,
  .CodeMirror-hscrollbar,
  .CodeMirror-scrollbar-filler,
  .CodeMirror-gutter-filler {
    position: absolute;
    z-index: 6;
    display: none;
  }
  .CodeMirror-vscrollbar {
    right: 0;
    top: 0;
    overflow-x: hidden;
    overflow-y: scroll;
  }
  .CodeMirror-hscrollbar {
    bottom: 0;
    left: 0;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .CodeMirror-scrollbar-filler {
    right: 0;
    bottom: 0;
  }
  .CodeMirror-gutter-filler {
    left: 0;
    bottom: 0;
  }

  .CodeMirror-gutters {
    position: absolute;
    left: 0;
    top: 0;
    min-height: 100%;
    z-index: 3;
  }
  .CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    display: inline-block;
    vertical-align: top;
    margin-bottom: -30px;
  }
  .CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: none !important;
    border: none !important;
  }
  .CodeMirror-gutter-background {
    position: absolute;
    top: 0;
    bottom: 0;
    z-index: 4;
  }
  .CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
  }
  .CodeMirror-gutter-wrapper ::selection {
    background-color: transparent;
  }
  .CodeMirror-gutter-wrapper ::-moz-selection {
    background-color: transparent;
  }

  .CodeMirror-lines {
    cursor: text;
    min-height: 1px; /* prevents collapsing before first draw */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    /* Reset some styles that the rest of the page might have set */
    -moz-border-radius: 0;
    -webkit-border-radius: 0;
    border-radius: 0;
    border-width: 0;
    background: transparent;
    font-family: inherit;
    font-size: inherit;
    margin: 0;
    white-space: pre;
    word-wrap: normal;
    line-height: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
    -webkit-tap-highlight-color: transparent;
    -webkit-font-variant-ligatures: contextual;
    font-variant-ligatures: contextual;
  }
  .CodeMirror-wrap pre.CodeMirror-line,
  .CodeMirror-wrap pre.CodeMirror-line-like {
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
  }

  .CodeMirror-linebackground {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 0;
  }

  .CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    padding: 0.1px; /* Force widget margins to stay inside of the container */
  }

  .CodeMirror-widget {
  }

  .CodeMirror-rtl pre {
    direction: rtl;
  }

  .CodeMirror-code {
    outline: none;
  }

  /* Force content-box sizing for the elements where we expect it */
  .CodeMirror-scroll,
  .CodeMirror-sizer,
  .CodeMirror-gutter,
  .CodeMirror-gutters,
  .CodeMirror-linenumber {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }

  .CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0;
    overflow: hidden;
    visibility: hidden;
  }

  .CodeMirror-cursor {
    position: absolute;
    pointer-events: none;
  }
  .CodeMirror-measure pre {
    position: static;
  }

  div.CodeMirror-cursors {
    visibility: hidden;
    position: relative;
    z-index: 3;
  }
  div.CodeMirror-dragcursors {
    visibility: visible;
  }

  .CodeMirror-focused div.CodeMirror-cursors {
    visibility: visible;
  }

  .CodeMirror-selected {
    background: #d9d9d9;
  }
  .CodeMirror-focused .CodeMirror-selected {
    background: #d7d4f0;
  }
  .CodeMirror-crosshair {
    cursor: crosshair;
  }
  .CodeMirror-line::selection,
  .CodeMirror-line > span::selection,
  .CodeMirror-line > span > span::selection {
    background: #d7d4f0;
  }
  .CodeMirror-line::-moz-selection,
  .CodeMirror-line > span::-moz-selection,
  .CodeMirror-line > span > span::-moz-selection {
    background: #d7d4f0;
  }

  .cm-searching {
    background-color: #ffa;
    background-color: rgba(255, 255, 0, 0.4);
  }

  /* Used to force a border model for a node */
  .cm-force-border {
    padding-right: 0.1px;
  }

  @media print {
    /* Hide the cursor when printing */
    .CodeMirror div.CodeMirror-cursors {
      visibility: hidden;
    }
  }

  /* See issue #2901 */
  .cm-tab-wrap-hack:after {
    content: '';
  }

  /* Help users use markselection to safely style text background */
  span.CodeMirror-selectedtext {
    background: none;
  }
`;
const paddingX = 8;
const paddingY = 6;
const borderWidth = 1;
const controlSize = 12;
const proseMirrorTableStyles = `
  .ProseMirror {
    display: block
  }
  .ProseMirror .tableWrapper {
    overflow-x: auto;
  }
  .ProseMirror .column-resize-handle {
    position: absolute;
    right: -2px;
    top: 0;
    bottom: 0;
    width: 4px;
    z-index: 20;
    background-color: #adf;
    pointer-events: none;
  }
  .ProseMirror.resize-cursor {
    cursor: ew-resize;
    cursor: col-resize;
  }
  /* Give selected cells a blue overlay */
  .ProseMirror .selectedCell:after {
    z-index: 2;
    position: absolute;
    content: '';
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background: rgba(0, 132, 255, 0.25);
    /* This provides a bullet-proof border for selected cells even with border collapsing */
    box-shadow: 0 0 0 1px #0574E4;
    pointer-events: none;
  }
  .ProseMirror:focus {
    outline: 0px solid transparent;
  }
  .ProseMirror p {
    min-height: 18px;
  }
  .ProseMirror table {
    border-collapse: collapse;
    table-layout: fixed;
    display: inline-table;
    margin: 32px 0 32px 0;
    overflow: visible;
    width: 100%;
  }
  .ProseMirror th {
    background-color: #F6F6F9;
  }
  .ProseMirror tr {
    height: 40px;
  }
  .ProseMirror table td,
  .ProseMirror table th {
    border: 1px solid #E1DDEC;
    padding: ${paddingY}px ${paddingX}px;
    position: relative;
    vertical-align: top;
    box-sizing: border-box;
  }
  .ProseMirror .tina_table_header_ext_top {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: ${controlSize}px;
    width: calc(100% + ${borderWidth * 2}px);
    transform: translate(${(borderWidth + paddingX) * -1}px, ${(controlSize + paddingY) * -1}px);
    cursor: pointer;
    z-index: 1;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_top_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .tina_table_header_ext_left {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: calc(100% + ${borderWidth * 2}px);
    width: ${controlSize}px;
    transform: translate(${(controlSize + paddingX) * -1}px, ${(borderWidth + paddingY) * -1}px);
    cursor: pointer;
    z-index: 1;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_left_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .tina_table_header_ext_top_left {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: ${controlSize}px;
    width: ${controlSize}px;
    transform: translate(${(controlSize + paddingX) * -1}px, ${(controlSize + paddingY) * -1}px);
    border-radius: 5px 0 0 0;
    z-index: 1;
    cursor: pointer;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_top_left_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .selectedCell {
    border-color: transparent;
  }
`;
const ProseMirrorCss = css`
  .ProseMirror .tinacms-image-wrapper {
    display: inline-block;
    margin: 1em 0;
  }

  ${proseMirrorTableStyles}
`;
const ProsemirrorEditor = styled((_h) => {
  var _i = _h, {
    input,
    plugins,
    sticky,
    format,
    imageProps
  } = _i, styleProps = __objRest(_i, [
    "input",
    "plugins",
    "sticky",
    "format",
    "imageProps"
  ]);
  const editorRef = useRef(null);
  const [editorView, setEditorView] = useState();
  const [translator, setTranslator] = useState();
  const { browserFocused } = useBrowserFocusContext();
  useEffect(() => {
    const { translator: translatorObj } = buildEditor(input, editorRef.current, setEditorView, imageProps, format);
    setTranslator(translatorObj);
    return () => {
      editorView && editorView.view.destroy();
    };
  }, [editorRef]);
  useEffect(() => {
    const view = editorView && editorView.view;
    const editorWrapper = document.getElementsByClassName("ProseMirror")[0];
    if (!view || (editorWrapper === document.activeElement || editorWrapper.contains(document.activeElement)) && browserFocused)
      return;
    updateEditorState(view, translator, input.value);
  }, [input.value]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("link", {
    rel: "stylesheet",
    href: "https://codemirror.net/lib/codemirror.css"
  }), /* @__PURE__ */ React.createElement(EditorStateProvider, {
    translator,
    editorView
  }, /* @__PURE__ */ React.createElement(Menubar, {
    sticky,
    imageProps,
    plugins
  })), /* @__PURE__ */ React.createElement(RichTextInput, null, /* @__PURE__ */ React.createElement("div", __spreadProps(__spreadValues({}, styleProps), {
    ref: editorRef
  }))));
})`
  ${CodeMirrorCss}${ProseMirrorCss}
`;
const RichTextInput = ({ children }) => {
  return /* @__PURE__ */ React.createElement("div", {
    className: "tina-prose shadow-inner focus:shadow-outline focus:border-blue-500 block w-full bg-white border border-gray-200 text-gray-600 focus:text-gray-900 rounded-md p-5 mb-5",
    style: { minHeight: "100px", maxWidth: `100%` }
  }, children);
};
const modeTogglePlugin = {
  name: "wysiwygModeToggle",
  MenuItem: () => /* @__PURE__ */ React.createElement(EditorModeMenu, null)
};
const Wysiwyg = ({
  imageProps: passedInImageProps,
  input,
  form,
  plugins = [],
  format = "markdown",
  sticky,
  className
}) => {
  const cms = useCMS();
  const { value, onChange } = input;
  const pluginList = format === "markdown" ? [...plugins, modeTogglePlugin] : plugins;
  const imageProps = useImageProps(cms, form, passedInImageProps);
  return /* @__PURE__ */ React.createElement(EditorModeProvider, null, /* @__PURE__ */ React.createElement(EditorModeConsumer, null, ({ mode }) => /* @__PURE__ */ React.createElement(BrowserFocusProvider, null, mode === "markdown" ? /* @__PURE__ */ React.createElement(MarkdownEditor, {
    value,
    onChange,
    imageProps,
    plugins: pluginList,
    sticky
  }) : /* @__PURE__ */ React.createElement(ProsemirrorEditor, {
    input: {
      value,
      onChange
    },
    plugins: pluginList,
    sticky,
    format,
    imageProps,
    className
  }))));
};
const defaultParse = (media) => media.id;
function useImageProps(cms, form, passedInImageProps) {
  return React.useMemo(() => {
    const parse = (passedInImageProps == null ? void 0 : passedInImageProps.parse) || defaultParse;
    const uploadDir = (passedInImageProps == null ? void 0 : passedInImageProps.uploadDir) && form ? passedInImageProps.uploadDir(form.values) : "";
    return {
      upload: async (files) => {
        const filesToUpload = files.map((file) => ({
          directory: uploadDir,
          file
        }));
        const allMedia = await cms.media.persist(filesToUpload);
        return allMedia.map((media) => {
          if (parse) {
            return parse(media);
          } else {
            return media.filename;
          }
        });
      },
      previewSrc: (src) => {
        return cms.media.previewSrc(src);
      },
      mediaDir: uploadDir,
      parse
    };
  }, [
    cms.media.store,
    passedInImageProps == null ? void 0 : passedInImageProps.uploadDir,
    passedInImageProps == null ? void 0 : passedInImageProps.previewSrc,
    passedInImageProps == null ? void 0 : passedInImageProps.upload
  ]);
}
const HTMLField = (props) => {
  return /* @__PURE__ */ React__default.createElement(Wysiwyg, __spreadProps(__spreadValues({}, props), {
    sticky: false,
    format: "html",
    imageProps: props.field.imageProps
  }));
};
const HtmlFieldPlugin = {
  __type: "field",
  name: "html",
  Component: HTMLField,
  parse: (value) => value || ""
};
const MarkdownField = wrapFieldsWithMeta((props) => /* @__PURE__ */ React__default.createElement(Wysiwyg, __spreadProps(__spreadValues({}, props), {
  sticky: false,
  format: "markdown",
  imageProps: props.field.imageProps
})));
const MarkdownFieldPlugin = {
  __type: "field",
  name: "markdown",
  Component: MarkdownField,
  parse: (value) => value || ""
};
export { HTMLField, HtmlFieldPlugin, MarkdownField, MarkdownFieldPlugin, Wysiwyg };
