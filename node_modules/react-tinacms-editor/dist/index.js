var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("tinacms"), require("@tinacms/toolkit"), require("styled-components"), require("prosemirror-commands"), require("react-dom"), require("prosemirror-state"), require("prosemirror-history"), require("prosemirror-schema-list"), require("prosemirror-utils"), require("prosemirror-view"), require("prosemirror-tables"), require("lodash.debounce"), require("prosemirror-model"), require("prosemirror-dropcursor"), require("prosemirror-gapcursor"), require("prosemirror-keymap"), require("prosemirror-inputrules"), require("prosemirror-transform")) : typeof define === "function" && define.amd ? define(["exports", "react", "tinacms", "@tinacms/toolkit", "styled-components", "prosemirror-commands", "react-dom", "prosemirror-state", "prosemirror-history", "prosemirror-schema-list", "prosemirror-utils", "prosemirror-view", "prosemirror-tables", "lodash.debounce", "prosemirror-model", "prosemirror-dropcursor", "prosemirror-gapcursor", "prosemirror-keymap", "prosemirror-inputrules", "prosemirror-transform"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2["react-tinacms-editor"] = {}, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP, global2.NOOP));
})(this, function(exports2, React, tinacms, toolkit, styled, prosemirrorCommands, ReactDOM, prosemirrorState, prosemirrorHistory, prosemirrorSchemaList, prosemirrorUtils, prosemirrorView, TableCommands, debounce, prosemirrorModel, prosemirrorDropcursor, prosemirrorGapcursor, prosemirrorKeymap, prosemirrorInputrules, prosemirrorTransform) {
  "use strict";
  function _interopDefaultLegacy(e) {
    return e && typeof e === "object" && "default" in e ? e : { "default": e };
  }
  function _interopNamespace(e) {
    if (e && e.__esModule)
      return e;
    var n = { __proto__: null, [Symbol.toStringTag]: "Module" };
    if (e) {
      Object.keys(e).forEach(function(k) {
        if (k !== "default") {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function() {
              return e[k];
            }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }
  var React__namespace = /* @__PURE__ */ _interopNamespace(React);
  var React__default = /* @__PURE__ */ _interopDefaultLegacy(React);
  var styled__default = /* @__PURE__ */ _interopDefaultLegacy(styled);
  var ReactDOM__default = /* @__PURE__ */ _interopDefaultLegacy(ReactDOM);
  var ReactDOM__namespace = /* @__PURE__ */ _interopNamespace(ReactDOM);
  var TableCommands__namespace = /* @__PURE__ */ _interopNamespace(TableCommands);
  var debounce__default = /* @__PURE__ */ _interopDefaultLegacy(debounce);
  const BrowserFocusContext = React.createContext({
    browserFocused: true
  });
  const BrowserFocusProvider = ({
    children
  }) => {
    const [browserFocused, setBrowserFocused] = React.useState(true);
    React.useEffect(() => {
      const setWindowFocused = () => setBrowserFocused(true);
      const setWindowBlurred = () => setBrowserFocused(false);
      window.addEventListener("focus", setWindowFocused);
      window.addEventListener("blur", setWindowBlurred);
      return () => {
        window.removeEventListener("focus", setWindowFocused);
        window.removeEventListener("blur", setWindowBlurred);
      };
    }, []);
    return /* @__PURE__ */ React__namespace.createElement(BrowserFocusContext.Provider, {
      value: { browserFocused }
    }, children);
  };
  BrowserFocusContext.Consumer;
  const useBrowserFocusContext = () => __spreadValues({}, React.useContext(BrowserFocusContext));
  const MenuButton = styled__default["default"].button`
  padding: 8px !important;
  border: none;
  border-right: 1px solid var(--tina-color-grey-2);
  width: auto;
  height: auto;
  border-left: none;
  margin: 0 0 -1px 0;
  flex-grow: 1;
  max-width: 48px;
  transition: background 150ms ease-out;

  &:hover {
    background-color: rgba(53, 50, 50, 0.09);
  }
  &:active {
    color: var(--tina-color-primary);
    fill: var(--tina-color-primary);
    background-color: rgba(53, 50, 50, 0.05);
  }
  svg {
    width: 20px;
    height: 20px;
  }
  ${(props) => props.active && styled.css`
      color: var(--tina-color-primary);
      fill: var(--tina-color-primary);
      background-color: rgba(53, 50, 50, 0.05);
    `};
  ${(props) => props.disabled && styled.css`
      pointer-events: none;
      color: #d1d1d1;
      fill: #d1d1d1;
    `};
`;
  const EditorModeContext = React.createContext({
    mode: "wysiwyg",
    setMode: () => {
    }
  });
  const EditorModeProvider = ({ children }) => {
    const [mode, setMode] = React.useState("wysiwyg");
    React.useEffect(() => {
      document.addEventListener("keydown", (event) => {
        if (event.altKey && event.shiftKey && event.metaKey && event.keyCode === 77)
          setMode(mode === "wysiwyg" ? "markdown" : "wysiwyg");
      });
    });
    return /* @__PURE__ */ React__namespace.createElement(EditorModeContext.Provider, {
      value: { mode, setMode }
    }, children);
  };
  const EditorModeConsumer = EditorModeContext.Consumer;
  const useEditorModeContext = () => React.useContext(EditorModeContext);
  const EditorModeMenu = () => {
    const { mode, setMode } = useEditorModeContext();
    const toggleMode = () => {
      if (mode === "markdown")
        setMode("wysiwyg");
      else
        setMode("markdown");
    };
    return /* @__PURE__ */ React__namespace.createElement(MenuButton, {
      "data-testid": "markdown-toggle",
      "data-tooltip": "Markdown mode",
      title: "Toggle Markdown mode",
      onClick: toggleMode
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.MarkdownIcon, null));
  };
  const EditorStateContext = React.createContext({
    editorView: void 0,
    translator: void 0
  });
  const EditorStateProvider = ({
    children,
    editorView,
    translator
  }) => {
    return /* @__PURE__ */ React__namespace.createElement(EditorStateContext.Provider, {
      value: { editorView, translator }
    }, children);
  };
  EditorStateContext.Consumer;
  const useEditorStateContext = () => __spreadValues({}, React.useContext(EditorStateContext));
  const commandControl = (command, Icon, _title, tooltip, focusOnCreate = true) => () => {
    const { editorView } = useEditorStateContext();
    const onClick = () => {
      if (canDo()) {
        const view = editorView.view;
        command(view.state, view.dispatch);
        if (focusOnCreate) {
          view.focus();
        }
      }
    };
    const canDo = () => command(editorView.view.state);
    return /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
      "data-tooltip": tooltip,
      title: tooltip,
      onClick,
      disabled: !canDo(),
      onMouseDown: (evt) => {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }, /* @__PURE__ */ React__default["default"].createElement(Icon, null));
  };
  function markControl({
    mark,
    Icon,
    tooltip,
    defaultAttrs,
    selectionOnly = false,
    noMix = [],
    isDisabled,
    onClick,
    onMenuOptionClick
  }) {
    return () => {
      const { editorView } = useEditorStateContext();
      const view = editorView.view;
      const markType = (markName) => {
        const schema = view.state.schema;
        return schema.marks[markName];
      };
      const isActive = () => markIsActive(mark);
      const markIsActive = (markName) => {
        const { state } = view;
        const mark2 = markType(markName);
        const { from, $from, to, empty } = state.selection;
        if (empty)
          return !!mark2.isInSet(state.storedMarks || $from.marks());
        else
          return state.doc.rangeHasMark(from, to, mark2);
      };
      const isOptionDisabled = () => {
        if (isDisabled)
          return isDisabled(view);
        if (mark === "image") {
          if (selectionOnly) {
            const { $cursor } = view.state.selection;
            return !!$cursor || isInCodeBlock() || isIncompatibleMarksAreActive();
          }
        }
        return isInCodeBlock() || isIncompatibleMarksAreActive();
      };
      const isInCodeBlock = () => {
        const node = view.state.selection.$from.node(view.state.selection.$from.depth);
        return node.type === view.state.schema.nodes.code_block;
      };
      const isIncompatibleMarksAreActive = () => {
        return noMix.map(markIsActive).reduce((someMarkActive, nextMarkActive) => nextMarkActive || someMarkActive, false);
      };
      const onOptionClick = () => {
        if (onClick) {
          onClick(view);
        }
        if (onMenuOptionClick) {
          return onMenuOptionClick(view);
        }
        if (isOptionDisabled())
          return;
        const { state, dispatch } = view;
        if (state.selection.$cursor && selectionOnly) {
          return;
        }
        prosemirrorCommands.toggleMark(markType(mark), defaultAttrs)(state, dispatch);
      };
      if (!markType(mark)) {
        return null;
      }
      return /* @__PURE__ */ React__namespace.createElement(MenuButton, {
        "data-tooltip": tooltip,
        "data-side": "top",
        title: tooltip,
        onClick: onOptionClick,
        active: !isOptionDisabled() && isActive(),
        disabled: isOptionDisabled()
      }, /* @__PURE__ */ React__namespace.createElement(Icon, null));
    };
  }
  const MenuPortalContext = React__namespace.createContext(() => {
    return null;
  });
  function useMenuPortal() {
    return React.useContext(MenuPortalContext);
  }
  const MenuPortalProvider = ({ children }) => {
    const wrapperRef = React__namespace.useRef(null);
    const MenuPortal = React__namespace.useCallback((props) => {
      if (!wrapperRef.current)
        return null;
      return ReactDOM.createPortal(props.children, wrapperRef.current);
    }, [wrapperRef]);
    return /* @__PURE__ */ React__namespace.createElement(MenuPortalContext.Provider, {
      value: MenuPortal
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      ref: wrapperRef
    }, children));
  };
  const MenuDropdown = styled__default["default"]((_a) => {
    var _b = _a, { children, open, triggerRef, innerRef } = _b, styleProps = __objRest(_b, ["children", "open", "triggerRef", "innerRef"]);
    const MenuPortal = useMenuPortal();
    const menuPortalRef = React__namespace.useRef(null);
    const [menuOffset, setMenuOffset] = React__namespace.useState(0);
    React__namespace.useEffect(() => {
      if (triggerRef.current && menuPortalRef.current) {
        const menuDropdownBoundingBox = triggerRef.current.getBoundingClientRect();
        const menuPortalBoundingBox = menuPortalRef.current.getBoundingClientRect();
        setMenuOffset(menuDropdownBoundingBox.x - menuPortalBoundingBox.x);
      }
    }, [triggerRef.current, menuPortalRef.current]);
    return /* @__PURE__ */ React__namespace.createElement(MenuPortal, null, /* @__PURE__ */ React__namespace.createElement("div", {
      ref: menuPortalRef
    }, /* @__PURE__ */ React__namespace.createElement(Offset, {
      offset: menuOffset
    }, /* @__PURE__ */ React__namespace.createElement("div", __spreadValues({}, styleProps), children))));
  })`
  border-radius: var(--tina-radius-small);
  border: 1px solid #efefef;
  display: block;
  position: absolute;
  bottom: -4px;
  left: 0;
  transform: translate3d(0, 100%, 0) scale3d(0.5, 0.5, 1);
  opacity: 0;
  pointer-events: none;
  transition: all 85ms ease-out;
  transform-origin: 0 0;
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12), 0px 4px 8px rgba(48, 48, 48, 0.1);
  background-color: white;
  overflow: hidden;
  z-index: 10;
  white-space: nowrap;

  ${(props) => props.open && styled.css`
      opacity: 1;
      pointer-events: all;
      transform: translate3d(0, 100%, 0) scale3d(1, 1, 1);
    `};
`;
  const Offset = styled__default["default"].div`
  position: absolute;
  left: ${(props) => props.offset}px;
`;
  const MenuOption = styled__default["default"].div`
  display: block;
  padding: 8px 12px;
  transition: all 85ms ease-out;
  cursor: pointer;
  &:first-child {
    padding-top: var(--tina-padding-small);
  }
  &:last-child {
    padding-bottom: var(--tina-padding-small);
  }
  &:hover {
    background-color: var(--tina-color-grey-1);
    color: var(--tina-color-primary);
  }
  &:active {
    color: var(--tina-color-primary);
    fill: var(--tina-color-primary);
    background-color: rgba(53, 50, 50, 0.05);
  }
  ${(props) => props.active && styled.css`
      color: var(--tina-color-primary);
      fill: var(--tina-color-primary);
      background-color: rgba(53, 50, 50, 0.05);
    `};
`;
  const findElementOffsetTop = (element, parent) => {
    let target = element;
    let offsetTop = target.offsetTop;
    while (target.offsetParent && (!parent || target.offsetParent !== parent)) {
      target = target.offsetParent;
      offsetTop += target.offsetTop;
    }
    return offsetTop < 0 ? 0 : offsetTop;
  };
  const findElementOffsetLeft = (element, parent) => {
    let target = element;
    let offsetLeft = target.offsetLeft;
    while (target.offsetParent && (!parent || target.offsetParent !== parent)) {
      target = target.offsetParent;
      offsetLeft += target.offsetLeft;
    }
    return offsetLeft;
  };
  const isMarkPresent = (state, markType) => !!getMarkPresent(state, markType);
  const getMarkPresent = (state, markType) => {
    const { selection } = state;
    const { anchor, head } = selection;
    let start;
    let end;
    if (anchor < head) {
      start = anchor;
      end = head;
    } else {
      start = head;
      end = anchor;
    }
    start = selection.empty ? start : start + 1;
    const mark = markType.isInSet(state.doc.resolve(start).marks());
    if (!mark)
      return false;
    let markPresent = mark;
    for (; start < end && markPresent; start += 1) {
      if (!markType.isInSet(state.doc.resolve(start).marks()))
        markPresent = void 0;
    }
    return markPresent;
  };
  const getOS = () => {
    if (typeof global["navigator"] === "undefined")
      return "Windows";
    const nAgt = navigator.userAgent;
    const clientStrings = [
      { s: "Windows", r: /Win16/ },
      { s: "Windows", r: /(Windows 95|Win95|Windows_95)/ },
      { s: "Windows", r: /(Win 9x 4.90|Windows ME)/ },
      { s: "Windows", r: /(Windows 98|Win98)/ },
      { s: "Windows", r: /Windows CE/ },
      { s: "Windows", r: /(Windows NT 5.0|Windows 2000)/ },
      { s: "Windows", r: /(Windows NT 5.1|Windows XP)/ },
      { s: "Windows", r: /Windows NT 5.2/ },
      { s: "Windows", r: /Windows NT 6.0/ },
      { s: "Windows", r: /(Windows 7|Windows NT 6.1)/ },
      { s: "Windows", r: /(Windows 8.1|Windows NT 6.3)/ },
      { s: "Windows", r: /(Windows 8|Windows NT 6.2)/ },
      { s: "Windows", r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/ },
      { s: "Linux", r: /(Linux|X11)/ },
      { s: "iOS", r: /(iPhone|iPad|iPod)/ },
      { s: "Mac OS X", r: /Mac OS X/ },
      { s: "Mac OS", r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/ },
      { s: "QNX", r: /QNX/ },
      { s: "UNIX", r: /UNIX/ },
      { s: "BeOS", r: /BeOS/ }
    ];
    const keys = Object.keys(clientStrings);
    for (let i = 0; i < clientStrings.length; i += 1) {
      const clientObj = clientStrings[keys[i]];
      if (clientObj.r.test(nAgt)) {
        return clientObj.s;
      }
    }
    return "";
  };
  const formatKeymap = (keymapStr) => {
    const os = getOS();
    const mod = os === "Windows" ? "^" : "\u2318";
    let formattedKeymap = keymapStr;
    formattedKeymap = formattedKeymap.replace("Mod", mod);
    formattedKeymap = formattedKeymap.replace("Shift", "\u21E7");
    formattedKeymap = formattedKeymap.replace("Alt", "\u2325");
    return formattedKeymap;
  };
  function deleteEmptyHeading(state, dispatch) {
    const { $cursor } = state.selection;
    if (!$cursor)
      return false;
    const node = state.doc.nodeAt(Math.max($cursor.pos - 1, 0));
    if (!node)
      return false;
    if (node.type != state.schema.nodes.heading)
      return false;
    if (node.textContent.length)
      return false;
    if (dispatch) {
      const { tr } = state;
      dispatch(tr.replaceRangeWith($cursor.pos - 1, $cursor.pos + node.nodeSize - 1, state.schema.nodes.paragraph.create()).setSelection(new prosemirrorState.TextSelection(tr.doc.resolve(state.selection.head))).scrollIntoView());
    }
    return true;
  }
  function toggleHeader(nodeType, attrs2, fallBackNodeType, fallbackAttrs) {
    return function(state, dispatch) {
      const { from, to } = state.selection;
      let firstTextblock = null;
      let firstPos = -1;
      state.doc.nodesBetween(from, to, (node, pos) => {
        if (firstTextblock)
          return false;
        if (node.isTextblock) {
          firstTextblock = node;
          firstPos = pos;
        }
        return true;
      });
      if (!firstTextblock || firstPos < 0)
        return false;
      const $firstPos = state.doc.resolve(firstPos);
      const index = $firstPos.index();
      const setAsParagraph = state.selection.$head.parent.attrs.level == attrs2.level;
      const nextNodeType = setAsParagraph ? fallBackNodeType : nodeType;
      const nextAttrs = setAsParagraph ? fallbackAttrs : attrs2;
      if (!$firstPos.parent.canReplaceWith(index, index + 1, nextNodeType))
        return false;
      if (dispatch) {
        dispatch(state.tr.setBlockType(from, to, nextNodeType, nextAttrs).scrollIntoView());
      }
      return true;
    };
  }
  function blockTool(options) {
    const { Component, children, command, typeName, attrs: attrs2, title } = options;
    return class extends React__namespace.Component {
      constructor() {
        super(...arguments);
        this.canDo = () => command(this.props.view.state);
        this.onClick = () => {
          command(this.props.view.state, this.props.view.dispatch);
          this.props.view.focus();
          this.props.onClick();
        };
      }
      get active() {
        if (!typeName)
          return false;
        const { state } = this.props.view;
        const $from = state.selection.$from;
        const node = $from.node($from.depth);
        const correctNodeType = node.type.name === typeName;
        const correctAttrs = attrs2 ? node.attrs.level === attrs2.level : true;
        return correctNodeType && correctAttrs;
      }
      render() {
        return /* @__PURE__ */ React__namespace.createElement(MenuOption, {
          onClick: this.onClick,
          disabled: !this.canDo(),
          active: this.active
        }, /* @__PURE__ */ React__namespace.createElement(Content, null, /* @__PURE__ */ React__namespace.createElement(Component, null, children), /* @__PURE__ */ React__namespace.createElement(TitleText, null, title)));
      }
    };
  }
  const Content = styled__default["default"].div`
  display: flex;
  justify-content: space-between;
  align-items: center;
`;
  const TitleText = styled__default["default"].span`
  color: #d1d1d1;
  font-size: 12px;
`;
  const ProsemirrorMenu$8 = () => {
    const [active, setActive] = React.useState(false);
    const menuButtonRef = React.useRef();
    const { editorView } = useEditorStateContext();
    const view = editorView.view;
    const toggle = () => setActive(!active);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(toolkit.Dismissible, {
      click: true,
      escape: true,
      disabled: !active,
      onDismiss: toggle
    }, /* @__PURE__ */ React__namespace.createElement(MenuButton, {
      ref: menuButtonRef,
      "data-tooltip": "Heading",
      title: "Heading",
      onClick: toggle,
      active
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.HeadingIcon, null)), /* @__PURE__ */ React__namespace.createElement(MenuDropdown, {
      triggerRef: menuButtonRef,
      open: active
    }, /* @__PURE__ */ React__namespace.createElement(H1, {
      view,
      onClick: toggle
    }), /* @__PURE__ */ React__namespace.createElement(H2, {
      view,
      onClick: toggle
    }), /* @__PURE__ */ React__namespace.createElement(H3, {
      view,
      onClick: toggle
    }), /* @__PURE__ */ React__namespace.createElement(H4, {
      view,
      onClick: toggle
    }), /* @__PURE__ */ React__namespace.createElement(H5, {
      view,
      onClick: toggle
    }), /* @__PURE__ */ React__namespace.createElement(H6, {
      view,
      onClick: toggle
    }))));
  };
  function makeToggleHeader(level) {
    return function toggleHeader$1(state, dispatch) {
      const tn = toggleHeader(state.schema.nodes.heading, { level }, state.schema.nodes.paragraph, null);
      return tn(state, dispatch);
    };
  }
  const BaseHeading = styled.css`
  white-space: nowrap;
  line-height: 1;
  display: block;
  margin: 0;
`;
  const HeadingOne = styled__default["default"].h1`
  ${BaseHeading}
`;
  const HeadingTwo = styled__default["default"].h2`
  ${BaseHeading}
`;
  const HeadingThree = styled__default["default"].h3`
  ${BaseHeading}
`;
  const HeadingFour = styled__default["default"].h4`
  ${BaseHeading}
`;
  const HeadingFive = styled__default["default"].h5`
  ${BaseHeading}
`;
  const HeadingSix = styled__default["default"].h6`
  ${BaseHeading}
`;
  const H1 = blockTool({
    Component: HeadingOne,
    children: "Heading 1",
    command: makeToggleHeader(1),
    typeName: "heading",
    attrs: { level: 1 },
    title: formatKeymap("Mod-Alt-1")
  });
  const H2 = blockTool({
    Component: HeadingTwo,
    children: "Heading 2",
    command: makeToggleHeader(2),
    typeName: "heading",
    attrs: { level: 2 },
    title: formatKeymap("Mod-Alt-2")
  });
  const H3 = blockTool({
    Component: HeadingThree,
    children: "Heading 3",
    command: makeToggleHeader(3),
    typeName: "heading",
    attrs: { level: 3 },
    title: formatKeymap("Mod-Alt-3")
  });
  const H4 = blockTool({
    Component: HeadingFour,
    children: "Heading 4",
    command: makeToggleHeader(4),
    typeName: "heading",
    attrs: { level: 4 },
    title: formatKeymap("Mod-Alt-4")
  });
  const H5 = blockTool({
    Component: HeadingFive,
    children: "Heading 5",
    command: makeToggleHeader(5),
    typeName: "heading",
    attrs: { level: 5 },
    title: formatKeymap("Mod-Alt-5")
  });
  const H6 = blockTool({
    Component: HeadingSix,
    children: "Heading 6",
    command: makeToggleHeader(6),
    typeName: "heading",
    attrs: { level: 6 },
    title: formatKeymap("Mod-Alt-6")
  });
  const MarkdownMenu$8 = () => /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Heading",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.HeadingIcon, null));
  function makeCodeBlock(state, dispatch) {
    const { code_block: code_block2, paragraph: paragraph2 } = state.schema.nodes;
    const { selection, tr } = state;
    const currentNode = selection.$to.node(selection.$to.depth);
    if (currentNode.type === code_block2)
      return prosemirrorCommands.setBlockType(paragraph2)(state, dispatch);
    if (!dispatch || selection.empty)
      return prosemirrorCommands.setBlockType(code_block2)(state, dispatch);
    let content = ``;
    let startPos = void 0;
    let endPos = void 0;
    state.doc.nodesBetween(selection.from, selection.to - 1, (node, pos) => {
      if (node.isTextblock) {
        if (startPos === void 0)
          startPos = pos;
        if (content.length)
          content += `
`;
        content += node.textContent;
        endPos = pos + node.textContent.length + 1;
      }
    });
    const codeBlock = code_block2.createChecked();
    return dispatch(tr.replaceRangeWith(startPos, endPos + 1, codeBlock).insertText(content, startPos + 1).setSelection(new prosemirrorState.TextSelection(tr.doc.resolve(startPos + content.length + 1))));
  }
  const ProsemirrorMenu$7 = commandControl(makeCodeBlock, toolkit.CodeIcon, "Codeblock", formatKeymap("Codeblock Mod-Alt-0"), true);
  const MarkdownMenu$7 = () => /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
    "data-tooltip": "Codeblock",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__default["default"].createElement(toolkit.CodeIcon, null));
  function exitCodeHard(state, dispatch) {
    const { $head } = state.selection;
    const above = $head.node(-1);
    const after = $head.indexAfter(-1);
    const type = above.defaultContentType(after);
    if (dispatch) {
      const pos = $head.before();
      const tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  function exitCodeUp(state, dispatch) {
    const { $head, $anchor } = state.selection;
    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
      return false;
    const above = $head.node(-1);
    const after = $head.indexAfter(-1);
    const type = above.defaultContentType(after);
    if (!above.canReplaceWith(after, after, type))
      return false;
    if (dispatch) {
      const pos = $head.before();
      const tr = state.tr.replaceWith(pos, pos, type.createAndFill());
      tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), -1));
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  function deleteEmptyCodeblock(cm) {
    return (state, dispatch) => {
      const pos = cm.getCursor();
      const code2 = cm.getValue();
      const codeWithoutInvisibles = code2.replace(/[ \r\n]/g, "");
      const shouldRemove = !codeWithoutInvisibles;
      if (!(pos.line == 0 && pos.ch == 0 && shouldRemove)) {
        return false;
      }
      const { $from } = state.selection;
      if (dispatch) {
        const { schema, tr } = state;
        dispatch(tr.replaceRangeWith($from.pos - 1, $from.pos + code2.length + 1, schema.nodes.paragraph.create()).setSelection(new prosemirrorState.TextSelection(tr.doc.resolve($from.pos))));
      }
      return true;
    };
  }
  const ssr = typeof navigator == "undefined";
  const mac$1 = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
  let CodeMirror = null;
  if (!ssr) {
    CodeMirror = require("codemirror");
  }
  class CodeBlockView {
    constructor(node, view, getPos) {
      this.node = node;
      this.view = view;
      this.getPos = getPos;
      this.updating = false;
      this.onCursorActivity = () => {
        if (!this.updating) {
          this.forwardSelection();
        }
      };
      this.forwardSelection = () => {
        if (!this.cm.hasFocus())
          return;
        const state = this.view.state;
        const selection = this.asProseMirrorSelection(state.doc);
        if (!selection.eq(state.selection)) {
          this.view.dispatch(state.tr.setSelection(selection));
        }
      };
      this.onChange = () => {
        if (!this.updating) {
          this.valueChanged();
        }
      };
      if (ssr)
        return;
      this.cm = this.setupCodeMirror(node);
      this.dom = this.cm.getWrapperElement();
      setTimeout(() => this.cm.refresh(), 20);
      this.cm.on("cursorActivity", this.onCursorActivity);
      this.cm.on("changes", this.onChange);
      this.cm.on("focus", this.forwardSelection);
      const offset = this.getPos() + 1;
      const { anchor, head } = view.state.selection;
      this.setSelection(anchor - offset, head - offset);
    }
    valueChanged() {
      const change = computeChange(this.node.textContent, this.cm.getValue());
      if (change) {
        const codeBlockStart = this.getPos() + 1;
        const schema = this.view.state.schema;
        const tr = this.view.state.tr.replaceWith(codeBlockStart + change.from, codeBlockStart + change.to, change.text ? schema.text(change.text) : null);
        this.view.dispatch(tr);
      }
    }
    asProseMirrorSelection(doc2) {
      const offset = this.getPos() + 1;
      const anchor = this.cm.indexFromPos(this.cm.getCursor("anchor")) + offset;
      const head = this.cm.indexFromPos(this.cm.getCursor("head")) + offset;
      return prosemirrorState.TextSelection.create(doc2, anchor, head);
    }
    setSelection(anchor, head) {
      this.cm.focus();
      this.updating = true;
      this.cm.setSelection(this.cm.posFromIndex(anchor), this.cm.posFromIndex(head));
      this.updating = false;
    }
    setupCodeMirror(node) {
      return CodeMirror(null, {
        value: node.textContent,
        lineNumbers: true,
        extraKeys: this.codeMirrorKeymap(),
        mode: node.attrs.params,
        theme: "forestry"
      });
    }
    codeMirrorKeymap() {
      const view = this.view;
      const mod = mac$1 ? "Cmd" : "Ctrl";
      return CodeMirror.normalizeKeyMap({
        Up: () => this.maybeEscape("line", -1),
        Left: () => this.maybeEscape("char", -1),
        Down: () => this.maybeEscape("line", 1),
        Right: () => this.maybeEscape("char", 1),
        Backspace: () => {
          if (!deleteEmptyCodeblock(this.cm)(this.view.state, this.view.dispatch)) {
            return CodeMirror.Pass;
          }
          this.view.focus();
        },
        [`${mod}-Z`]: () => prosemirrorHistory.undo(view.state, view.dispatch),
        [`Shift-${mod}-Z`]: () => prosemirrorHistory.redo(view.state, view.dispatch),
        [`${mod}-Shift-Enter`]: () => {
          const pos = this.cm.getCursor();
          if (this.cm.somethingSelected() || pos.line != this.cm.firstLine()) {
            return CodeMirror.Pass;
          }
          if (view.state.selection.$anchor.parentOffset) {
            const pos2 = view.state.selection.$anchor.pos;
            view.dispatch(view.state.tr.setSelection(prosemirrorState.Selection.near(this.view.state.doc.resolve(pos2 - 1), -1)));
          }
          if (exitCodeUp(view.state, view.dispatch)) {
            view.focus();
          }
          return true;
        },
        ["Shift-Enter"]: () => {
          const pos = this.cm.getCursor();
          if (this.cm.somethingSelected() || pos.line != this.cm.lastLine()) {
            return CodeMirror.Pass;
          }
          if (view.state.selection.$anchor.parentOffset) {
            const pos2 = view.state.selection.$anchor.pos;
            view.dispatch(view.state.tr.setSelection(prosemirrorState.Selection.near(this.view.state.doc.resolve(pos2 - 1), -1)));
          }
          if (prosemirrorCommands.exitCode(view.state, view.dispatch)) {
            return view.focus();
          } else if (exitCodeHard(view.state, view.dispatch)) {
            return view.focus();
          }
        },
        [`${mod}-Alt-0`]: () => {
          const { state, dispatch } = view;
          const { paragraph: paragraph2 } = state.schema.nodes;
          prosemirrorCommands.setBlockType(paragraph2)(state, dispatch);
        }
      });
    }
    maybeEscape(unit, dir) {
      const pos = this.cm.getCursor();
      if (this.cm.somethingSelected() || pos.line != (dir < 0 ? this.cm.firstLine() : this.cm.lastLine()) || unit == "char" && pos.ch != (dir < 0 ? 0 : this.cm.getLine(pos.line).length)) {
        return CodeMirror.Pass;
      }
      const targetPos = this.getPos() + (dir < 0 ? 0 : this.node.nodeSize);
      const selection = prosemirrorState.Selection.near(this.view.state.doc.resolve(targetPos), dir);
      const atEndOfDocument = !(selection.$from.pos + 1 < this.view.state.doc.content.size);
      if (atEndOfDocument) {
        return CodeMirror.Pass;
      }
      this.view.dispatch(this.view.state.tr.setSelection(selection));
      this.view.focus();
    }
    update(node) {
      if (node.type != this.node.type)
        return false;
      this.node = node;
      const change = computeChange(this.cm.getValue(), node.textContent);
      if (change) {
        this.updating = true;
        this.cm.replaceRange(change.text, this.cm.posFromIndex(change.from), this.cm.posFromIndex(change.to));
        this.updating = false;
      }
      return true;
    }
    selectNode() {
      this.cm.focus();
    }
    stopEvent() {
      return true;
    }
  }
  function computeChange(oldVal, newVal) {
    if (oldVal == newVal)
      return null;
    let start = 0;
    let oldEnd = oldVal.length;
    let newEnd = newVal.length;
    while (start < oldEnd && oldVal.charCodeAt(start) == newVal.charCodeAt(start))
      ++start;
    while (oldEnd > start && newEnd > start && oldVal.charCodeAt(oldEnd - 1) == newVal.charCodeAt(newEnd - 1)) {
      oldEnd--;
      newEnd--;
    }
    return { from: start, to: oldEnd, text: newVal.slice(start, newEnd) };
  }
  const codeBlockPluginKey = new prosemirrorState.PluginKey("image");
  const codeBlockPlugin = new prosemirrorState.Plugin({
    key: codeBlockPluginKey,
    props: {
      nodeViews: {
        code_block(node, view, getPos) {
          return new CodeBlockView(node, view, getPos);
        }
      }
    }
  });
  const ProsemirrorMenu$6 = () => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(UndoControl$1, null), /* @__PURE__ */ React__namespace.createElement(RedoControl$1, null));
  const UndoControl$1 = () => {
    const { editorView } = useEditorStateContext();
    const undoChange = () => {
      const { state, dispatch } = editorView.view;
      prosemirrorHistory.undo(state, dispatch);
    };
    const tooltip = formatKeymap("Undo Mod-Z");
    return /* @__PURE__ */ React__namespace.createElement(MenuButton, {
      "data-tooltip": tooltip,
      title: tooltip,
      "data-side": "top",
      onClick: undoChange,
      disabled: prosemirrorHistory.undoDepth(editorView.view.state) < 1
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.UndoIcon, null));
  };
  const RedoControl$1 = () => {
    const { editorView } = useEditorStateContext();
    const redoChange = () => {
      const { state, dispatch } = editorView.view;
      prosemirrorHistory.redo(state, dispatch);
    };
    const tooltip = formatKeymap("Redo Mod-Shift-Z");
    return /* @__PURE__ */ React__namespace.createElement(MenuButton, {
      "data-tooltip": tooltip,
      title: tooltip,
      "data-side": "top",
      onClick: redoChange,
      disabled: prosemirrorHistory.redoDepth(editorView.view.state) < 1
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.RedoIcon, null));
  };
  const MarkdownMenu$6 = () => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(UndoControl, null), /* @__PURE__ */ React__namespace.createElement(RedoControl, null));
  const UndoControl = () => /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Undo",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.UndoIcon, null));
  const RedoControl = () => /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Redo",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.RedoIcon, null));
  const exitCodeMarkOnArrowRight = (view, event) => {
    if (event.key !== "ArrowRight")
      return false;
    const { selection, schema } = view.state;
    const { code: code2 } = schema.marks;
    if (!code2.isInSet(selection.$to.marks()))
      return false;
    const selectionIsAtEnd = selection.$to.node().nodeSize - 2 === selection.$to.parentOffset;
    if (!selectionIsAtEnd)
      return false;
    const { state, dispatch } = view;
    dispatch(state.tr.insertText(" ", selection.$to.pos).removeMark(selection.$to.pos, selection.$to.pos + 1, code2));
    return true;
  };
  const inlinePluginKey = new prosemirrorState.PluginKey("inline");
  const inlinePlugin = new prosemirrorState.Plugin({
    key: inlinePluginKey,
    props: {
      handleKeyDown(view, event) {
        return exitCodeMarkOnArrowRight(view, event);
      }
    }
  });
  const ProsemirrorMenu$5 = () => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(BoldControl, null), /* @__PURE__ */ React__namespace.createElement(ItalicControl, null), /* @__PURE__ */ React__namespace.createElement(StrikeControl, null));
  const BoldControl = markControl({
    mark: "strong",
    Icon: toolkit.BoldIcon,
    tooltip: formatKeymap("Bold Mod-B")
  });
  const ItalicControl = markControl({
    mark: "em",
    Icon: toolkit.ItalicIcon,
    tooltip: formatKeymap("Italic Mod-I")
  });
  const StrikeControl = markControl({
    mark: "strike",
    Icon: toolkit.StrikethroughIcon,
    tooltip: "Strike"
  });
  const MarkdownMenu$5 = () => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Bold",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.BoldIcon, null)), /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Italic",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.ItalicIcon, null)), /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Strike",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.StrikethroughIcon, null)));
  function toggleBulletList(state, dispatch) {
    const lift = prosemirrorSchemaList.liftListItem(state.schema.nodes.list_item);
    const wrap = prosemirrorSchemaList.wrapInList(state.schema.nodes.bullet_list);
    const canDo = wrap(state, dispatch) || lift(state, dispatch);
    return canDo;
  }
  function toggleOrderedList(state, dispatch) {
    const lift = prosemirrorSchemaList.liftListItem(state.schema.nodes.list_item);
    const wrap = prosemirrorSchemaList.wrapInList(state.schema.nodes.ordered_list);
    return wrap(state, dispatch) || lift(state, dispatch);
  }
  const ProsemirrorMenu$4 = (props) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(BulletList$1, __spreadValues({}, props)), /* @__PURE__ */ React__namespace.createElement(OrderedList$1, __spreadValues({}, props)));
  const BulletList$1 = commandControl(toggleBulletList, toolkit.UnorderedListIcon, "Unordered List", formatKeymap("Unordered List Mod-Alt-8"));
  const OrderedList$1 = commandControl(toggleOrderedList, toolkit.OrderedListIcon, "Ordered List", formatKeymap("Ordered List Mod-Alt-7"));
  const MarkdownMenu$4 = (props) => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(BulletList, __spreadValues({}, props)), /* @__PURE__ */ React__namespace.createElement(OrderedList, __spreadValues({}, props)));
  const BulletList = () => /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Unordered List",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.UnorderedListIcon, null));
  const OrderedList = () => /* @__PURE__ */ React__namespace.createElement(MenuButton, {
    "data-tooltip": "Ordered List",
    disabled: true
  }, /* @__PURE__ */ React__namespace.createElement(toolkit.OrderedListIcon, null));
  function wrapInBlockquote(state, dispatch) {
    const { blockquote: blockquote2 } = state.schema.nodes;
    const { start, node } = prosemirrorUtils.findParentNodeOfType(blockquote2)(state.selection) || {};
    if (start && node) {
      const { tr } = state;
      const nodeRange = tr.doc.resolve(start + 1).blockRange(tr.doc.resolve(start + node.nodeSize - 2));
      if (nodeRange) {
        if (dispatch)
          return dispatch(tr.lift(nodeRange, 0));
        else
          return true;
      }
    }
    return prosemirrorCommands.wrapIn(state.schema.nodes.blockquote)(state, dispatch);
  }
  const ProsemirrorMenu$3 = commandControl(wrapInBlockquote, toolkit.QuoteIcon, "Blockquote", "Blockquote");
  const MarkdownMenu$3 = () => /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
    "data-tooltip": "Quote",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__default["default"].createElement(toolkit.QuoteIcon, null));
  const buildCellSelection = (pos, classes, tableMap, table, state) => {
    if (classes.includes("tina_table_header_ext_top_left"))
      return buildTableSelection(pos, tableMap, table, state.doc);
    if (classes.includes("tina_table_header_ext_left"))
      return buildColumnSelection(pos, tableMap, table, state.doc);
    if (classes.includes("tina_table_header_ext_top"))
      return buildRowSelection(pos, tableMap, table, state.doc);
  };
  const buildColumnSelection = (pos, tableMap, table, doc2) => {
    const { width: width2 } = tableMap;
    const colStart = tableMap.map.findIndex((c) => c === pos - table.start);
    return new TableCommands.CellSelection(doc2.resolve(tableMap.map[colStart + width2 - 1] + table.start), doc2.resolve(pos));
  };
  const buildRowSelection = (pos, tableMap, table, doc2) => {
    const { width: width2, height } = tableMap;
    const rowStart = tableMap.map.findIndex((c) => c === pos - table.start);
    return new TableCommands.CellSelection(doc2.resolve(tableMap.map[rowStart + width2 * (height - 1)] + table.start), doc2.resolve(pos));
  };
  const buildTableSelection = (pos, tableMap, table, doc2) => new TableCommands.CellSelection(doc2.resolve(tableMap.map[tableMap.map.length - 1] + table.start), doc2.resolve(pos));
  const buildExtendedHeaders = (tableNode, selection) => {
    const tableMap = TableCommands.TableMap.get(tableNode.node);
    const colSelection = selection.isColSelection && selection.isColSelection();
    const rowSelection = selection.isRowSelection && selection.isRowSelection();
    let decorations = buildExtendedTableHeaders(tableNode, colSelection, rowSelection);
    decorations = [
      ...decorations,
      ...buildExtendedColumnHeaders(tableNode, tableMap, selection, colSelection)
    ];
    decorations = [
      ...decorations,
      ...buildExtendedRowHeaders(tableNode, tableMap, selection, rowSelection)
    ];
    return decorations;
  };
  const buildExtendedColumnHeaders = (tableNode, tableMap, selection, colSelection) => {
    const decorations = [];
    const cellMap = tableMap.map;
    for (let i = 0; i < tableMap.width; i++) {
      const div = document.createElement("div");
      div.classList.add("tina_table_header_ext_top");
      if (colSelection && selection.ranges.some((r) => r.$from.pos === tableNode.start + cellMap[i] + 1)) {
        div.classList.add("tina_table_header_ext_top_selected");
      }
      decorations.push(prosemirrorView.Decoration.widget(tableNode.start + cellMap[i] + 1, div));
    }
    return decorations;
  };
  const buildExtendedRowHeaders = (tableNode, tableMap, selection, rowSelection) => {
    const decorations = [];
    const cellMap = tableMap.map;
    for (let i = 0; i < tableMap.height; i++) {
      const div = document.createElement("div");
      div.classList.add("tina_table_header_ext_left");
      if (rowSelection && selection.ranges.some((r) => r.$from.pos === tableNode.start + cellMap[i * tableMap.width] + 1)) {
        div.classList.add("tina_table_header_ext_left_selected");
      }
      decorations.push(prosemirrorView.Decoration.widget(tableNode.start + cellMap[i * tableMap.width] + 1, div));
    }
    return decorations;
  };
  const buildExtendedTableHeaders = (tableNode, colSelection, rowSelection) => {
    const decorations = [];
    const div = document.createElement("div");
    div.classList.add("tina_table_header_ext_top_left");
    if (colSelection && rowSelection) {
      div.classList.add("tina_table_header_ext_top_left_selected");
    }
    decorations.push(prosemirrorView.Decoration.widget(tableNode.start + 2, div));
    return decorations;
  };
  const tablePluginKey = new prosemirrorState.PluginKey("table");
  const tablePlugin = new prosemirrorState.Plugin({
    key: tablePluginKey,
    state: {
      init: () => {
        return { deco: prosemirrorView.DecorationSet.empty };
      },
      apply(tr, prev, oldState, newState) {
        if (tr.getMeta("image_clicked") === false)
          return prev;
        const { selection } = newState;
        if (selection) {
          const { table } = newState.schema.nodes;
          const tableNode = prosemirrorUtils.findParentNodeOfType(table)(selection);
          if (tableNode) {
            const selectionNotChanged = selection === oldState.selection;
            const tableNotChanged = (tableNode && tableNode.node.nodeSize) === (prev.selectedTable && prev.selectedTable.node.nodeSize) && (tableNode && tableNode.start) === (prev.selectedTable && prev.selectedTable.start);
            if (selectionNotChanged && tableNotChanged)
              return prev;
            const decorations = buildExtendedHeaders(tableNode, selection);
            if (decorations.length)
              return {
                deco: prosemirrorView.DecorationSet.create(newState.doc, decorations),
                tableMap: TableCommands.TableMap.get(tableNode.node),
                selectedTable: tableNode
              };
          }
        }
        return { deco: prosemirrorView.DecorationSet.empty };
      }
    },
    props: {
      decorations(state) {
        return this.getState(state).deco;
      },
      handleClickOn(view, _1, _2, nodePos, event, direct) {
        if (!direct)
          return false;
        const targetClasses = event.target.classList;
        const { state, dispatch } = view;
        const tablePluginState = tablePluginKey.getState(state);
        const { tableMap, selectedTable } = tablePluginState;
        const cellSelection = buildCellSelection(nodePos, targetClasses.value, tableMap, selectedTable, state);
        if (cellSelection)
          dispatch(state.tr.setSelection(cellSelection));
        return false;
      }
    }
  });
  const createCell = (cellType, cellContent) => {
    if (cellContent)
      return cellType.createChecked(null, cellContent);
    return cellType.createAndFill();
  };
  const insertTable = (state, dispatch) => {
    if (!dispatch)
      return true;
    const {
      table_cell: tableCell,
      table_header: tableHeader,
      table_row: tableRow,
      table
    } = state.schema.nodes;
    const rowsCount = 3;
    const colsCount = 3;
    const cells = [];
    const headerCells = [];
    for (let i = 0; i < colsCount; i += 1) {
      headerCells.push(createCell(tableHeader));
      cells.push(createCell(tableCell));
    }
    const rows = [];
    for (let i = 0; i < rowsCount; i += 1) {
      rows.push(tableRow.createChecked(null, i === 0 ? headerCells : cells));
    }
    const newTable = table.createChecked(null, rows);
    const { selection, tr } = state;
    const { $from, $to } = selection;
    const start = $from.pos - 1;
    const end = $to.pos < state.doc.content.size ? $to.pos + 1 : $to.pos;
    dispatch(tr.replaceWith(start, end, newTable).setSelection(new prosemirrorState.TextSelection(tr.doc.resolve($from.pos + 1))).scrollIntoView());
    return true;
  };
  function insertTableCmd(state, dispatch) {
    const { table, code_block: code_block2 } = state.schema.nodes;
    const { selection } = state;
    const currentNode = selection.$to.node(selection.$to.depth);
    if (currentNode && currentNode.type === code_block2)
      return false;
    const tableParent = prosemirrorUtils.findParentNodeOfType(table)(selection);
    if (tableParent)
      return false;
    return insertTable(state, dispatch);
  }
  const ProsemirrorMenu$2 = commandControl(insertTableCmd, toolkit.TableIcon, "Table", "Table");
  const MarkdownMenu$2 = () => /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
    "data-tooltip": "Table",
    disabled: true
  }, /* @__PURE__ */ React__default["default"].createElement(toolkit.TableIcon, null));
  function insertImage(state, dispatch, src) {
    const nodeType = state.schema.nodes["image"];
    const image2 = nodeType.createAndFill({ src, alt: "", title: "" });
    if (dispatch) {
      dispatch(state.tr.replaceSelectionWith(image2).scrollIntoView());
    }
    return true;
  }
  function insertImageList(state, dispatch, imageSrc) {
    if (dispatch) {
      const nodeType = state.schema.nodes["image"];
      const { tr } = state;
      imageSrc.forEach((src) => {
        const image2 = nodeType.createAndFill({ src, alt: "", title: "" });
        tr.replaceSelectionWith(image2);
      });
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  const Identity = (str) => str;
  class ImageView {
    constructor(node, view, previewSrc = Identity) {
      this.previewSrc = previewSrc;
      this.selectNode = () => {
        if (this.img) {
          this.img.style.outline = "4px solid #0084FF";
          this.img.classList.add("tina-selected-image");
        }
      };
      this.deselectNode = () => {
        if (this.img) {
          this.img.style.outline = "";
          this.img.classList.remove("tina-selected-image");
        }
      };
      this.destroy = () => {
        this.deselectNode();
      };
      this.node = node;
      this.view = view;
      this.dom = document.createElement("span");
      this.dom.classList.add("tinacms-image-wrapper");
      this.img = document.createElement("img");
      const { src, align, alt, title, width: width2, height } = node.attrs;
      this.updateImgSrc(src);
      if (height)
        this.img.style.height = height;
      if (width2)
        this.img.style.width = width2;
      if (align)
        this.img.classList.add(`align-${align}`);
      if (alt)
        this.img.alt = alt;
      if (title)
        this.img.title = title;
      this.dom.appendChild(this.img);
    }
    async updateImgSrc(src) {
      if (!this.img)
        return;
      try {
        this.img.src = await this.previewSrc(src);
      } catch {
        this.img.src = src;
      }
    }
    update(node) {
      if (this.img) {
        const { alt, title } = node.attrs;
        if (alt)
          this.img.alt = alt;
        if (title)
          this.img.title = title;
      }
      return true;
    }
  }
  const imagePluginKey = new prosemirrorState.PluginKey("image");
  const setSelectionAtPos = (state, dispatch, pos) => {
    dispatch(state.tr.setSelection(new prosemirrorState.NodeSelection(state.tr.doc.resolve(pos))));
  };
  const insertImageFiles = (editorView, data, uploadImages) => {
    const files = [];
    for (let i = 0; i < data.files.length; i++) {
      const file = data.files[i];
      if (file.type.match("image.*"))
        files.push(file);
    }
    if (files.length) {
      const { state, dispatch } = editorView;
      dispatch(state.tr.setMeta("loading_images", files.length));
      const uploadPromise = uploadImages(files);
      uploadPromise.then((urls = []) => {
        dispatch(state.tr.setMeta("loading_images", 0));
        insertImageList(state, dispatch, urls);
        editorView.focus();
      });
      return true;
    }
    return false;
  };
  const imagePlugin = ({ previewSrc, upload: uploadImages }) => new prosemirrorState.Plugin({
    key: imagePluginKey,
    state: {
      init: () => {
        return { selectedImage: void 0 };
      },
      apply(tr, prev, _, newState) {
        if (tr.getMeta("loading_images") > 0) {
          const loadingImagesCount = tr.getMeta("loading_images");
          const div = document.createElement("div");
          for (let i = 0; i < loadingImagesCount; i++) {
            const childElement = document.createElement("div");
            childElement.classList.add("image_loading_indicator");
            div.appendChild(childElement);
          }
          return __spreadProps(__spreadValues({}, prev), {
            deco: prosemirrorView.DecorationSet.create(newState.doc, [
              prosemirrorView.Decoration.widget(newState.selection.$to.pos, div)
            ])
          });
        }
        if (tr.getMeta("loading_images") === 0) {
          return __spreadProps(__spreadValues({}, prev), {
            deco: void 0
          });
        }
        if (prev && prev.selectedImage) {
          const { pos } = prev.selectedImage;
          if (!tr.doc.nodeAt(pos))
            return __spreadProps(__spreadValues({}, prev), {
              selectedImage: void 0
            });
        }
        const selectedImage = tr.getMeta("image_clicked");
        if (selectedImage)
          return __spreadProps(__spreadValues({}, prev), { selectedImage });
        if (selectedImage === false)
          return __spreadProps(__spreadValues({}, prev), { selectedImage: void 0 });
        return prev;
      }
    },
    props: {
      nodeViews: {
        image(node, view) {
          return new ImageView(node, view, previewSrc);
        }
      },
      decorations(state) {
        return this.getState(state).deco;
      },
      handleKeyDown(view, event) {
        const { state, dispatch } = view;
        const { selection, schema } = state;
        if (event.key === "Escape") {
          dispatch(state.tr.setMeta("image_clicked", false));
        } else if (event.key === "Backspace" && selection.$to.nodeBefore && selection.$to.nodeBefore.type === schema.nodes.image) {
          setSelectionAtPos(state, dispatch, selection.$to.pos - 1);
          return true;
        } else if (event.key === "Delete" && selection.$to.nodeAfter && selection.$to.nodeAfter.type === schema.nodes.image) {
          setSelectionAtPos(state, dispatch, selection.$to.pos);
          return true;
        }
        return false;
      },
      handleClickOn(view, _1, node, nodePos, _2, direct) {
        if (!direct)
          return false;
        const { state, dispatch } = view;
        const { image: image2 } = view.state.schema.nodes;
        if (node.type === image2) {
          dispatch(state.tr.setMeta("image_clicked", { pos: nodePos, node }));
        } else {
          dispatch(state.tr.setMeta("image_clicked", false));
        }
        return false;
      },
      handleDrop(editorView, event, _, moved) {
        if (moved || !uploadImages)
          return false;
        event.preventDefault();
        const dataTransfer = event.dataTransfer;
        if (!dataTransfer)
          return false;
        return insertImageFiles(editorView, dataTransfer, uploadImages);
      },
      handlePaste(editorView, event) {
        if (!uploadImages)
          return false;
        event.preventDefault();
        const clipboardData = event.clipboardData;
        if (!clipboardData)
          return false;
        return insertImageFiles(editorView, clipboardData, uploadImages);
      }
    }
  });
  const ProsemirrorMenu$1 = ({ imageProps }) => {
    const cms = tinacms.useCMS();
    const menuButtonRef = React.useRef();
    const { editorView } = useEditorStateContext();
    if (!imageProps || !imageProps.upload)
      return null;
    const { parse, mediaDir } = imageProps;
    const insertImageInEditor = (src) => {
      if (!editorView)
        return;
      const { state, dispatch } = editorView.view;
      insertImage(state, dispatch, src);
      editorView.view.focus();
    };
    async function onMediaSelect(media) {
      var _a, _b;
      if (media) {
        const parseFunc = ((_b = (_a = cms.media) == null ? void 0 : _a.store) == null ? void 0 : _b.parse) || parse;
        insertImageInEditor(parseFunc(media));
      }
    }
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
      title: "Image",
      ref: menuButtonRef,
      onClick: () => {
        cms.media.open({
          directory: mediaDir || "/",
          onSelect: onMediaSelect
        });
      }
    }, /* @__PURE__ */ React__default["default"].createElement(toolkit.MediaIcon, null)));
  };
  const MarkdownMenu$1 = ({ uploadImages }) => uploadImages ? /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
    "data-testid": "image-menu",
    "data-tooltip": "Image",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__default["default"].createElement(toolkit.MediaIcon, null)) : null;
  const ImageEdit = () => {
    const { editorView } = useEditorStateContext();
    const view = editorView.view;
    const imagePluginState = imagePluginKey.getState(view.state);
    if (!imagePluginState || !imagePluginState.selectedImage)
      return null;
    const { node, pos } = imagePluginState.selectedImage;
    const { link: link2 } = view.state.schema.marks;
    const linkMark = node.marks.find((mark) => mark.type === link2);
    const [title, setTitle] = React.useState(node.attrs.title);
    const [alt, setAlt] = React.useState(node.attrs.alt);
    const [linkTitle, setLinkTitle] = React.useState(linkMark && linkMark.attrs.title);
    const [linkSrc, setLinkSrc] = React.useState(linkMark && linkMark.attrs.href);
    const { top, left } = view.coordsAtPos(pos);
    const [modalTop, setModalTop] = React.useState(top);
    const [modalLeft, setModalLeft] = React.useState(left);
    const wrapperRef = React.useRef();
    const inputRef = React.useRef();
    const imageRef = React.useRef();
    const [linked, toggleLinked] = React.useState(!!linkMark);
    function positionImage(scroll) {
      const image2 = document.getElementsByClassName("tina-selected-image")[0];
      const wysiwygWrapper = document.getElementsByClassName("wysiwyg-wrapper")[0];
      if (image2 && (imageRef.current !== image2 || scroll) && wrapperRef.current) {
        imageRef.current = image2;
        const wrapperDimensions = wrapperRef.current.getBoundingClientRect();
        setModalLeft(image2.clientWidth / 2 + findElementOffsetLeft(image2, wysiwygWrapper) - wrapperDimensions.width / 2);
        setModalTop(findElementOffsetTop(image2, wysiwygWrapper));
      }
    }
    React.useEffect(() => {
      const debouncedPositionImage = debounce__default["default"](() => positionImage(true), 10);
      window.addEventListener("scroll", debouncedPositionImage);
      return () => {
        window.removeEventListener("scroll", debouncedPositionImage);
      };
    });
    React.useEffect(() => {
      setLinkTitle(linkMark ? linkMark.attrs.title : "");
      setLinkSrc(linkMark ? linkMark.attrs.href : "");
      toggleLinked(!!linkMark);
    }, [linkMark]);
    React.useEffect(() => {
      setTitle(node.attrs.title);
      setAlt(node.attrs.alt);
    }, [imagePluginState.selectedImage.node]);
    React.useEffect(() => {
      setTimeout(() => {
        if (inputRef.current)
          inputRef.current.focus();
      });
    }, [inputRef]);
    React.useEffect(positionImage);
    const updateNodeAttrs = () => {
      const { dispatch, state } = view;
      const { image: image2 } = state.schema.nodes;
      const { link: link22 } = state.schema.marks;
      const { tr } = state;
      if (linked && (linkSrc || linkTitle)) {
        tr.addMark(pos, pos + 1, link22.create({ href: linkSrc, title: linkTitle }));
      } else {
        tr.removeMark(pos, pos + 1, link22);
      }
      tr.setNodeMarkup(pos, image2, __spreadProps(__spreadValues({}, node.attrs), {
        alt,
        title
      })).setSelection(new prosemirrorState.NodeSelection(tr.doc.resolve(pos)));
      dispatch(tr);
      closeImageSettings();
      view.focus();
    };
    const closeImageSettings = () => {
      const { dispatch, state } = view;
      dispatch(state.tr.setMeta("image_clicked", false));
      setTitle("");
      setAlt("");
      setLinkTitle("");
      setLinkSrc("");
      view.focus();
    };
    const handleKeyPress = (evt) => {
      if (evt.key === "Escape")
        closeImageSettings();
      if (evt.key === "Enter")
        updateNodeAttrs();
    };
    return /* @__PURE__ */ React__default["default"].createElement(LinkPopup$1, {
      top: modalTop,
      left: modalLeft,
      ref: wrapperRef,
      onKeyDown: handleKeyPress
    }, /* @__PURE__ */ React__default["default"].createElement(LinkLabel$1, null, "Title"), /* @__PURE__ */ React__default["default"].createElement(LinkInput$1, {
      placeholder: "Enter Title",
      type: "text",
      ref: inputRef,
      value: title,
      onChange: (evt) => setTitle(evt.target.value)
    }), /* @__PURE__ */ React__default["default"].createElement(LinkLabel$1, null, "Alt"), /* @__PURE__ */ React__default["default"].createElement(LinkInput$1, {
      placeholder: "Enter Alt Text",
      type: "text",
      value: alt,
      onChange: (evt) => setAlt(evt.target.value)
    }), /* @__PURE__ */ React__default["default"].createElement(ToggleElement, null, /* @__PURE__ */ React__default["default"].createElement(ToggleInput, {
      id: "toggleImageLink",
      onChange: () => {
        toggleLinked(!linked);
        if (!linked) {
          setLinkTitle("");
          setLinkSrc("");
        }
      },
      type: "checkbox"
    }), /* @__PURE__ */ React__default["default"].createElement(ToggleLabel, {
      htmlFor: "toggleImageLink",
      role: "switch"
    }, "Insert Link", /* @__PURE__ */ React__default["default"].createElement(ToggleSwitch, {
      checked: linked
    }, /* @__PURE__ */ React__default["default"].createElement("span", null)))), linked && /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(LinkLabel$1, null, "Link Title"), /* @__PURE__ */ React__default["default"].createElement(LinkInput$1, {
      placeholder: "Enter Link Title",
      type: "text",
      value: linkTitle,
      onChange: (evt) => setLinkTitle(evt.target.value)
    }), /* @__PURE__ */ React__default["default"].createElement(LinkLabel$1, null, "Link URL"), /* @__PURE__ */ React__default["default"].createElement(LinkInput$1, {
      placeholder: "Enter Link URL",
      type: "text",
      value: linkSrc,
      onChange: (evt) => setLinkSrc(evt.target.value)
    })), /* @__PURE__ */ React__default["default"].createElement(LinkActions$1, null, /* @__PURE__ */ React__default["default"].createElement(CancelLink, {
      onClick: closeImageSettings
    }, "Cancel"), /* @__PURE__ */ React__default["default"].createElement(SaveLink$1, {
      onClick: updateNodeAttrs
    }, "Save")));
  };
  const LinkPopup$1 = styled__default["default"].span`
  background-color: #f6f6f9;
  position: absolute;
  border-radius: var(--tina-radius-small);
  border: 1px solid var(--tina-color-grey-2);
  filter: drop-shadow(0px 4px 8px rgba(48, 48, 48, 0.1))
    drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.12));
  transform-origin: 50% 0;
  overflow: visible;
  padding: 12px;
  z-index: 10;
  width: 256px;
  left: ${({ left }) => `${left}px`};
  top: ${({ top }) => `${top}px`};
`;
  const LinkLabel$1 = styled__default["default"].label`
  display: block;
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  color: var(--tina-color-grey-8);
  margin-bottom: 3px;
`;
  const LinkInput$1 = styled__default["default"].input`
  position: relative;
  background-color: white;
  border-radius: var(--tina-radius-small);
  font-size: var(--tina-font-size-1);
  line-height: 1.35;
  transition: all 85ms ease-out;
  padding: 8px 12px;
  border: 1px solid var(--tina-color-grey-2);
  width: 100%;
  margin: 0 0 8px 0;
  outline: none;
  box-shadow: 0 0 0 2px transparent;

  &:hover {
    box-shadow: 0 0 0 2px var(--tina-color-grey-3);
  }

  &:focus {
    box-shadow: 0 0 0 2px var(--tina-color-primary);
  }

  &::placeholder {
    font-size: var(--tina-font-size-2);
    color: #cfd3d7;
  }
`;
  const LinkActions$1 = styled__default["default"].div`
  display: flex;
  justify-content: flex-end;
  padding-top: 4px;
`;
  const SaveLink$1 = styled__default["default"].button`
  text-align: center;
  border: 0;
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: var(--tina-color-primary);
  color: white;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: var(--tina-color-primary-light);
  }
  &:active {
    background-color: var(--tina-color-primary-dark);
  }
`;
  const CancelLink = styled__default["default"].button`
  text-align: center;
  border: 1px solid var(--tina-color-grey-2);
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: white;
  color: var(--tina-color-primary);
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: var(--tina-color-grey-1);
    opacity: 1;
  }
  &:active {
    background-color: var(--tina-color-primary-dark);
  }
`;
  const ToggleElement = styled__default["default"].div`
  display: block;
  position: relative;
  margin: 0 0 8px 0;
`;
  const ToggleLabel = styled__default["default"].label`
  background: none;
  padding: 0;
  opacity: ${(props) => props.disabled ? "0.4" : "1"};
  outline: none;
  height: 28px;
  pointer-events: ${(props) => props.disabled ? "none" : "inherit"};
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  line-height: 1.35;
  color: var(--tina-color-grey-8);
`;
  const ToggleSwitch = styled__default["default"].div`
  position: relative;
  width: 48px;
  height: 28px;
  border-radius: var(--tina-radius-big);
  background-color: white;
  border: 1px solid var(--tina-color-grey-2);
  pointer-events: none;
  margin-left: -2px;
  span {
    position: absolute;
    border-radius: var(--tina-radius-big);
    left: 2px;
    top: 50%;
    width: calc(28px - 6px);
    height: calc(28px - 6px);
    background: ${(p) => p.checked ? "var(--tina-color-primary)" : "var(--tina-color-grey-3)"};
    transform: translate3d(${(p) => p.checked ? "20px" : "0"}, -50%, 0);
    transition: all 150ms ease-out;
  }
`;
  const ToggleInput = styled__default["default"].input`
  position: absolute;
  left: 0;
  top: 0;
  width: 48px;
  height: 28px;
  opacity: 0;
  margin: 0;
  cursor: ${(props) => props.disabled ? "not-allowed" : "pointer"};
`;
  const Loader = () => {
    const markerImageLoader = document.getElementsByClassName("image_loading_indicator");
    if (!markerImageLoader.length)
      return null;
    const loaders = [];
    for (let i = 0; i < markerImageLoader.length; i++) {
      loaders.push(ReactDOM__default["default"].createPortal(/* @__PURE__ */ React__default["default"].createElement(ImagePlaceholder, null), markerImageLoader[0]));
    }
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, loaders);
  };
  const ImagePlaceholder = styled__default["default"]((_c) => {
    var styleProps = __objRest(_c, []);
    return /* @__PURE__ */ React__default["default"].createElement("div", __spreadValues({}, styleProps), /* @__PURE__ */ React__default["default"].createElement(tinacms.LoadingDots, {
      color: "var(--tina-color-primary)"
    }));
  })`
  display: flex;
  width: 100%;
  align-items: center;
  justify-content: center;
  padding: 64px;
  background-color: rgba(100, 100, 100, 0.07);
`;
  const IMG_REGEX = /\.(jpe?g|png)/;
  const HTTP_LINK_REGEX = /\bhttps?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:;%_\+.,~#?&//=]*)/g;
  const linkify = function(fragment) {
    const linkified = [];
    fragment.forEach(function(child) {
      if (child.isText) {
        const text2 = child.text;
        let pos = 0;
        let match;
        const link2 = child.type.schema.marks["link"];
        const img = child.type.schema.nodes["image"];
        const matches = [];
        while (match = HTTP_LINK_REGEX.exec(text2)) {
          const start = match.index;
          const end = start + match[0].length;
          matches.push({ start, end });
        }
        matches.forEach(({ start, end }) => {
          if (start > 0) {
            linkified.push(child.cut(pos, start));
          }
          let attrs2;
          const urlText = text2.slice(start, end);
          if (IMG_REGEX.test(urlText)) {
            attrs2 = { src: urlText, title: "", alt: "" };
            linkified.push(img.create(attrs2));
          } else {
            attrs2 = { href: urlText, title: urlText };
            linkified.push(child.cut(start, end).mark(link2.create(attrs2).addToSet(child.marks)));
          }
          pos = end;
        });
        if (pos < text2.length) {
          linkified.push(child.cut(pos));
        }
      } else {
        linkified.push(child.copy(linkify(child.content)));
      }
    });
    return prosemirrorModel.Fragment.fromArray(linkified);
  };
  const linkPluginKey = new prosemirrorState.PluginKey("image");
  function linkPlugin() {
    let shiftKey;
    return new prosemirrorState.Plugin({
      key: linkPluginKey,
      state: {
        init: () => {
          return { showLinkForm: false };
        },
        apply(tr, prev, _) {
          if (tr.getMeta("show_link_toolbar") === false) {
            return {
              show_link_toolbar: false
            };
          }
          if (tr.getMeta("show_link_toolbar")) {
            return {
              show_link_toolbar: true
            };
          }
          return prev;
        }
      },
      props: {
        transformPasted(slice) {
          if (shiftKey) {
            return slice;
          }
          return new prosemirrorModel.Slice(linkify(slice.content), slice.openStart, slice.openEnd);
        },
        handleKeyDown(_x, e) {
          shiftKey = e.shiftKey;
          return false;
        },
        handleClickOn(view, _1) {
          const { dispatch, state } = view;
          const { tr } = state;
          dispatch(tr.setMeta("show_link_toolbar", false));
        }
      }
    });
  }
  function markExtend($cursor, markType) {
    window.$cursor = $cursor;
    let startIndex = $cursor.index();
    let endIndex = $cursor.indexAfter();
    if (startIndex === $cursor.parent.childCount) {
      startIndex--;
      endIndex--;
    }
    const mark = markType.isInSet($cursor.parent.child(startIndex).marks);
    if (!mark)
      return;
    const hasMark = (index) => mark.isInSet($cursor.parent.child(index).marks);
    while (startIndex > 0 && hasMark(startIndex - 1)) {
      startIndex--;
    }
    while (endIndex < $cursor.parent.childCount && hasMark(endIndex)) {
      endIndex++;
    }
    let startPos = $cursor.start();
    let endPos = startPos;
    for (let i = 0; i < endIndex; i++) {
      const size = $cursor.parent.child(i).nodeSize;
      if (i < startIndex)
        startPos += size;
      endPos += size;
    }
    return { from: startPos, to: endPos, mark };
  }
  function unmountLinkForm(view) {
    const { dispatch, state } = view;
    dispatch(state.tr.setMeta("show_link_toolbar", false));
  }
  function updateLinkBeingEdited(state, dispatch, attrs2) {
    if (dispatch) {
      const { selection, schema, tr } = state;
      const mark = markExtend(selection.$anchor, schema.marks.link);
      if (mark) {
        tr.addMark(mark.from, mark.to, schema.marks.link.create(attrs2));
      }
      tr.setMeta("show_link_toolbar", false);
      dispatch(tr);
    }
    return true;
  }
  function removeLinkBeingEdited(state, dispatch) {
    if (dispatch) {
      const { selection, schema, tr } = state;
      const mark = markExtend(selection.$anchor, schema.marks.link);
      if (mark) {
        tr.removeMark(mark.from, mark.to, mark.mark);
      }
      tr.setMeta("show_link_toolbar", false);
      dispatch(tr);
    }
    return true;
  }
  const openLinkPopup = (state, dispatch) => {
    const { schema, selection } = state;
    const { marks: marks2 } = schema;
    if (selection.empty && !isMarkPresent(state, marks2.link))
      return false;
    const tr = state.tr.setMeta("show_link_toolbar", true);
    if (!isMarkPresent(state, marks2.link)) {
      const { $to, $from } = selection;
      tr.addMark($from.pos, $to.pos, marks2.link.create({
        href: "",
        title: ""
      }));
    }
    return dispatch(tr);
  };
  const ProsemirrorMenu = markControl({
    mark: "link",
    Icon: toolkit.LinkIcon,
    tooltip: formatKeymap("Link Mod-K"),
    selectionOnly: true,
    noMix: ["code"],
    isDisabled: (view) => {
      const { schema, selection } = view.state;
      const { marks: marks2, nodes: nodes2 } = schema;
      if (selection.empty && !isMarkPresent(view.state, marks2.link))
        return true;
      const selectedNode = selection.$from.node();
      const imagePluginState = imagePluginKey.getState(view.state);
      return !!(imagePluginState == null ? void 0 : imagePluginState.selectedImage) || selectedNode && selectedNode.type === nodes2.code_block;
    },
    onMenuOptionClick: (view) => {
      const { state, dispatch } = view;
      return openLinkPopup(state, dispatch);
    }
  });
  const MarkdownMenu = () => /* @__PURE__ */ React__default["default"].createElement(MenuButton, {
    "data-tooltip": "Link",
    "data-side": "top",
    disabled: true
  }, /* @__PURE__ */ React__default["default"].createElement(toolkit.LinkIcon, null));
  class InnerForm extends React__namespace.Component {
    constructor() {
      super(...arguments);
      this.state = {
        href: this.props.href || ""
      };
      this.inputRef = React__namespace.createRef();
      this.setHref = ({ target: { value } }) => this.setState(() => ({ href: value }));
      this.save = () => this.props.onChange(this.state);
      this.onEnterSave = (e) => {
        if (e.key === "Enter") {
          this.save();
        }
      };
      this.onEscapeCancel = (e) => {
        if (e.keyCode === 27) {
          this.closeModal();
        }
      };
    }
    componentDidMount() {
      document.addEventListener("keydown", this.onEscapeCancel);
      if (this.inputRef.current)
        this.inputRef.current.focus();
    }
    componentWillUnmount() {
      document.removeEventListener("keydown", this.onEscapeCancel);
    }
    componentDidUpdate(prevProps) {
      const { href } = this.props;
      if (href !== prevProps.href)
        this.setState(() => ({ href }));
    }
    closeModal() {
      const { href } = this.state;
      const { cancel, removeLink, href: originalHref } = this.props;
      if (!href && !originalHref)
        removeLink();
      cancel();
    }
    render() {
      const { removeLink, style = {} } = this.props;
      const { href } = this.state;
      return /* @__PURE__ */ React__namespace.createElement(LinkPopup, {
        style: __spreadValues({}, style)
      }, /* @__PURE__ */ React__namespace.createElement(LinkLabel, null, "URL"), /* @__PURE__ */ React__namespace.createElement(LinkInput, {
        ref: this.inputRef,
        placeholder: "Enter URL",
        type: "text",
        value: href,
        onChange: this.setHref,
        onKeyPress: this.onEnterSave
      }), /* @__PURE__ */ React__namespace.createElement(LinkActions, null, /* @__PURE__ */ React__namespace.createElement(DeleteLink, {
        onClick: removeLink
      }, "Delete"), /* @__PURE__ */ React__namespace.createElement(SaveLink, {
        onClick: this.save,
        disabled: !href
      }, "Save")));
    }
  }
  const LinkPopupKeyframes = styled.keyframes`
  0% {
    transform: scale3d(0.5,0.5,1)
  }
  100% {
    transform: scale3d(1, 1, 1);
  }
`;
  const LinkPopup = styled__default["default"].div`
  background-color: #f6f6f9;
  position: relative;
  height: max-content;
  border-radius: var(--tina-radius-small);
  border: 1px solid var(--tina-color-grey-2);
  filter: drop-shadow(0px 4px 8px rgba(48, 48, 48, 0.1))
    drop-shadow(0px 2px 3px rgba(0, 0, 0, 0.12));
  transform-origin: 50% 0;
  animation: ${LinkPopupKeyframes} 85ms ease-out both 1;
  overflow: visible;
  padding: 12px;
  z-index: 10;
`;
  const LinkLabel = styled__default["default"].label`
  display: block;
  font-size: var(--tina-font-size-1);
  font-weight: 600;
  letter-spacing: 0.01em;
  color: var(--tina-color-grey-8);
  margin-bottom: 3px;
`;
  const LinkInput = styled__default["default"].input`
  position: relative;
  background-color: white;
  border-radius: var(--tina-radius-small);
  font-size: var(--tina-font-size-1);
  line-height: 1.35;
  transition: all 85ms ease-out;
  padding: 8px 12px;
  border: 1px solid var(--tina-color-grey-2);
  width: 100%;
  margin: 0 0 8px 0;
  outline: none;
  box-shadow: 0 0 0 2px transparent;

  &:hover {
    box-shadow: 0 0 0 2px var(--tina-color-grey-3);
  }

  &:focus {
    box-shadow: 0 0 0 2px #0084ff;
  }

  &::placeholder {
    font-size: var(--tina-font-size-2);
    color: #cfd3d7;
  }
`;
  const LinkActions = styled__default["default"].div`
  display: flex;
  justify-content: flex-end;
  padding-top: 4px;
`;
  const SaveLink = styled__default["default"].button`
  text-align: center;
  border: 0;
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: #0084ff;
  color: white;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: #2296fe;
  }
  &:active {
    background-color: #0574e4;
  }
  &:disabled {
    background-color: #d1d1d1;
    box-shadow: none;
  }
`;
  const DeleteLink = styled__default["default"].button`
  text-align: center;
  border: 1px solid var(--tina-color-grey-2);
  border-radius: var(--tina-radius-big);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  background-color: white;
  color: #0084ff;
  font-weight: var(--tina-font-weight-regular);
  cursor: pointer;
  transition: all 85ms ease-out;
  font-size: var(--tina-font-size-0);
  padding: 8px 20px;
  margin-left: 8px;
  &:hover {
    background-color: #f6f6f9;
    opacity: 1;
  }
  &:active {
    background-color: #0574e4;
  }
`;
  const width = 240;
  const LinkForm = () => {
    const { editorView } = useEditorStateContext();
    const [position, setPosition] = React.useState(void 0);
    if (!editorView)
      return null;
    const { view } = editorView;
    const linkPluginState = linkPluginKey.getState(view.state);
    const { anchor, head } = view.state.selection;
    const selState = anchor < head ? anchor : head;
    const node = view.state.selection.empty ? view.domAtPos(selState).node : view.domAtPos(selState + 1).node;
    const clickTarget = node.parentNode;
    const onChange = (attrs2) => {
      updateLinkBeingEdited(view.state, view.dispatch, attrs2);
      view.focus();
    };
    const onCancel = () => {
      unmountLinkForm(view);
      view.focus();
    };
    const wrapperRef = React.createRef();
    React.useEffect(() => {
      if (!clickTarget || !wrapperRef.current) {
        setPosition(void 0);
        return;
      }
      const left2 = calcLeftOffset(clickTarget, wrapperRef.current, width);
      const top2 = `calc(32px + ${findElementOffsetTop(clickTarget) - findElementOffsetTop(wrapperRef.current)}px)`;
      const arrowOffset2 = calcArrowLeftOffset(clickTarget, wrapperRef.current);
      setPosition({ arrowOffset: arrowOffset2, left: left2, top: top2 });
    }, [linkPluginState]);
    if (!linkPluginState.show_link_toolbar) {
      return null;
    }
    const { arrowOffset, left, top } = position || {};
    const { state, dispatch } = view;
    let href = "";
    const linkMark = getMarkPresent(state, state.schema.marks.link);
    if (linkMark) {
      href = linkMark.attrs.href;
    }
    return /* @__PURE__ */ React__namespace.createElement("div", {
      ref: wrapperRef,
      style: { position: "absolute" }
    }, position && /* @__PURE__ */ React__namespace.createElement(LinkFormWrapper, null, /* @__PURE__ */ React__namespace.createElement(LinkArrow, {
      offset: arrowOffset,
      top
    }), /* @__PURE__ */ React__namespace.createElement(InnerForm, {
      style: {
        left,
        top,
        width: `${width}px`
      },
      removeLink: () => removeLinkBeingEdited(state, dispatch),
      onChange,
      href,
      cancel: onCancel
    })));
  };
  const LinkFormWrapper = styled__default["default"].div`
  position: relative;
`;
  const LinkArrow = styled__default["default"].div`
  position: absolute;
  top: ${(p) => p.top};
  left: ${(p) => p.offset};
  margin-top: 3px;
  transform: translate3d(-50%, -100%, 0);
  width: 16px;
  height: 13px;
  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
  background-color: #f6f6f9;
  z-index: 100;
`;
  function calcLeftOffset(clickTarget, renderTarget, minWidth) {
    const ow_ct = clickTarget.offsetWidth;
    const ol_ct = findElementOffsetLeft(clickTarget);
    const ow_rt = renderTarget.parentElement.offsetWidth;
    const ol_rt = findElementOffsetLeft(renderTarget);
    const ol = ol_ct - ol_rt + ow_ct / 2 - minWidth / 2;
    const leftEdgeOutsideView = ol < -ol_rt;
    if (leftEdgeOutsideView) {
      return `-8px`;
    }
    const rightEdgeOutsideView = ol + minWidth > ow_rt;
    if (rightEdgeOutsideView) {
      return `calc(${ol - (ol + minWidth - ow_rt)}px + 8px)`;
    }
    return `${ol}px`;
  }
  function calcArrowLeftOffset(clickTarget, renderTarget, _minWidth) {
    const ow_ct = clickTarget.offsetWidth;
    const ol_ct = findElementOffsetLeft(clickTarget);
    const ol_rt = findElementOffsetLeft(renderTarget);
    const ol = ol_ct - ol_rt + ow_ct / 2;
    return `${ol}px`;
  }
  const MenuPlaceholder = styled__default["default"].div`
  color: transparent;
  background: transparent;
  pointer-events: none;
  position: relative;
  display: block;
  height: ${(props) => props.menuBoundingBox.height}px;
  width: ${(props) => props.menuBoundingBox.width}px;
`;
  const MenuWrapper = styled__default["default"].div`
  position: relative;
  margin-bottom: 14px;
  z-index: var(--tina-z-index-1);

  ${(props) => props.menuFixed && styled.css`
      position: fixed;
      width: ${props.menuBoundingBox.width}px;
      top: ${props.menuFixedTopOffset};
    `};
`;
  const MenuContainer = styled__default["default"].div`
  display: flex;
  flex-direction: row;
  justify-content: flex-start;
  flex-wrap: wrap;
  justify-content: space-between;
  position: relative;
  top: 0;
  width: 100%;
  background-color: white;
  border-radius: var(--tina-radius-small);
  box-shadow: 0px 2px 3px rgba(0, 0, 0, 0.12);
  border: 1px solid var(--tina-color-grey-2);
  overflow: hidden;
  z-index: var(--tina-z-index-0);
`;
  const BaseMenubar = ({
    sticky = true,
    menus,
    plugins,
    popups
  }) => {
    const [menuFixed, setMenuFixed] = React.useState(false);
    const isBrowser = typeof window !== `undefined`;
    const menuRef = React.useRef(null);
    const [menuBoundingBox, setMenuBoundingBox] = React.useState(null);
    const [menuOffsetTop, setMenuOffsetTop] = React.useState(null);
    const stickyOffset = typeof sticky === "string" ? sticky : "0";
    const scrollY = React.useRef(0);
    const scrollAnimationRef = React.useRef(0);
    const { editorView } = useEditorStateContext();
    const { mode } = useEditorModeContext();
    React.useEffect(() => {
      if (menuRef.current && sticky) {
        setMenuBoundingBox(menuRef.current.getBoundingClientRect());
      }
    }, [menuRef, editorView, mode]);
    React.useEffect(() => {
      if (!isBrowser || !menuRef.current || !sticky) {
        return;
      }
      const wysiwygWrapper = menuRef.current.parentElement;
      let ticking = false;
      const handleStickyMenu = () => {
        if (typeof menuOffsetTop === "number") {
          const btmBound = menuOffsetTop + ((wysiwygWrapper == null ? void 0 : wysiwygWrapper.offsetHeight) || 0);
          if (scrollY.current > menuOffsetTop && scrollY.current < btmBound) {
            setMenuFixed(true);
          } else {
            setMenuFixed(false);
          }
        }
        scrollAnimationRef.current = window.requestAnimationFrame(handleStickyMenu);
      };
      const handleResize = () => {
        if (menuRef.current) {
          const wasMenuFixed = menuFixed;
          setMenuFixed(false);
          setMenuBoundingBox(menuRef.current.getBoundingClientRect());
          setMenuFixed(wasMenuFixed);
        }
      };
      const handleScrollStart = debounce__default["default"](() => {
        scrollY.current = window.scrollY;
        requestTick();
      }, 10, { leading: true, trailing: false });
      const handleScrollStop = debounce__default["default"](() => {
        cancelAnimationFrame(scrollAnimationRef.current);
        ticking = false;
      }, 10);
      function requestTick() {
        if (!ticking) {
          scrollAnimationRef.current = window.requestAnimationFrame(handleStickyMenu);
        }
        ticking = true;
      }
      function calculateOffset() {
        if (wysiwygWrapper) {
          const stickyOffsetInt = parseInt(stickyOffset, 10);
          const offsetTop = findElementOffsetTop(wysiwygWrapper) - stickyOffsetInt;
          setMenuOffsetTop(offsetTop);
        }
      }
      document.readyState !== "complete" ? window.addEventListener("load", calculateOffset) : setTimeout(calculateOffset, 10);
      window.addEventListener("scroll", handleScrollStart);
      window.addEventListener("scroll", handleScrollStop);
      window.addEventListener("resize", handleResize);
      return () => {
        window.removeEventListener("scroll", handleScrollStart);
        window.removeEventListener("scroll", handleScrollStop);
        window.removeEventListener("resize", handleResize);
        cancelAnimationFrame(scrollAnimationRef.current);
      };
    }, [menuRef, menuBoundingBox, menuOffsetTop]);
    const preventProsemirrorFocusLoss = React__default["default"].useCallback((e) => {
      e.stopPropagation();
      e.preventDefault();
    }, []);
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, menuFixed && /* @__PURE__ */ React__default["default"].createElement(MenuPlaceholder, {
      menuBoundingBox
    }), /* @__PURE__ */ React__default["default"].createElement(MenuWrapper, {
      menuFixedTopOffset: stickyOffset,
      menuFixed,
      menuBoundingBox,
      ref: menuRef,
      "data-testid": "base-menubar"
    }, /* @__PURE__ */ React__default["default"].createElement(MenuPortalProvider, null, /* @__PURE__ */ React__default["default"].createElement(MenuContainer, {
      onMouseDown: preventProsemirrorFocusLoss
    }, menus, plugins == null ? void 0 : plugins.map(({ name, MenuItem }) => /* @__PURE__ */ React__default["default"].createElement(MenuItem, {
      key: name,
      mode,
      editorView
    }))))), popups);
  };
  const Menubar$1 = (_d) => {
    var _e = _d, { plugins, uploadImages } = _e, rest = __objRest(_e, ["plugins", "uploadImages"]);
    return /* @__PURE__ */ React__default["default"].createElement(BaseMenubar, __spreadProps(__spreadValues({}, rest), {
      menus: [
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$8, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$5, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$1, {
          uploadImages
        }),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$2, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$3, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$7, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$4, null),
        /* @__PURE__ */ React__default["default"].createElement(MarkdownMenu$6, null)
      ],
      plugins
    }));
  };
  const inputLineHeight = 20;
  const MarkdownEditor = ({
    imageProps,
    onChange,
    value,
    plugins,
    sticky
  }) => {
    const inputRef = React.useRef(null);
    const [val, setVal] = React.useState(value);
    const { browserFocused } = useBrowserFocusContext();
    React.useEffect(() => {
      const inputElm = inputRef.current;
      if (!inputElm)
        return;
      inputElm.focus({ preventScroll: true });
      inputElm.setSelectionRange(inputElm.value.length, inputElm.value.length);
    }, []);
    React.useEffect(() => {
      const inputElm = inputRef.current;
      if (!inputElm)
        return;
      inputElm.style.height = "0";
      inputElm.style.height = inputElm.scrollHeight + inputLineHeight + "px";
    });
    React.useEffect(() => {
      const editorElementFocused = inputRef.current === document.activeElement;
      if (browserFocused && editorElementFocused)
        return;
      setVal(value);
    }, [value]);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(Menubar$1, {
      sticky,
      uploadImages: imageProps == null ? void 0 : imageProps.upload,
      plugins
    }), /* @__PURE__ */ React__namespace.createElement("textarea", {
      "data-testid": "markdown-editing-textarea",
      ref: inputRef,
      value: val,
      onChange: (evt) => {
        const v = evt.target.value;
        setVal(v);
        onChange(v);
      },
      onFocus: (e) => {
        e.preventDefault();
        e.target.focus({ preventScroll: true });
      },
      className: "w-full shadow-inner focus:shadow-outline focus:border-blue-500 block bg-white border border-gray-200 text-gray-600 focus:text-gray-900 rounded-md p-5 mb-5",
      style: { minHeight: "100px" }
    }));
  };
  const code = {
    parseDOM: [{ tag: "code" }],
    toDOM() {
      return ["code"];
    },
    excludes: "em strong strike"
  };
  const em = {
    parseDOM: [
      { tag: "i" },
      { tag: "em" },
      {
        style: "font-style",
        getAttrs: (value) => value === "italic" && null
      }
    ],
    toDOM() {
      return ["em"];
    },
    excludes: "code"
  };
  const link$1 = {
    attrs: {
      href: {},
      title: { default: null }
    },
    inclusive: false,
    parseDOM: [
      {
        tag: "a[href]",
        getAttrs(dom) {
          return {
            href: dom.getAttribute("href"),
            title: dom.getAttribute("title")
          };
        }
      }
    ],
    toDOM(node) {
      return ["a", node.attrs];
    },
    toDocument(node) {
      return ["a", node.attrs];
    }
  };
  const strike = {
    parseDOM: [
      { tag: "strike" },
      { tag: "s" },
      { tag: "del" },
      {
        style: "text-decoration",
        getAttrs: (value) => value === "line-through" && null
      }
    ],
    toDOM: () => ["s", 0],
    excludes: "code"
  };
  const strong = {
    parseDOM: [
      { tag: "strong" },
      {
        tag: "b",
        getAttrs: (node) => {
          return node.style.fontWeight != "normal" && null;
        }
      },
      {
        style: "font-weight",
        getAttrs: (value) => {
          return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
        }
      }
    ],
    toDOM() {
      return ["strong"];
    },
    excludes: "code"
  };
  const doc = {
    content: "block+"
  };
  const blockquote = {
    content: "block+",
    group: "block",
    defining: true,
    parseDOM: [{ tag: "blockquote" }],
    toDOM() {
      return ["blockquote", 0];
    }
  };
  const bullet_list = {
    content: "list_item+",
    group: "block",
    attrs: { tight: { default: false } },
    parseDOM: [
      {
        tag: "ul",
        getAttrs: (dom) => ({ tight: dom.hasAttribute("data-tight") })
      }
    ],
    toDOM(node) {
      return ["ul", { "data-tight": node.attrs.tight ? "true" : null }, 0];
    }
  };
  const code_block = {
    content: "text*",
    attrs: { params: { default: "" } },
    group: "block",
    code: true,
    defining: true,
    parseDOM: [
      {
        tag: "pre",
        preserveWhitespace: "full",
        getAttrs: (dom) => ({
          params: dom.getAttribute("data-params")
        })
      }
    ],
    toDOM(node) {
      return ["pre", { "data-params": node.attrs.params }, ["code", 0]];
    }
  };
  const hard_break = {
    inline: true,
    group: "inline",
    selectable: false,
    parseDOM: [{ tag: "br" }],
    toDOM() {
      return ["br"];
    }
  };
  function domAttrs(attrs2) {
    const domAttrs2 = {};
    for (const key in attrs2) {
      if (attrs2[key]) {
        domAttrs2[`forestry-${key}`] = attrs2[key];
      }
    }
    return domAttrs2;
  }
  function docAttrs(attrs2) {
    const domAttrs2 = {};
    for (const key in attrs2) {
      if (attrs2[key]) {
        domAttrs2[key] = attrs2[key];
      }
    }
    return domAttrs2;
  }
  function getAttrsWith(attrs2) {
    return function(dom) {
      return __spreadValues(__spreadValues({}, attrs2), getAttrs(dom));
    };
  }
  function getAttrs(dom) {
    const attrs2 = {};
    const attributes = dom.attributes;
    for (let i = 0; i < attributes.length; i++) {
      const attribute = attributes[i];
      if (attribute.value) {
        const name = attribute.name.startsWith("forestry-") ? attribute.name.slice(9) : attribute.name;
        attrs2[name] = attribute.value;
      }
    }
    return attrs2;
  }
  const heading = {
    attrs: {
      level: { default: 1 },
      class: { default: "" },
      id: { default: "" }
    },
    content: "inline*",
    marks: "_",
    group: "block",
    defining: true,
    parseDOM: [
      { tag: "h1", getAttrs: getAttrsWith({ level: 1 }) },
      { tag: "h2", getAttrs: getAttrsWith({ level: 2 }) },
      { tag: "h3", getAttrs: getAttrsWith({ level: 3 }) },
      { tag: "h4", getAttrs: getAttrsWith({ level: 4 }) },
      { tag: "h5", getAttrs: getAttrsWith({ level: 5 }) },
      { tag: "h6", getAttrs: getAttrsWith({ level: 6 }) }
    ],
    toDocument(node) {
      const _a = node.attrs, { level } = _a, other = __objRest(_a, ["level"]);
      return ["h" + level, docAttrs(other), 0];
    },
    toDOM(node) {
      const _a = node.attrs, { level } = _a, other = __objRest(_a, ["level"]);
      return ["h" + level, domAttrs(other), 0];
    }
  };
  const horizontal_rule = {
    group: "block",
    allowGapCursor: true,
    parseDOM: [{ tag: "hr" }],
    toDOM() {
      return ["hr"];
    }
  };
  const image = {
    inline: true,
    attrs: {
      src: {},
      align: { default: null },
      alt: { default: null },
      title: { default: null },
      width: { default: null },
      height: { default: null }
    },
    group: "inline",
    draggable: true,
    allowGapCursor: true,
    parseDOM: [
      {
        tag: "img[src]",
        getAttrs(dom) {
          return {
            src: dom.getAttribute("src"),
            title: dom.getAttribute("title"),
            alt: dom.getAttribute("alt"),
            align: getAlignFromDOM(dom),
            width: dom.getAttribute("width"),
            height: dom.getAttribute("height")
          };
        }
      }
    ],
    toDOM(node) {
      const attrs2 = {
        src: node.attrs.src
      };
      if (node.attrs.title)
        attrs2.title = node.attrs.title;
      if (node.attrs.alt)
        attrs2.alt = node.attrs.alt;
      if (node.attrs.width)
        attrs2.width = node.attrs.width;
      if (node.attrs.height)
        attrs2.height = node.attrs.height;
      if (node.attrs.align)
        attrs2["class"] = `align-${node.attrs.align}`;
      return ["img", attrs2];
    }
  };
  const alignRegex = /align-([a-z]*)/;
  function getAlignFromDOM(image2) {
    const className = image2.getAttribute("class") || "";
    const match = alignRegex.exec(className);
    if (match && match.length > 1) {
      return match[1];
    }
    return null;
  }
  const list_item = {
    content: "paragraph block*",
    defining: true,
    parseDOM: [{ tag: "li" }],
    toDOM() {
      return ["li", 0];
    }
  };
  const ordered_list = {
    content: "list_item+",
    group: "block",
    attrs: { order: { default: 1 }, tight: { default: false } },
    parseDOM: [
      {
        tag: "ol",
        getAttrs(dom) {
          return {
            order: dom.hasAttribute("start") ? +(dom.getAttribute("start") || 0) : 1,
            tight: dom.hasAttribute("data-tight")
          };
        }
      }
    ],
    toDOM(node) {
      return [
        "ol",
        {
          start: node.attrs.order == 1 ? null : node.attrs.order,
          "data-tight": node.attrs.tight ? "true" : null
        },
        0
      ];
    }
  };
  const paragraph = {
    content: "inline*",
    marks: "_",
    attrs: {
      class: { default: "" },
      id: { default: "" }
    },
    group: "block",
    parseDOM: [{ tag: "p", getAttrs }],
    toDocument(node) {
      return ["p", docAttrs(node.attrs), 0];
    },
    toDOM(node) {
      return ["p", domAttrs(node.attrs), 0];
    }
  };
  const text = {
    group: "inline"
  };
  const tables = TableCommands.tableNodes({
    tableGroup: "block",
    cellContent: "inline*",
    cellAttributes: {}
  });
  tables.table_cell = __spreadProps(__spreadValues({}, tables.table_cell), {
    marks: "_",
    attrs: __spreadProps(__spreadValues({}, tables.table_cell.attrs), { align: { default: null } }),
    toDOM(node) {
      const attrs2 = {};
      if (node.attrs.align) {
        attrs2.style = `text-align: ${node.attrs.align};`;
      }
      return ["td", attrs2, 0];
    }
  });
  tables.table_header = __spreadProps(__spreadValues({}, tables.table_header), {
    marks: "_",
    attrs: __spreadProps(__spreadValues({}, tables.table_header.attrs), { align: { default: null } }),
    toDOM(node) {
      const attrs2 = {};
      if (node.attrs.align) {
        attrs2.style = `text-align: ${node.attrs.align};`;
      }
      return ["th", attrs2, 0];
    }
  });
  const marks = { code, em, link: link$1, strike, strong };
  const nodes = __spreadValues({
    doc,
    paragraph,
    blockquote,
    bullet_list,
    code_block,
    hard_break,
    heading,
    horizontal_rule,
    image,
    list_item,
    ordered_list,
    text
  }, tables);
  const buildSchema = () => {
    return new prosemirrorModel.Schema({
      nodes,
      marks
    });
  };
  class TranslatorClass {
  }
  class MarkdownSerializer {
    constructor(nodes2, marks2) {
      this.nodes = nodes2;
      this.marks = marks2;
    }
    serialize(content, options = {}) {
      const state = new MarkdownSerializerState(this.nodes, this.marks, options);
      state.renderContent(content);
      return state.out;
    }
  }
  class MarkdownSerializerState {
    constructor(nodes2, marks2, options) {
      this.nodes = nodes2;
      this.marks = marks2;
      this.delim = this.out = "";
      this.closed = false;
      this.inTightList = false;
      this.options = options || {};
      if (typeof this.options.tightLists == "undefined")
        this.options.tightLists = false;
    }
    flushClose(size) {
      if (this.closed) {
        if (!this.atBlank())
          this.out += "\n";
        if (size == null)
          size = 2;
        if (size > 1) {
          let delimMin = this.delim;
          const trim = /\s+$/.exec(delimMin);
          if (trim)
            delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
          for (let i = 1; i < size; i++)
            this.out += delimMin + "\n";
        }
        this.closed = false;
      }
    }
    wrapBlock(delim, firstDelim, node, f) {
      const old = this.delim;
      this.write(firstDelim || delim);
      this.delim += delim;
      f();
      this.delim = old;
      this.closeBlock(node);
    }
    atBlank() {
      return /(^|\n)$/.test(this.out);
    }
    ensureNewLine() {
      if (!this.atBlank())
        this.out += "\n";
    }
    write(content) {
      this.flushClose();
      if (this.delim && this.atBlank())
        this.out += this.delim;
      if (content)
        this.out += content;
    }
    closeBlock(node) {
      this.closed = node;
    }
    text(text2, escape, escFn) {
      const lines = text2.split("\n");
      for (let i = 0; i < lines.length; i++) {
        const startOfLine = this.atBlank() || this.closed;
        this.write();
        let escapedString = escape !== false ? this.esc(lines[i], startOfLine) : lines[i];
        escapedString = escFn ? escFn(escapedString) : escapedString;
        this.out += escapedString;
        if (i != lines.length - 1)
          this.out += "\n";
      }
    }
    render(node, parent, index, escFn) {
      if (typeof parent == "number")
        throw new Error("!");
      this.nodes[node.type.name](this, node, parent, index, escFn);
    }
    renderContent(parent) {
      parent.forEach((node, _, i) => this.render(node, parent, i));
    }
    renderInline(parent, escFn) {
      const active = [];
      let trailing = "";
      const progress = (node, _, index = 0) => {
        let marks2 = node ? node.marks : [];
        const indexOfCode = marks2.findIndex((p) => p.type.name === "code");
        if (indexOfCode >= 0 && marks2.length > 1) {
          marks2 = [
            ...marks2.slice(0, indexOfCode),
            ...marks2.slice(indexOfCode + 1, marks2.length),
            marks2[indexOfCode]
          ];
        }
        let leading = trailing;
        trailing = "";
        if (node && node.isText && marks2.some((mark, _i, _a) => {
          const info = this.marks[mark.type.name];
          return !!(info && info.expelEnclosingWhitespace);
        }) && /^(\s*)(.*?)(\s*)$/.test(node.text || "")) {
          const [, lead, inner2, trail] = Array.from(/^(\s*)(.*?)(\s*)$/.exec(node.text || "") || []);
          leading += lead;
          trailing = trail;
          if (lead || trail) {
            node = inner2 ? node.withText(inner2) : null;
            if (!node)
              marks2 = active;
          }
        }
        const inner = marks2.length && marks2[marks2.length - 1];
        const noEsc = inner && this.marks[inner.type.name].escape === false;
        const len = marks2.length - (noEsc ? 1 : 0);
        outer:
          for (let i = 0; i < len; i++) {
            const mark = marks2[i];
            if (!this.marks[mark.type.name].mixable)
              break;
            for (let j = 0; j < active.length; j++) {
              const other = active[j];
              if (!this.marks[other.type.name].mixable)
                break;
              if (mark.eq(other)) {
                if (i > j)
                  marks2 = marks2.slice(0, j).concat(mark).concat(marks2.slice(j, i)).concat(marks2.slice(i + 1, len));
                else if (j > i)
                  marks2 = marks2.slice(0, i).concat(marks2.slice(i + 1, j)).concat(mark).concat(marks2.slice(j, len));
                continue outer;
              }
            }
          }
        let keep = 0;
        while (keep < Math.min(active.length, len) && marks2[keep].eq(active[keep]))
          ++keep;
        while (keep < active.length)
          this.text(this.markString(active.pop(), false, node), false);
        if (leading)
          this.text(leading);
        if (node) {
          while (active.length < len) {
            const add = marks2[active.length];
            active.push(add);
            this.text(this.markString(add, true, node), false);
          }
          if (noEsc && node.isText && inner)
            this.text(this.markString(inner, false, node) + node.text + this.markString(inner, true, node), false, escFn);
          else
            this.render(node, parent, index, escFn);
        }
      };
      parent.forEach(progress);
      progress(null);
    }
    renderList(node, delim, firstDelim) {
      if (this.closed && this.closed.type == node.type)
        this.flushClose(3);
      else if (this.inTightList)
        this.flushClose(1);
      const isTight = this.options.tightLists;
      const prevTight = this.inTightList;
      this.inTightList = !!isTight;
      node.forEach((child, _, i) => {
        if (i && isTight)
          this.flushClose(1);
        this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));
      });
      this.inTightList = prevTight;
    }
    esc(str, startOfLine) {
      str = str.replace(/[`\\~\[\]]/g, "\\$&");
      if (startOfLine)
        str = str.replace(/^[#\-*+]/, "\\$&").replace(/^(\d+)\./, "$1\\.");
      return str;
    }
    quote(str) {
      const wrap = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()";
      return wrap[0] + str + wrap[1];
    }
    repeat(str, n) {
      let out = "";
      for (let i = 0; i < n; i++)
        out += str;
      return out;
    }
    markString(mark, open, node) {
      const info = this.marks[mark.type.name];
      const value = open ? info.open : info.close;
      return typeof value == "string" ? value : value(this, mark, node);
    }
    getEnclosingWhitespace(text2) {
      return {
        leading: (text2.match(/^(\s+)/) || [])[0],
        trailing: (text2.match(/(\s+)$/) || [])[0]
      };
    }
  }
  const get = require("lodash.get");
  const ALIGN_STYLES = {
    ["text-align:left"]: "left",
    ["text-align:center"]: "center",
    ["text-align:right"]: "right"
  };
  const ALIGN_DASHES = {
    left: ":---",
    center: ":---:",
    right: "---:"
  };
  const TOKENS = {
    blockquote: { block: "blockquote" },
    paragraph: { block: "paragraph" },
    list_item: { block: "list_item" },
    bullet_list: { block: "bullet_list" },
    ordered_list: {
      block: "ordered_list",
      getAttrs: (tok) => ({ order: +tok.attrGet("order") || 1 })
    },
    heading: {
      block: "heading",
      getAttrs: (tok) => ({ level: +tok.tag.slice(1) })
    },
    code_block: { block: "code_block" },
    fence: {
      block: "code_block",
      getAttrs: (tok) => ({ params: tok.info || "" })
    },
    hr: { node: "horizontal_rule" },
    image: {
      node: "image",
      getAttrs: (tok) => ({
        src: tok.attrGet("src"),
        title: tok.attrGet("title") || null,
        alt: tok.children[0] && tok.children[0].content || null,
        width: tok.attrGet("width") || null,
        height: tok.attrGet("height") || null
      })
    },
    table: {
      block: "table"
    },
    table_row: { block: "table_row" },
    table_cell: {
      block: "table_cell",
      getAttrs(tok) {
        let style = "";
        if (tok.attrs) {
          for (let i = 0; i < tok.attrs.length; i++) {
            if (tok.attrs[i][0] === "style") {
              style = tok.attrs[i][1];
            }
          }
        }
        return { align: ALIGN_STYLES[style] };
      }
    },
    table_header: {
      block: "table_header",
      getAttrs(tok) {
        let style = "";
        if (tok.attrs) {
          for (let i = 0; i < tok.attrs.length; i++) {
            if (tok.attrs[i][0] === "style") {
              style = tok.attrs[i][1];
            }
          }
        }
        return { align: ALIGN_STYLES[style] };
      }
    },
    hardbreak: { node: "hard_break" },
    em: { mark: "em" },
    strike: { mark: "strike" },
    strong: { mark: "strong" },
    link: {
      mark: "link",
      getAttrs: (tok) => ({
        href: tok.attrGet("href"),
        title: tok.attrGet("title") || null
      })
    },
    code_inline: { mark: "code" }
  };
  const NODES = {
    blockquote(state, node) {
      state.wrapBlock("> ", null, node, () => state.renderContent(node));
    },
    code_block(state, node) {
      if (!node.attrs.params) {
        state.wrapBlock("    ", null, node, () => state.text(node.textContent, false));
      } else {
        state.write("```" + node.attrs.params + "\n");
        state.text(node.textContent, false);
        state.ensureNewLine();
        state.write("```");
        state.closeBlock(node);
      }
    },
    heading(state, node) {
      if (/\n/.test(node.textContent) && node.attrs.level < 3) {
        state.renderInline(node);
        state.write("\n");
        state.write(node.attrs.level === 1 ? "=" : "-");
      } else {
        state.write(state.repeat("#", node.attrs.level) + " ");
        state.renderInline(node);
      }
      state.closeBlock(node);
    },
    horizontal_rule(state, node) {
      state.write(node.attrs.markup || "***");
      state.closeBlock(node);
    },
    bullet_list(state, node) {
      state.renderList(node, "  ", () => (node.attrs.bullet || "*") + " ");
    },
    ordered_list(state, node) {
      const start = node.attrs.order || 1;
      const maxW = String(start + node.childCount - 1).length;
      const space = state.repeat(" ", maxW + 2);
      state.renderList(node, space, (i) => {
        const nStr = String(start + i);
        return state.repeat(" ", maxW - nStr.length) + nStr + ". ";
      });
    },
    list_item(state, node) {
      state.renderContent(node);
    },
    paragraph(state, node, _parent, _index) {
      state.renderInline(node);
      state.closeBlock(node);
    },
    image(state, node) {
      let size = "";
      if (node.attrs.height || node.attrs.width) {
        size = ` =${node.attrs.width || ""}x${node.attrs.height || ""}`;
      }
      const alt = state.esc(node.attrs.alt || "");
      const src = state.esc(node.attrs.src);
      const title = node.attrs.title ? " " + state.quote(node.attrs.title) : "";
      state.write(`![${alt}](${src}${title}${size})`);
    },
    hard_break(state, node, parent, index) {
      if (!parent || typeof index !== "number")
        return;
      for (let i = index + 1; i < parent.childCount; i++)
        if (parent.child(i).type != node.type) {
          state.write("  \n");
          return;
        }
    },
    text(state, node, _1, _2, escFn) {
      if (typeof node.text !== "string")
        return;
      state.text(node.text, true, escFn);
    },
    table(state, node) {
      let inHead = true;
      node.forEach((row) => {
        const nextRowIsInBody = row.content.child(0).type.name === "table_cell";
        if (inHead && nextRowIsInBody) {
          state.write("|");
          for (let i = 0; i < row.childCount; i++) {
            const align = row.content.child(i).attrs.align;
            const dash = ALIGN_DASHES[align] || "---";
            state.write(` ${dash} |`);
          }
          state.write("\n");
          inHead = false;
        }
        NODES.table_row(state, row);
      });
      state.closeBlock(node);
    },
    table_row(state, node) {
      state.write("|");
      state.renderContent(node);
      state.write("\n");
    },
    table_cell(state, node) {
      state.write(" ");
      state.renderInline(node, (str) => str.replace(/[\|]/g, "\\$&"));
      state.write(" |");
    },
    table_header(state, node) {
      NODES.table_cell(state, node);
    }
  };
  const MARKS = {
    em: {
      open: "_",
      close: "_",
      mixable: true,
      expelEnclosingWhitespace: true
    },
    strong: {
      open(_state, mark, node) {
        if (get(node, "text", "").endsWith("*"))
          return mark.openedWith = "__";
        return "**";
      },
      close(_state, mark, node) {
        if (mark.openedWith) {
          const closeWith = mark.openedWith;
          mark.openedWith = null;
          return closeWith;
        }
        if (get(node, "text", "").endsWith("*"))
          return "__";
        return "**";
      },
      mixable: true,
      expelEnclosingWhitespace: true
    },
    link: {
      open: "[",
      close(state, mark) {
        return "](" + state.esc(mark.attrs.href) + (mark.attrs.title ? " " + state.quote(mark.attrs.title) : "") + ")";
      }
    },
    strike: {
      open: "~~",
      close: "~~",
      mixable: true,
      expelEnclosingWhitespace: true
    },
    code: { open: "`", close: "`", escape: false }
  };
  function buildTokensForSchema(schema) {
    const tokens = {};
    if (schema.nodes.blockquote)
      tokens.blockquote = TOKENS.blockquote;
    if (schema.nodes.paragraph)
      tokens.paragraph = TOKENS.paragraph;
    if (schema.nodes.list_item)
      tokens.list_item = TOKENS.list_item;
    if (schema.nodes.bullet_list)
      tokens.bullet_list = TOKENS.bullet_list;
    if (schema.nodes.ordered_list)
      tokens.ordered_list = TOKENS.ordered_list;
    if (schema.nodes.heading)
      tokens.heading = TOKENS.heading;
    if (schema.nodes.code_block) {
      tokens.code_block = TOKENS.code_block;
      tokens.fence = TOKENS.fence;
    }
    if (schema.nodes.horizontal_rule)
      tokens.hr = TOKENS.hr;
    if (schema.nodes.image)
      tokens.image = TOKENS.image;
    if (schema.nodes.hard_break)
      tokens.hardbreak = TOKENS.hardbreak;
    if (schema.nodes.ordered_list)
      tokens.ordered_list = TOKENS.ordered_list;
    if (schema.nodes.bullet_list)
      tokens.bullet_list = TOKENS.bullet_list;
    if (schema.nodes.list_item)
      tokens.list_item = TOKENS.list_item;
    if (schema.nodes.table) {
      tokens.table = TOKENS.table;
      tokens.thead = { ignore: true };
      tokens.th = TOKENS.table_header;
      tokens.tbody = { ignore: true };
      tokens.tr = TOKENS.table_row;
      tokens.td = TOKENS.table_cell;
    }
    if (schema.marks.em)
      tokens.em = TOKENS.em;
    if (schema.marks.strong)
      tokens.strong = TOKENS.strong;
    if (schema.marks.link)
      tokens.link = TOKENS.link;
    if (schema.marks.code)
      tokens.code_inline = TOKENS.code_inline;
    if (schema.marks.strike)
      tokens.strike = TOKENS.strike;
    return tokens;
  }
  function buildNodesFromSchema(schema) {
    const nodes2 = {};
    if (schema.nodes.blockquote)
      nodes2.blockquote = NODES.blockquote;
    if (schema.nodes.paragraph)
      nodes2.paragraph = NODES.paragraph;
    if (schema.nodes.list_item)
      nodes2.list_item = NODES.list_item;
    if (schema.nodes.bullet_list)
      nodes2.bullet_list = NODES.bullet_list;
    if (schema.nodes.ordered_list)
      nodes2.ordered_list = NODES.ordered_list;
    if (schema.nodes.heading)
      nodes2.heading = NODES.heading;
    if (schema.nodes.code_block)
      nodes2.code_block = NODES.code_block;
    if (schema.nodes.horizontal_rule)
      nodes2.horizontal_rule = NODES.horizontal_rule;
    if (schema.nodes.image)
      nodes2.image = NODES.image;
    if (schema.nodes.hard_break)
      nodes2.hard_break = NODES.hard_break;
    if (schema.nodes.ordered_list)
      nodes2.ordered_list = NODES.ordered_list;
    if (schema.nodes.bullet_list)
      nodes2.bullet_list = NODES.bullet_list;
    if (schema.nodes.list_item)
      nodes2.list_item = NODES.list_item;
    if (schema.nodes.table) {
      nodes2.table = NODES.table;
      nodes2.table_header = NODES.table_header;
      nodes2.table_row = NODES.table_row;
      nodes2.table_cell = NODES.table_cell;
    }
    nodes2.text = NODES.text;
    return nodes2;
  }
  function buildMarksFromSchema(schema) {
    if (schema.marks.em)
      ;
    if (schema.marks.strong)
      ;
    if (schema.marks.link)
      ;
    if (schema.marks.code)
      ;
    return MARKS;
  }
  function CommonMarkSerializer(schema) {
    return new MarkdownSerializer(buildNodesFromSchema(schema), buildMarksFromSchema(schema));
  }
  function parseNextNumber(str, pos, max) {
    let code2;
    const start = pos;
    const result = {
      ok: false,
      pos
    };
    code2 = str.charCodeAt(pos);
    while (pos < max && code2 >= 48 && code2 <= 57 || code2 === 37) {
      code2 = str.charCodeAt(++pos);
    }
    result.ok = true;
    result.pos = pos;
    result.value = Number(str.slice(start, pos));
    return result;
  }
  function parseImageSize(str, pos, max) {
    let code2;
    const result = {
      ok: false,
      pos: 0
    };
    if (pos >= max) {
      return result;
    }
    code2 = str.charCodeAt(pos);
    if (code2 !== 61) {
      return result;
    }
    pos++;
    code2 = str.charCodeAt(pos);
    if (code2 !== 120 && (code2 < 48 || code2 > 57)) {
      return result;
    }
    const resultW = parseNextNumber(str, pos, max);
    pos = resultW.pos;
    code2 = str.charCodeAt(pos);
    if (code2 !== 120) {
      return result;
    }
    pos++;
    const resultH = parseNextNumber(str, pos, max);
    pos = resultH.pos;
    result.width = resultW.value;
    result.height = resultH.value;
    result.pos = pos;
    result.ok = true;
    return result;
  }
  function parseLinkDestination(md, state, pos) {
    const isSpace = md.utils.isSpace;
    const unescapeAll = md.utils.unescapeAll;
    const str = state.src;
    const max = state.posMax;
    let code2;
    let level;
    const lines = 0;
    const start = pos;
    const result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === 10 || isSpace(code2)) {
          return result;
        }
        if (code2 === 62) {
          result.pos = pos + 1;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code2 === 92 && pos + 1 < max) {
          pos += 2;
          continue;
        }
        pos++;
      }
      return result;
    }
    level = 0;
    while (pos < max) {
      code2 = str.charCodeAt(pos);
      if (code2 == 61 || code2 == 34 || code2 == 39) {
        pos--;
        break;
      }
      if (code2 < 32 || code2 === 127) {
        break;
      }
      if (code2 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      if (code2 === 40) {
        level++;
      }
      if (code2 === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescapeAll(str.slice(start, pos));
    result.lines = lines;
    result.pos = pos;
    result.ok = true;
    return result;
  }
  function image_with_size(md) {
    return function(state, silent) {
      let attrs2, code2, label, pos, ref, res, title, width2 = null, height = null, token, tokens, start, href = "";
      const oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      const labelStart = state.pos + 2;
      const labelEnd = md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (code2 !== 32 && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = parseLinkDestination(md, state, pos);
        if (res.ok) {
          href = res.str;
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (code2 !== 32 && code2 !== 10) {
            break;
          }
        }
        res = md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (code2 !== 32 && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos - 1 >= 0) {
          code2 = state.src.charCodeAt(pos - 1);
          if (code2 === 32) {
            res = parseImageSize(state.src, pos, state.posMax);
            if (res.ok) {
              width2 = res.width;
              height = res.height;
              pos = res.pos;
              for (; pos < max; pos++) {
                code2 = state.src.charCodeAt(pos);
                if (code2 !== 32 && code2 !== 10) {
                  break;
                }
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (code2 !== 32 && code2 !== 10) {
            break;
          }
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[md.utils.normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        const newState = new state.md.inline.State(state.src.slice(labelStart, labelEnd), state.md, state.env, tokens = []);
        newState.md.inline.tokenize(newState);
        token = state.push("image", "img", 0);
        token.attrs = attrs2 = [
          ["src", href],
          ["alt", ""]
        ];
        token.children = tokens;
        if (title) {
          attrs2.push(["title", title]);
        }
        if (width2 !== null) {
          attrs2.push(["width", width2]);
        }
        if (height !== null) {
          attrs2.push(["height", height]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
  function imsize(md) {
    md.inline.ruler.before("emphasis", "image", image_with_size(md));
  }
  function _link(md) {
    return function(state, silent) {
      const normalizeReference = state.md.utils.normalizeReference;
      const isSpace = state.md.utils.isSpace;
      let attrs2, code2, label, pos, res, ref, title, token, href = "", start = state.pos, parseReference = true;
      const oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      const labelStart = state.pos + 1;
      const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = parseLinkDestination(md, state, pos);
        if (res.ok) {
          href = res.str;
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs2 = [["href", href]];
        if (title) {
          attrs2.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
  function link(md) {
    md.inline.ruler.before("emphasis", "link", _link(md));
  }
  const MarkMapping = {
    strike: "s"
  };
  function maybeMerge(a, b) {
    if (a.isText && b.isText && prosemirrorModel.Mark.sameSet(a.marks, b.marks))
      return a.copy(a.text + b.text);
  }
  class MarkdownParseState {
    constructor(schema, tokenHandlers2) {
      this.schema = schema;
      this.stack = [{ type: schema.topNodeType, content: [] }];
      this.marks = prosemirrorModel.Mark.none;
      this.tokenHandlers = tokenHandlers2;
    }
    top() {
      return this.stack[this.stack.length - 1];
    }
    push(elt) {
      if (this.stack.length)
        this.top().content.push(elt);
    }
    addText(text2) {
      if (!text2)
        return;
      const nodes2 = this.top().content, last = nodes2[nodes2.length - 1], node = this.schema.text(text2, this.marks);
      let merged;
      if (last && (merged = maybeMerge(last, node)))
        nodes2[nodes2.length - 1] = merged;
      else
        nodes2.push(node);
    }
    openMark(mark) {
      this.marks = mark.addToSet(this.marks);
    }
    closeMark(mark) {
      this.marks = mark.removeFromSet(this.marks);
    }
    parseTokens(toks) {
      for (let i = 0; i < toks.length; i++) {
        const tok = toks[i];
        const handler = this.tokenHandlers[tok.type];
        if (!handler)
          throw new Error("Token type `" + tok.type + "` not supported by Markdown parser");
        handler(this, tok);
      }
    }
    addNode(type, attrs2, content) {
      const node = type.createAndFill(attrs2, content, this.marks);
      if (!node)
        return null;
      this.push(node);
      return node;
    }
    openNode(type, attrs2) {
      this.stack.push({ type, attrs: attrs2, content: [] });
    }
    closeNode() {
      if (this.marks.length)
        this.marks = prosemirrorModel.Mark.none;
      const info = this.stack.pop();
      if (!info)
        return;
      return this.addNode(info.type, info.attrs, info.content);
    }
  }
  function attrs(spec, token) {
    if (spec.getAttrs)
      return spec.getAttrs(token);
    else if (spec.attrs instanceof Function)
      return spec.attrs(token);
    else
      return spec.attrs;
  }
  function noOpenClose(type) {
    return type == "code_inline" || type == "code_block" || type == "fence";
  }
  function withoutTrailingNewline(str) {
    return str[str.length - 1] == "\n" ? str.slice(0, str.length - 1) : str;
  }
  function noOp() {
  }
  function tokenHandlers(schema, tokens) {
    const handlers = Object.create(null);
    for (const type in tokens) {
      const spec = tokens[type];
      if (spec.block) {
        const nodeType = schema.nodeType(spec.block);
        if (noOpenClose(type)) {
          handlers[type] = (state, tok) => {
            state.openNode(nodeType, attrs(spec, tok));
            state.addText(withoutTrailingNewline(tok.content));
            state.closeNode();
          };
        } else {
          handlers[type + "_open"] = (state, tok) => state.openNode(nodeType, attrs(spec, tok));
          handlers[type + "_close"] = (state) => state.closeNode();
        }
      } else if (spec.node) {
        const nodeType = schema.nodeType(spec.node);
        handlers[type] = (state, tok) => state.addNode(nodeType, attrs(spec, tok));
      } else if (spec.mark) {
        const markType = schema.marks[spec.mark];
        if (noOpenClose(type)) {
          handlers[type] = (state, tok) => {
            state.openMark(markType.create(attrs(spec, tok)));
            state.addText(withoutTrailingNewline(tok.content));
            state.closeMark(markType);
          };
        } else {
          handlers[(MarkMapping[type] || type) + "_open"] = (state, tok) => state.openMark(markType.create(attrs(spec, tok)));
          handlers[(MarkMapping[type] || type) + "_close"] = (state) => state.closeMark(markType);
        }
      } else if (spec.ignore) {
        if (noOpenClose(type)) {
          handlers[type] = noOp;
        } else {
          handlers[type + "_open"] = noOp;
          handlers[type + "_close"] = noOp;
        }
      } else {
        throw new RangeError("Unrecognized parsing spec " + JSON.stringify(spec));
      }
    }
    handlers.text = (state, tok) => state.addText(tok.content);
    handlers.inline = (state, tok) => state.parseTokens(tok.children);
    handlers.softbreak = (state) => state.addText("\n");
    return handlers;
  }
  class MarkdownParser {
    constructor(schema, tokenizer, tokens) {
      this.tokens = tokens;
      this.schema = schema;
      this.tokenizer = tokenizer;
      this.tokenHandlers = tokenHandlers(schema, tokens);
    }
    parse(text2) {
      const state = new MarkdownParseState(this.schema, this.tokenHandlers);
      let doc2;
      state.parseTokens(this.tokenizer.parse(text2, {}));
      do {
        doc2 = state.closeNode();
      } while (state.stack.length);
      return doc2;
    }
  }
  const markdownit = require("markdown-it");
  function CommonMarkParser(schema) {
    const parser = markdownit({ html: false });
    parser.use(imsize);
    parser.use(link);
    return new MarkdownParser(schema, parser, buildTokensForSchema(schema));
  }
  class MarkdownTranslator extends TranslatorClass {
    constructor(schema) {
      super();
      this.parser = null;
      this.serializer = null;
      this.schema = schema;
    }
    static fromSchema(schema) {
      return MarkdownTranslator.commonMarkFromSchema(schema);
    }
    static commonMarkFromSchema(schema) {
      const translator = new MarkdownTranslator(schema);
      translator.parser = CommonMarkParser(schema);
      translator.serializer = CommonMarkSerializer(schema);
      return translator;
    }
    nodeFromString(value) {
      return this.parser.parse(value);
    }
    stringFromNode(node) {
      return this.serializer.serialize(node, {
        tightLists: true
      });
    }
  }
  class DOMSerializer extends prosemirrorModel.DOMSerializer {
    static nodesFromSchema(schema) {
      const result = gatherToDOM(schema.nodes);
      if (!result.text)
        result.text = (node) => node.text;
      return result;
    }
    static marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }
  function gatherToDOM(obj) {
    const result = {};
    for (const name in obj) {
      const toDocument = obj[name].spec.toDocument;
      const toDOM = obj[name].spec.toDOM;
      if (toDocument)
        result[name] = toDocument;
      else if (toDOM)
        result[name] = toDOM;
    }
    return result;
  }
  class DOMTranslator extends TranslatorClass {
    constructor(schema) {
      super();
      this.schema = schema;
      this.parser = prosemirrorModel.DOMParser.fromSchema(schema);
      this.serializer = DOMSerializer.fromSchema(schema);
    }
    static fromSchema(schema) {
      return new DOMTranslator(schema);
    }
    nodeFromString(value) {
      let al;
      try {
        al = window.document.createRange().createContextualFragment(value);
      } catch (e) {
        al = new DOMParser().parseFromString(value, "text/html");
      }
      return this.parser.parse(al);
    }
    stringFromNode(node) {
      const el = document.createElement("div");
      el.appendChild(this.serializer.serializeFragment(node.content));
      return el.innerHTML;
    }
  }
  const buildTranslator = (schema, format = "markdown") => {
    if (format === "html")
      return DOMTranslator.fromSchema(schema);
    return MarkdownTranslator.fromSchema(schema);
  };
  const commonPluginKey = new prosemirrorState.PluginKey("common");
  const commonPlugin = new prosemirrorState.Plugin({
    key: commonPluginKey,
    state: {
      init: () => {
        return { editorFocused: false };
      },
      apply(tr, prev) {
        if (tr.getMeta("editor_focused") === false) {
          return {
            editorFocused: false
          };
        }
        if (tr.getMeta("editor_focused")) {
          return {
            editorFocused: true
          };
        }
        return prev;
      }
    },
    props: {
      handleScrollToSelection() {
        return true;
      },
      handleDOMEvents: {
        focus(view) {
          const { state, dispatch } = view;
          dispatch(state.tr.setMeta("editor_focused", true));
          return false;
        },
        blur(view) {
          const { state, dispatch } = view;
          dispatch(state.tr.setMeta("editor_focused", false));
          return false;
        }
      }
    }
  });
  function byType(__type) {
    return (plugin) => plugin.__type === __type;
  }
  function findPlugins(type, plugins) {
    return plugins.filter(byType(type));
  }
  function liftBlockquote(state, dispatch) {
    const range = getRangeForType(state, state.schema.nodes.blockquote);
    if (!range)
      return false;
    const target = prosemirrorTransform.liftTarget(range);
    if (!target)
      return false;
    if (dispatch) {
      dispatch(state.tr.lift(range, target));
    }
    return true;
  }
  const getRangeForType = (state, listType) => {
    const { $from, $to } = state.selection;
    const range = $from.blockRange($to, (node) => {
      return node.type == listType;
    });
    return range;
  };
  function insertHr(state, dispatch) {
    const type = state.schema.nodes.horizontal_rule;
    if (dispatch) {
      dispatch(state.tr.replaceSelectionWith(type.create()).scrollIntoView());
    }
    return true;
  }
  const hardBreakCmd = (schema) => {
    const br = schema.nodes.hard_break;
    return prosemirrorCommands.chainCommands(prosemirrorCommands.exitCode, (state, dispatch) => {
      dispatch(state.tr.replaceSelectionWith(br.create()).scrollIntoView());
      return true;
    });
  };
  const headingCmd = (level) => (schema) => {
    const heading2 = schema.nodes.heading;
    return toggleHeader(heading2, { level }, schema.nodes.paragraph, null);
  };
  const KEYMAP_PLUGINS = [
    { __type: "wysiwyg:keymap", name: "Mod-z", command: () => prosemirrorHistory.undo },
    { __type: "wysiwyg:keymap", name: "Backspace", command: () => prosemirrorInputrules.undoInputRule },
    { __type: "wysiwyg:keymap", name: "Mod-Shift-z", command: () => prosemirrorHistory.redo },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-y",
      command: () => prosemirrorHistory.redo,
      unlessMac: true
    },
    { __type: "wysiwyg:keymap", name: "Tab", command: () => tab },
    { __type: "wysiwyg:keymap", name: "Shift-Tab", command: () => shiftTab },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-b",
      ifMark: "strong",
      command: (schema) => prosemirrorCommands.toggleMark(schema.marks.strong)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-i",
      ifMark: "em",
      command: (schema) => prosemirrorCommands.toggleMark(schema.marks.em)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-k",
      ifMark: "link",
      command: () => {
        return function(state, dispatch) {
          return openLinkPopup(state, dispatch);
        };
      }
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Enter",
      command: hardBreakCmd,
      ifNode: "hard_break"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Shift-Enter",
      command: hardBreakCmd,
      ifNode: "hard_break"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Ctrl-Enter",
      command: hardBreakCmd,
      ifNode: "hard_break",
      ifMac: true
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-1",
      command: headingCmd(1),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-2",
      command: headingCmd(2),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-3",
      command: headingCmd(3),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-4",
      command: headingCmd(4),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-5",
      command: headingCmd(5),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-6",
      command: headingCmd(6),
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Backspace",
      command: () => deleteEmptyHeading,
      ifNode: "heading"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-7",
      command: () => toggleOrderedList,
      ifNode: "ordered_list"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-8",
      command: () => toggleBulletList,
      ifNode: "bullet_list"
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-9",
      command: (schema) => prosemirrorSchemaList.liftListItem(schema.nodes.list_item),
      onCondition(schema) {
        return !!(schema.nodes.bullet_list || schema.nodes.ordered_list);
      }
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-0",
      command: (schema) => prosemirrorCommands.setBlockType(schema.nodes.code_block),
      ifNode: "code_block"
    },
    {
      __type: "wysiwyg:keymap",
      name: "ArrowLeft",
      command: () => arrowHandler("left"),
      ifNodes: ["code_block", "table"]
    },
    {
      __type: "wysiwyg:keymap",
      name: "ArrowRight",
      command: () => arrowHandler("right"),
      ifNodes: ["code_block", "table"]
    },
    {
      __type: "wysiwyg:keymap",
      name: "ArrowUp",
      command: () => arrowHandler("up"),
      ifNodes: ["code_block", "table"]
    },
    {
      __type: "wysiwyg:keymap",
      name: "ArrowDown",
      command: () => arrowHandler("down"),
      ifNodes: ["code_block", "table"]
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-0",
      ifMark: "code",
      command: (schema) => prosemirrorCommands.toggleMark(schema.marks.code)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod->",
      ifNode: "blockquote",
      command: (schema) => prosemirrorCommands.wrapIn(schema.nodes.blockquote)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-<",
      ifNode: "blockquote",
      command: () => liftBlockquote
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Alt-9",
      ifNode: "paragraph",
      command: (schema) => prosemirrorCommands.setBlockType(schema.nodes.paragraph)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Shift-Ctrl-0",
      ifNode: "paragraph",
      command: (schema) => prosemirrorCommands.setBlockType(schema.nodes.paragraph)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Mod-Enter",
      ifNode: "horizontal_rule",
      command: () => insertHr
    },
    {
      __type: "wysiwyg:keymap",
      name: "Enter",
      ifNode: "list_item",
      command: (schema) => prosemirrorSchemaList.splitListItem(schema.nodes.list_item)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Tab",
      ifNode: "list_item",
      command: (schema) => prosemirrorSchemaList.sinkListItem(schema.nodes.list_item)
    },
    {
      __type: "wysiwyg:keymap",
      name: "Shift-Tab",
      ifNode: "list_item",
      command: (schema) => prosemirrorSchemaList.liftListItem(schema.nodes.list_item)
    }
  ];
  function arrowHandler(dir) {
    return (state, dispatch, view) => {
      if (view.endOfTextblock(dir)) {
        const side = dir == "left" || dir == "up" ? -1 : 1;
        const $head = state.selection.$head;
        const nextPos = prosemirrorState.Selection.near(state.doc.resolve(side > 0 ? $head.after() : $head.before()), side);
        if (nextPos.$head) {
          const { name } = nextPos.$head.parent.type;
          if (name == "code_block" || name === "table_header" || name === "table_cell") {
            dispatch(state.tr.setSelection(nextPos));
            return true;
          }
        }
      }
      return false;
    };
  }
  const tab = goToCell(1);
  const shiftTab = goToCell(-1);
  function goToCell(dir) {
    return (state, dispatch) => {
      const { table } = state.schema.nodes;
      const parentTable = prosemirrorUtils.findParentNodeOfType(table)(state.selection);
      if (parentTable) {
        TableCommands__namespace.goToNextCell(1 * dir)(state, dispatch);
        return true;
      }
      return false;
    };
  }
  const mac = typeof navigator != "undefined" ? /Mac/.test(navigator.platform) : false;
  function buildKeymap(schema) {
    const keys = __spreadValues({}, prosemirrorCommands.baseKeymap);
    function bind(key, cmd) {
      if (keys[key]) {
        cmd = prosemirrorCommands.chainCommands(cmd, keys[key]);
      }
      keys[key] = cmd;
    }
    bind("Enter", prosemirrorCommands.chainCommands(prosemirrorCommands.createParagraphNear, prosemirrorCommands.liftEmptyBlock, prosemirrorCommands.splitBlock));
    findPlugins("wysiwyg:keymap", KEYMAP_PLUGINS).forEach((plugin) => {
      let skip = false;
      if (plugin.unlessMac && mac)
        skip = true;
      if (plugin.ifMark && !schema.marks[plugin.ifMark])
        skip = true;
      if (plugin.ifNode && !schema.nodes[plugin.ifNode])
        skip = true;
      if (plugin.ifNodes && !plugin.ifNodes.some((n) => schema.nodes[n]))
        skip = true;
      if (plugin.onCondition && !plugin.onCondition(schema))
        skip = true;
      if (!skip)
        bind(plugin.name, plugin.command(schema));
    });
    return keys;
  }
  function singleMarkCommand(markType, getAttrs2) {
    return function command(state, dispatch, match, start, end) {
      const attrs2 = getAttrs2 instanceof Function ? getAttrs2(match) : getAttrs2;
      const tr = state.tr;
      const offset = match[1].length;
      const textGroup = 2;
      if (match[textGroup]) {
        const textStart = start + 1 + offset;
        const textEnd = textStart + match[textGroup].length;
        const deleteStart = [textStart - 1, textStart];
        const nextChar = getNextChar(state, textEnd);
        const deleteEndEnd = nextChar ? 0 : 1;
        const deleteEnd = [textEnd, textEnd + deleteEndEnd];
        tr.delete(...deleteEnd);
        tr.delete(...deleteStart);
        end = start + match[textGroup].length + offset;
      }
      tr.addMark(start + offset, end, markType.create(attrs2));
      tr.removeStoredMark(markType);
      if (dispatch) {
        dispatch(tr);
      }
      return tr;
    };
  }
  function getNextChar(state, textEnd) {
    try {
      return state.doc.textBetween(textEnd + 1, textEnd + 2);
    } catch (e) {
      return "";
    }
  }
  const star = "\\*";
  const double = (boundary) => new RegExp(`${boundary}${boundary}([^\r
	\f${boundary}} ](.*[^\r
	\f${boundary} ])?)${boundary}${boundary}`);
  const single = (boundary) => new RegExp(`(^|[^${boundary}])${boundary}([^\r
	\f${boundary} ](.*[^\r
	\f${boundary} ])?)${boundary}`);
  const STRONG = double(star);
  const EM = single(star);
  const S = double("~");
  const EM_UNDERSCORE = single("_");
  const CODE = single("`");
  function buildInputRules(schema) {
    const rules = [];
    let type;
    if (type = schema.nodes.blockquote)
      rules.push(blockQuoteRule(type));
    if (type = schema.nodes.ordered_list)
      rules.push(orderedListRule(type));
    if (type = schema.nodes.bullet_list)
      rules.push(bulletListRule(type));
    if (type = schema.nodes.code_block)
      rules.push(codeBlockRule(type));
    if (type = schema.nodes.heading)
      rules.push(headingRule(type, 6));
    if (type = schema.nodes.horizontal_rule)
      rules.push(horizontalRuleRule(type));
    let mark;
    if (mark = schema.marks.strong) {
      rules.push(strongStarRule(mark));
      rules.push(strongUnderRule(mark));
    }
    if (mark = schema.marks.strike) {
      rules.push(strikethroughRule(mark));
    }
    if (mark = schema.marks.em) {
      rules.push(emStarRule(mark));
      rules.push(emUnderRule(mark));
    }
    if (mark = schema.marks.code)
      rules.push(codeRule(mark));
    return rules;
  }
  function markInputRule(regexp, markType, getAttrs2) {
    return new prosemirrorInputrules.InputRule(regexp, (state, match, start, end) => {
      const attrs2 = getAttrs2 instanceof Function ? getAttrs2(match) : getAttrs2;
      const tr = state.tr;
      if (match[1]) {
        const textStart = start + match[0].indexOf(match[1]);
        const textEnd = textStart + match[1].length;
        if (textEnd < end)
          tr.delete(textEnd, end);
        if (textStart > start)
          tr.delete(start, textStart);
        end = start + match[1].length;
      }
      tr.addMark(start, end, markType.create(attrs2));
      tr.removeStoredMark(markType);
      return tr;
    });
  }
  function singleMarkInputRule(regexp, markType, getAttrs2) {
    const command = singleMarkCommand(markType, getAttrs2);
    return new prosemirrorInputrules.InputRule(regexp, (state, match, start, end) => {
      return command(state, null, match, start, end);
    });
  }
  function strongStarRule(markType) {
    return markInputRule(STRONG, markType, {});
  }
  function strikethroughRule(markType) {
    return markInputRule(S, markType, {});
  }
  function strongUnderRule(markType) {
    return markInputRule(double("_"), markType, {});
  }
  function emStarRule(markType) {
    return singleMarkInputRule(EM, markType, {});
  }
  function emUnderRule(markType) {
    return singleMarkInputRule(EM_UNDERSCORE, markType, {});
  }
  function codeRule(markType) {
    return singleMarkInputRule(CODE, markType, {});
  }
  function blockQuoteRule(nodeType) {
    return prosemirrorInputrules.wrappingInputRule(/^\s*>\s$/, nodeType);
  }
  function orderedListRule(nodeType) {
    return prosemirrorInputrules.wrappingInputRule(/^(\d+)\.\s$/, nodeType, (match) => ({ order: +match[1] }), (match, node) => node.childCount + node.attrs.order == +match[1]);
  }
  function horizontalRuleRule(nodeType) {
    return new prosemirrorInputrules.InputRule(/^(---|___|\*\*\*)$/, (state, _match, start, end) => {
      return state.tr.replaceRangeWith(start, end, nodeType.create());
    });
  }
  function bulletListRule(nodeType) {
    return prosemirrorInputrules.wrappingInputRule(/^\s*([-+*])\s$/, nodeType);
  }
  function codeBlockRule(nodeType) {
    return prosemirrorInputrules.textblockTypeInputRule(/^```([a-zA-Z]*)? $/, nodeType, (match) => {
      const language = match[1];
      if (language) {
        return { params: language };
      }
      return {};
    });
  }
  function headingRule(nodeType, maxLevel) {
    return prosemirrorInputrules.textblockTypeInputRule(new RegExp("^(#{1," + maxLevel + "})\\s$"), nodeType, (match) => ({
      level: match[1].length
    }));
  }
  function inputRules(schema) {
    return prosemirrorInputrules.inputRules({ rules: buildInputRules(schema) });
  }
  function buildEditorState(schema, translator, value, imageProps) {
    const plugins = [
      commonPlugin,
      inlinePlugin,
      inputRules(schema),
      prosemirrorKeymap.keymap(buildKeymap(schema)),
      prosemirrorHistory.history(),
      linkPlugin(),
      prosemirrorDropcursor.dropCursor({ width: 2, color: "rgb(0, 132, 255)" }),
      prosemirrorGapcursor.gapCursor(),
      TableCommands.tableEditing(),
      tablePlugin,
      codeBlockPlugin
    ];
    if (imageProps) {
      plugins.push(imagePlugin(imageProps));
    }
    return prosemirrorState.EditorState.create({
      schema,
      doc: translator.nodeFromString(value),
      plugins
    });
  }
  const buildEditor = (input, el, setEditorView, imageProps, format) => {
    const schema = buildSchema();
    const translator = buildTranslator(schema, format);
    if (!el)
      return {};
    const view = new prosemirrorView.EditorView(el, {
      state: buildEditorState(schema, translator, input.value, imageProps),
      dispatchTransaction(tr2) {
        const nextState = view.state.apply(tr2);
        view.updateState(nextState);
        setEditorView({ view });
        if (tr2.docChanged && !tr2.getMeta("input-update")) {
          input.onChange(translator.stringFromNode(tr2.doc));
        }
      }
    });
    const { state, dispatch } = view;
    const { tr, doc: doc2 } = state;
    dispatch(tr.setSelection(new prosemirrorState.TextSelection(doc2.resolve(doc2.content.size) || 0)));
    view.focus();
    setEditorView({ view });
    return { translator };
  };
  function updateEditorState(view, translator, value) {
    const doc2 = translator.nodeFromString(value);
    if (!doc2)
      return;
    const { state, dispatch } = view;
    const { tr } = state;
    dispatch(tr.setSelection(new prosemirrorState.TextSelection(tr.doc.resolve(0), tr.doc.resolve(state.doc.nodeSize - 2))).replaceSelectionWith(doc2).setMeta("input-update", true));
  }
  const alignColumn = (view, alignValue) => {
    const { state, dispatch } = view;
    const { selection } = state;
    const { table, table_cell, table_header } = state.schema.nodes;
    const tableCell = prosemirrorUtils.findParentNodeOfType(table_cell)(state.selection);
    const tableHeader = prosemirrorUtils.findParentNodeOfType(table_header)(state.selection);
    const cellNode = tableCell || tableHeader;
    if (!cellNode)
      return;
    const align = cellNode.node.attrs.align === alignValue ? void 0 : alignValue;
    const tableNode = prosemirrorUtils.findParentNodeOfType(table)(state.selection);
    if (!tableNode)
      return;
    const tableMap = TableCommands.TableMap.get(tableNode.node);
    const pos = Object.entries(tableMap.map).find((entry) => entry[1] > selection.head - tableNode.start);
    if (!pos)
      return;
    const cellPos = parseInt(pos[0]) - 1;
    const columnPos = cellPos % tableMap.width;
    dispatch(prosemirrorUtils.forEachCellInColumn(columnPos, (cell, tr) => {
      return prosemirrorUtils.setCellAttrs(cell, { align })(tr);
    })(state.tr));
    view.focus();
  };
  var ColumnPopup = () => {
    const { editorView } = useEditorStateContext();
    if (!editorView)
      return null;
    const { state, dispatch } = editorView.view;
    const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left_selected")[0];
    if (markerDivTable)
      return null;
    const markerDivCol = document.getElementsByClassName("tina_table_header_ext_top_selected")[0];
    const markerDivRows = document.getElementsByClassName("tina_table_header_ext_left");
    let markerDivRow;
    for (let i = 1; i < markerDivRows.length; i++) {
      if (markerDivRows[i].classList.contains("tina_table_header_ext_left_selected"))
        markerDivRow = markerDivRows[i];
    }
    if (!markerDivCol && !markerDivRow)
      return null;
    const { view } = editorView;
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, markerDivCol && ReactDOM__namespace.createPortal(/* @__PURE__ */ React__namespace.createElement(IconWrapperCol$1, null, /* @__PURE__ */ React__namespace.createElement(toolkit.IconButton, {
      onClick: () => alignColumn(view, "left"),
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.AlignLeft, {
      className: "w-5/6 h-auto"
    })), /* @__PURE__ */ React__namespace.createElement(toolkit.IconButton, {
      onClick: () => alignColumn(view, "center"),
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.AlignCenter, {
      className: "w-5/6 h-auto"
    })), /* @__PURE__ */ React__namespace.createElement(toolkit.IconButton, {
      onClick: () => alignColumn(view, "right"),
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.AlignRight, {
      className: "w-5/6 h-auto"
    })), /* @__PURE__ */ React__namespace.createElement(toolkit.IconButton, {
      onClick: () => {
        TableCommands.deleteColumn(state, dispatch);
        view.focus();
      },
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.TrashIcon, {
      className: "w-5/6 h-auto"
    }))), markerDivCol), markerDivRow && ReactDOM__namespace.createPortal(/* @__PURE__ */ React__namespace.createElement(IconWrapperRow$1, null, /* @__PURE__ */ React__namespace.createElement(toolkit.IconButton, {
      onClick: () => {
        TableCommands.deleteRow(state, dispatch);
        view.focus();
      },
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__namespace.createElement(toolkit.TrashIcon, {
      className: "w-5/6 h-auto"
    }))), markerDivRow));
  };
  const IconWrapperCol$1 = styled__default["default"].span`
  display: flex;
  left: 50%;
  position: absolute;
  top: -8px;
  transform: translate3d(-50%, -100%, 0);
  button:not(:first-of-type) {
    margin-left: 10px;
  }
`;
  const IconWrapperRow$1 = styled__default["default"].span`
  position: absolute;
  top: 50%;
  left: -8px;
  transform: translate3d(-100%, -50%, 0);
`;
  const borderWidth$2 = 1;
  const controlSize$2 = 12;
  var AddColumn = ({ index, marker, tableHeight, view }) => {
    const { state, dispatch } = view;
    const addColumn = (pos) => {
      dispatch(prosemirrorUtils.addColumnAt(pos)(state.tr));
      view.focus();
    };
    const [hovered, setHovered] = React.useState(false);
    React.useEffect(() => {
      if (hovered)
        marker.style.zIndex = "1000";
      else
        marker.style.zIndex = "1";
    }, [hovered]);
    return ReactDOM__namespace.createPortal(/* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(Wrapper$2, {
      onMouseEnter: () => setHovered(true),
      onMouseLeave: () => setHovered(false)
    }, hovered ? /* @__PURE__ */ React__default["default"].createElement(IconWrapperCol, null, /* @__PURE__ */ React__default["default"].createElement(toolkit.IconButton, {
      onClick: () => {
        addColumn(index);
        setHovered(false);
      },
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__default["default"].createElement(toolkit.AddIcon, null))) : /* @__PURE__ */ React__default["default"].createElement(Pointer$1, null)), hovered && /* @__PURE__ */ React__default["default"].createElement(ColumnDivider$1, {
      height: tableHeight
    })), marker);
  };
  const Wrapper$2 = styled__default["default"].div`
  top: -7px;
  position: absolute;
  right: 0;
  padding: 8px;
  transform: translate3d(50%, -100%, 0);
  user-select: none;
`;
  const Pointer$1 = styled__default["default"].div`
  background: #e1ddec;
  border-radius: 50%;
  height: 4px;
  width: 4px;
`;
  const IconWrapperCol = styled__default["default"].span`
  position: absolute;
  top: 0;
  left: 50%;
  transform: translate3d(-50%, -50%, 0);
`;
  const ColumnDivider$1 = styled__default["default"].div`
  position: absolute;
  background: #0574e4;
  top: ${-1 * borderWidth$2}px;
  z-index: 1000;
  right: ${-1 * borderWidth$2}px;
  width: ${2 * borderWidth$2}px;
  height: ${({ height }) => `${height + controlSize$2 - borderWidth$2}px`};
`;
  const borderWidth$1 = 1;
  const controlSize$1 = 12;
  var AddRow = ({ index, marker, tableWidth, view }) => {
    const { state, dispatch } = view;
    const addRow = (pos) => {
      if (pos > 1)
        dispatch(prosemirrorUtils.addRowAt(pos, true)(state.tr));
      else {
        const { table, table_cell, table_row } = state.schema.nodes;
        const tableNode = prosemirrorUtils.findParentNodeOfType(table)(state.selection);
        if (!tableNode)
          return;
        const tableMap = TableCommands.TableMap.get(tableNode.node);
        const position = tableNode.start + tableMap.map[tableMap.width] - 1;
        const cellInNextRow = prosemirrorUtils.getCellsInRow(0)(state.selection);
        if (!cellInNextRow)
          return;
        const cells = cellInNextRow == null ? void 0 : cellInNextRow.map((cell) => table_cell.createAndFill(__spreadValues({}, cell.node.attrs)));
        dispatch(state.tr.insert(position, table_row.create(null, cells)));
      }
      view.focus();
    };
    const [hovered, setHovered] = React.useState(false);
    React.useEffect(() => {
      if (hovered)
        marker.style.zIndex = "1000";
      else
        marker.style.zIndex = "1";
    }, [hovered]);
    return ReactDOM__namespace.createPortal(/* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, /* @__PURE__ */ React__default["default"].createElement(Wrapper$1, {
      onMouseEnter: () => setHovered(true),
      onMouseLeave: () => setHovered(false)
    }, hovered && index > 0 ? /* @__PURE__ */ React__default["default"].createElement(IconWrapperRow, null, /* @__PURE__ */ React__default["default"].createElement(toolkit.IconButton, {
      onClick: () => addRow(index),
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__default["default"].createElement(toolkit.AddIcon, {
      className: "w-5/6 h-auto"
    }))) : /* @__PURE__ */ React__default["default"].createElement(Pointer, null)), hovered && /* @__PURE__ */ React__default["default"].createElement(ColumnDivider, {
      width: tableWidth
    })), marker);
  };
  const Wrapper$1 = styled__default["default"].div`
  left: -7px;
  position: absolute;
  bottom: 0;
  padding: 8px;
  transform: translate3d(-100%, 50%, 0);
  user-select: none;
`;
  const Pointer = styled__default["default"].div`
  background: #e1ddec;
  border-radius: 50%;
  height: 4px;
  width: 4px;
`;
  const IconWrapperRow = styled__default["default"].span`
  position: absolute;
  top: 50%;
  left: 0;
  transform: translate3d(-50%, -50%, 0);
`;
  const ColumnDivider = styled__default["default"].div`
  position: absolute;
  background: #0574e4;
  left: ${-1 * borderWidth$1}px;
  z-index: var(--tina-z-index-1);
  bottom: ${-1 * borderWidth$1}px;
  height: ${2 * borderWidth$1}px;
  width: ${({ width: width2 }) => `${width2 + controlSize$1 - borderWidth$1}px`};
`;
  var AddPopup = () => {
    const { editorView } = useEditorStateContext();
    if (!editorView)
      return null;
    const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left");
    if (!markerDivTable.length)
      return null;
    const tableElm = markerDivTable[0].closest("table");
    if (!tableElm)
      return null;
    const { height, width: width2 } = tableElm.getBoundingClientRect();
    const markerDivCol = document.getElementsByClassName("tina_table_header_ext_top");
    const markerCols = [markerDivTable[0]];
    for (let i = 0; i < markerDivCol.length; i++) {
      markerCols.push(markerDivCol[i]);
    }
    const markerDivRow = document.getElementsByClassName("tina_table_header_ext_left");
    const markerRows = [markerDivTable[0]];
    for (let i = 0; i < markerDivRow.length; i++) {
      markerRows.push(markerDivRow[i]);
    }
    const { view } = editorView;
    return /* @__PURE__ */ React__default["default"].createElement(React__default["default"].Fragment, null, markerCols.map((marker, index) => /* @__PURE__ */ React__default["default"].createElement(AddColumn, {
      key: `add-column-menu-${index}`,
      index,
      marker,
      tableHeight: height,
      view
    })), markerRows.map((marker, index) => /* @__PURE__ */ React__default["default"].createElement(AddRow, {
      key: `add-row-menu-${index}`,
      index,
      marker,
      tableWidth: width2,
      view
    })));
  };
  var OptionsPopup = () => {
    const { editorView } = useEditorStateContext();
    if (!editorView)
      return null;
    const { view } = editorView;
    const deleteSelectedTable = () => {
      const { state, dispatch } = view;
      TableCommands.deleteTable(state, dispatch);
      view.focus();
    };
    const markerDivTable = document.getElementsByClassName("tina_table_header_ext_top_left_selected");
    if (!markerDivTable.length)
      return null;
    const tableElm = markerDivTable[0].closest("table");
    if (!tableElm)
      return null;
    const { height, width: width2 } = tableElm.getBoundingClientRect();
    return ReactDOM__default["default"].createPortal(/* @__PURE__ */ React__default["default"].createElement(Wrapper, {
      height,
      width: width2
    }, /* @__PURE__ */ React__default["default"].createElement(toolkit.IconButton, {
      onClick: deleteSelectedTable,
      size: "small",
      variant: "primary"
    }, /* @__PURE__ */ React__default["default"].createElement(toolkit.TrashIcon, null))), markerDivTable[0]);
  };
  const Wrapper = styled__default["default"].div`
  background-color: #ffffff;
  border-radius: 2px;
  cursor: default;
  padding: 0px 4px;
  position: absolute;
  top: ${({ height }) => `${height + 24}px`};
  left: ${({ width: width2 }) => `${width2 / 2 - 8}px`};
`;
  const TablePopups = () => /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(ColumnPopup, null), /* @__PURE__ */ React__namespace.createElement(AddPopup, null), /* @__PURE__ */ React__namespace.createElement(OptionsPopup, null));
  const Menubar = (_f) => {
    var _g = _f, { plugins, imageProps } = _g, rest = __objRest(_g, ["plugins", "imageProps"]);
    const { editorView } = useEditorStateContext();
    if (!editorView)
      return null;
    return /* @__PURE__ */ React__default["default"].createElement(BaseMenubar, __spreadProps(__spreadValues({}, rest), {
      menus: [
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$8, {
          key: "BlockMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$5, {
          key: "InlineMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu, {
          key: "LinkMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$1, {
          key: "ImageMenu",
          imageProps
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$2, {
          key: "TableMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$3, {
          key: "QuoteMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$7, {
          key: "CodeBlockMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$4, {
          key: "ListMenu"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ProsemirrorMenu$6, {
          key: "HistoryMenu"
        })
      ],
      popups: [
        /* @__PURE__ */ React__default["default"].createElement(TablePopups, {
          key: "TablePopups"
        }),
        /* @__PURE__ */ React__default["default"].createElement(ImageEdit, {
          key: "ImageEditPopup"
        }),
        /* @__PURE__ */ React__default["default"].createElement(LinkForm, {
          key: "LinkFormPopup"
        }),
        /* @__PURE__ */ React__default["default"].createElement(Loader, {
          key: "ImageLoader"
        })
      ],
      plugins
    }));
  };
  const CodeMirrorCss = styled.css`
  white-space: pre-wrap;

  .CodeMirror {
    font-family: monospace;
    height: auto;
    width: 100%;
    border-radius: 5px;
    margin-bottom: 16px;
    color: black;
    direction: ltr;
  }

  .CodeMirror-lines {
    padding: 4px 0; /* Vertical padding around content */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    padding: 0 4px; /* Horizontal padding of content */
  }

  .CodeMirror-scrollbar-filler,
  .CodeMirror-gutter-filler {
    background-color: white; /* The little square between H and V scrollbars */
  }

  /* GUTTER */

  .CodeMirror-gutters {
    border-right: 1px solid #ddd;
    background-color: #f7f7f7;
    white-space: nowrap;
  }
  .CodeMirror-linenumbers {
  }
  .CodeMirror-linenumber {
    padding: 0 3px 0 5px;
    min-width: 20px;
    text-align: right;
    color: #999;
    white-space: nowrap;
  }

  .CodeMirror-guttermarker {
    color: black;
  }
  .CodeMirror-guttermarker-subtle {
    color: #999;
  }

  /* CURSOR */

  .CodeMirror-cursor {
    border-left: 1px solid black;
    border-right: none;
    width: 0;
  }
  /* Shown when moving in bi-directional text */
  .CodeMirror div.CodeMirror-secondarycursor {
    border-left: 1px solid silver;
  }
  .cm-fat-cursor .CodeMirror-cursor {
    width: auto;
    border: 0 !important;
    background: #7e7;
  }
  .cm-fat-cursor div.CodeMirror-cursors {
    z-index: 1;
  }
  .cm-fat-cursor-mark {
    background-color: rgba(20, 255, 20, 0.5);
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
  }
  .cm-animate-fat-cursor {
    width: auto;
    border: 0;
    -webkit-animation: blink 1.06s steps(1) infinite;
    -moz-animation: blink 1.06s steps(1) infinite;
    animation: blink 1.06s steps(1) infinite;
    background-color: #7e7;
  }
  @-moz-keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }
  @-webkit-keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }
  @keyframes blink {
    0% {
    }
    50% {
      background-color: transparent;
    }
    100% {
    }
  }

  /* Can style cursor different in overwrite (non-insert) mode */
  .CodeMirror-overwrite .CodeMirror-cursor {
  }

  .cm-tab {
    display: inline-block;
    text-decoration: inherit;
  }

  .CodeMirror-rulers {
    position: absolute;
    left: 0;
    right: 0;
    top: -50px;
    bottom: 0;
    overflow: hidden;
  }
  .CodeMirror-ruler {
    border-left: 1px solid #ccc;
    top: 0;
    bottom: 0;
    position: absolute;
  }

  /* DEFAULT THEME */

  .cm-s-default .cm-header {
    color: blue;
  }
  .cm-s-default .cm-quote {
    color: #090;
  }
  .cm-negative {
    color: #d44;
  }
  .cm-positive {
    color: #292;
  }
  .cm-header,
  .cm-strong {
    font-weight: bold;
  }
  .cm-em {
    font-style: italic;
  }
  .cm-link {
    text-decoration: underline;
  }
  .cm-strikethrough {
    text-decoration: line-through;
  }

  .cm-s-default .cm-keyword {
    color: #708;
  }
  .cm-s-default .cm-atom {
    color: #219;
  }
  .cm-s-default .cm-number {
    color: #164;
  }
  .cm-s-default .cm-def {
    color: #00f;
  }
  .cm-s-default .cm-variable,
  .cm-s-default .cm-punctuation,
  .cm-s-default .cm-property,
  .cm-s-default .cm-operator {
  }
  .cm-s-default .cm-variable-2 {
    color: #05a;
  }
  .cm-s-default .cm-variable-3,
  .cm-s-default .cm-type {
    color: #085;
  }
  .cm-s-default .cm-comment {
    color: #a50;
  }
  .cm-s-default .cm-string {
    color: #a11;
  }
  .cm-s-default .cm-string-2 {
    color: #f50;
  }
  .cm-s-default .cm-meta {
    color: #555;
  }
  .cm-s-default .cm-qualifier {
    color: #555;
  }
  .cm-s-default .cm-builtin {
    color: #30a;
  }
  .cm-s-default .cm-bracket {
    color: #997;
  }
  .cm-s-default .cm-tag {
    color: #170;
  }
  .cm-s-default .cm-attribute {
    color: #00c;
  }
  .cm-s-default .cm-hr {
    color: #999;
  }
  .cm-s-default .cm-link {
    color: #00c;
  }

  .cm-s-default .cm-error {
    color: #f00;
  }
  .cm-invalidchar {
    color: #f00;
  }

  .CodeMirror-composing {
    border-bottom: 2px solid;
  }

  /* Default styles for common addons */

  div.CodeMirror span.CodeMirror-matchingbracket {
    color: #0b0;
  }
  div.CodeMirror span.CodeMirror-nonmatchingbracket {
    color: #a22;
  }
  .CodeMirror-matchingtag {
    background: rgba(255, 150, 0, 0.3);
  }
  .CodeMirror-activeline-background {
    background: #e8f2ff;
  }

  /* STOP */

  /* The rest of this file contains styles related to the mechanics of
    the editor. You probably shouldn't touch them. */

  .CodeMirror {
    position: relative;
    overflow: hidden;
    background: white;
  }

  .CodeMirror-scroll {
    overflow: scroll !important; /* Things will break if this is overridden */
    /* 30px is the magic margin used to hide the element's real scrollbars */
    /* See overflow: hidden in .CodeMirror */
    margin-bottom: -30px;
    margin-right: -30px;
    padding-bottom: 30px;
    height: 100%;
    outline: none; /* Prevent dragging from highlighting the element */
    position: relative;
  }
  .CodeMirror-sizer {
    position: relative;
    min-height: auto;
    border-right: 30px solid transparent;
  }

  /* The fake, visible scrollbars. Used to force redraw during scrolling
    before actual scrolling happens, thus preventing shaking and
    flickering artifacts. */
  .CodeMirror-vscrollbar,
  .CodeMirror-hscrollbar,
  .CodeMirror-scrollbar-filler,
  .CodeMirror-gutter-filler {
    position: absolute;
    z-index: 6;
    display: none;
  }
  .CodeMirror-vscrollbar {
    right: 0;
    top: 0;
    overflow-x: hidden;
    overflow-y: scroll;
  }
  .CodeMirror-hscrollbar {
    bottom: 0;
    left: 0;
    overflow-y: hidden;
    overflow-x: scroll;
  }
  .CodeMirror-scrollbar-filler {
    right: 0;
    bottom: 0;
  }
  .CodeMirror-gutter-filler {
    left: 0;
    bottom: 0;
  }

  .CodeMirror-gutters {
    position: absolute;
    left: 0;
    top: 0;
    min-height: 100%;
    z-index: 3;
  }
  .CodeMirror-gutter {
    white-space: normal;
    height: 100%;
    display: inline-block;
    vertical-align: top;
    margin-bottom: -30px;
  }
  .CodeMirror-gutter-wrapper {
    position: absolute;
    z-index: 4;
    background: none !important;
    border: none !important;
  }
  .CodeMirror-gutter-background {
    position: absolute;
    top: 0;
    bottom: 0;
    z-index: 4;
  }
  .CodeMirror-gutter-elt {
    position: absolute;
    cursor: default;
    z-index: 4;
  }
  .CodeMirror-gutter-wrapper ::selection {
    background-color: transparent;
  }
  .CodeMirror-gutter-wrapper ::-moz-selection {
    background-color: transparent;
  }

  .CodeMirror-lines {
    cursor: text;
    min-height: 1px; /* prevents collapsing before first draw */
  }
  .CodeMirror pre.CodeMirror-line,
  .CodeMirror pre.CodeMirror-line-like {
    /* Reset some styles that the rest of the page might have set */
    -moz-border-radius: 0;
    -webkit-border-radius: 0;
    border-radius: 0;
    border-width: 0;
    background: transparent;
    font-family: inherit;
    font-size: inherit;
    margin: 0;
    white-space: pre;
    word-wrap: normal;
    line-height: inherit;
    z-index: 2;
    position: relative;
    overflow: visible;
    -webkit-tap-highlight-color: transparent;
    -webkit-font-variant-ligatures: contextual;
    font-variant-ligatures: contextual;
  }
  .CodeMirror-wrap pre.CodeMirror-line,
  .CodeMirror-wrap pre.CodeMirror-line-like {
    word-wrap: break-word;
    white-space: pre-wrap;
    word-break: normal;
  }

  .CodeMirror-linebackground {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 0;
  }

  .CodeMirror-linewidget {
    position: relative;
    z-index: 2;
    padding: 0.1px; /* Force widget margins to stay inside of the container */
  }

  .CodeMirror-widget {
  }

  .CodeMirror-rtl pre {
    direction: rtl;
  }

  .CodeMirror-code {
    outline: none;
  }

  /* Force content-box sizing for the elements where we expect it */
  .CodeMirror-scroll,
  .CodeMirror-sizer,
  .CodeMirror-gutter,
  .CodeMirror-gutters,
  .CodeMirror-linenumber {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
  }

  .CodeMirror-measure {
    position: absolute;
    width: 100%;
    height: 0;
    overflow: hidden;
    visibility: hidden;
  }

  .CodeMirror-cursor {
    position: absolute;
    pointer-events: none;
  }
  .CodeMirror-measure pre {
    position: static;
  }

  div.CodeMirror-cursors {
    visibility: hidden;
    position: relative;
    z-index: 3;
  }
  div.CodeMirror-dragcursors {
    visibility: visible;
  }

  .CodeMirror-focused div.CodeMirror-cursors {
    visibility: visible;
  }

  .CodeMirror-selected {
    background: #d9d9d9;
  }
  .CodeMirror-focused .CodeMirror-selected {
    background: #d7d4f0;
  }
  .CodeMirror-crosshair {
    cursor: crosshair;
  }
  .CodeMirror-line::selection,
  .CodeMirror-line > span::selection,
  .CodeMirror-line > span > span::selection {
    background: #d7d4f0;
  }
  .CodeMirror-line::-moz-selection,
  .CodeMirror-line > span::-moz-selection,
  .CodeMirror-line > span > span::-moz-selection {
    background: #d7d4f0;
  }

  .cm-searching {
    background-color: #ffa;
    background-color: rgba(255, 255, 0, 0.4);
  }

  /* Used to force a border model for a node */
  .cm-force-border {
    padding-right: 0.1px;
  }

  @media print {
    /* Hide the cursor when printing */
    .CodeMirror div.CodeMirror-cursors {
      visibility: hidden;
    }
  }

  /* See issue #2901 */
  .cm-tab-wrap-hack:after {
    content: '';
  }

  /* Help users use markselection to safely style text background */
  span.CodeMirror-selectedtext {
    background: none;
  }
`;
  const paddingX = 8;
  const paddingY = 6;
  const borderWidth = 1;
  const controlSize = 12;
  const proseMirrorTableStyles = `
  .ProseMirror {
    display: block
  }
  .ProseMirror .tableWrapper {
    overflow-x: auto;
  }
  .ProseMirror .column-resize-handle {
    position: absolute;
    right: -2px;
    top: 0;
    bottom: 0;
    width: 4px;
    z-index: 20;
    background-color: #adf;
    pointer-events: none;
  }
  .ProseMirror.resize-cursor {
    cursor: ew-resize;
    cursor: col-resize;
  }
  /* Give selected cells a blue overlay */
  .ProseMirror .selectedCell:after {
    z-index: 2;
    position: absolute;
    content: '';
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    background: rgba(0, 132, 255, 0.25);
    /* This provides a bullet-proof border for selected cells even with border collapsing */
    box-shadow: 0 0 0 1px #0574E4;
    pointer-events: none;
  }
  .ProseMirror:focus {
    outline: 0px solid transparent;
  }
  .ProseMirror p {
    min-height: 18px;
  }
  .ProseMirror table {
    border-collapse: collapse;
    table-layout: fixed;
    display: inline-table;
    margin: 32px 0 32px 0;
    overflow: visible;
    width: 100%;
  }
  .ProseMirror th {
    background-color: #F6F6F9;
  }
  .ProseMirror tr {
    height: 40px;
  }
  .ProseMirror table td,
  .ProseMirror table th {
    border: 1px solid #E1DDEC;
    padding: ${paddingY}px ${paddingX}px;
    position: relative;
    vertical-align: top;
    box-sizing: border-box;
  }
  .ProseMirror .tina_table_header_ext_top {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: ${controlSize}px;
    width: calc(100% + ${borderWidth * 2}px);
    transform: translate(${(borderWidth + paddingX) * -1}px, ${(controlSize + paddingY) * -1}px);
    cursor: pointer;
    z-index: 1;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_top_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .tina_table_header_ext_left {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: calc(100% + ${borderWidth * 2}px);
    width: ${controlSize}px;
    transform: translate(${(controlSize + paddingX) * -1}px, ${(borderWidth + paddingY) * -1}px);
    cursor: pointer;
    z-index: 1;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_left_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .tina_table_header_ext_top_left {
    background: #F6F6F9;
    border: 1px solid #E1DDEC;
    position: absolute;
    height: ${controlSize}px;
    width: ${controlSize}px;
    transform: translate(${(controlSize + paddingX) * -1}px, ${(controlSize + paddingY) * -1}px);
    border-radius: 5px 0 0 0;
    z-index: 1;
    cursor: pointer;
    user-select: none;
    box-sizing: border-box;
  }
  .ProseMirror div.tina_table_header_ext_top_left_selected {
    background: #0084ff;
    border-color: #0574E4;
    z-index: 10;
  }
  .ProseMirror .selectedCell {
    border-color: transparent;
  }
`;
  const ProseMirrorCss = styled.css`
  .ProseMirror .tinacms-image-wrapper {
    display: inline-block;
    margin: 1em 0;
  }

  ${proseMirrorTableStyles}
`;
  const ProsemirrorEditor = styled__default["default"]((_h) => {
    var _i = _h, {
      input,
      plugins,
      sticky,
      format,
      imageProps
    } = _i, styleProps = __objRest(_i, [
      "input",
      "plugins",
      "sticky",
      "format",
      "imageProps"
    ]);
    const editorRef = React.useRef(null);
    const [editorView, setEditorView] = React.useState();
    const [translator, setTranslator] = React.useState();
    const { browserFocused } = useBrowserFocusContext();
    React.useEffect(() => {
      const { translator: translatorObj } = buildEditor(input, editorRef.current, setEditorView, imageProps, format);
      setTranslator(translatorObj);
      return () => {
        editorView && editorView.view.destroy();
      };
    }, [editorRef]);
    React.useEffect(() => {
      const view = editorView && editorView.view;
      const editorWrapper = document.getElementsByClassName("ProseMirror")[0];
      if (!view || (editorWrapper === document.activeElement || editorWrapper.contains(document.activeElement)) && browserFocused)
        return;
      updateEditorState(view, translator, input.value);
    }, [input.value]);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement("link", {
      rel: "stylesheet",
      href: "https://codemirror.net/lib/codemirror.css"
    }), /* @__PURE__ */ React__namespace.createElement(EditorStateProvider, {
      translator,
      editorView
    }, /* @__PURE__ */ React__namespace.createElement(Menubar, {
      sticky,
      imageProps,
      plugins
    })), /* @__PURE__ */ React__namespace.createElement(RichTextInput, null, /* @__PURE__ */ React__namespace.createElement("div", __spreadProps(__spreadValues({}, styleProps), {
      ref: editorRef
    }))));
  })`
  ${CodeMirrorCss}${ProseMirrorCss}
`;
  const RichTextInput = ({ children }) => {
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: "tina-prose shadow-inner focus:shadow-outline focus:border-blue-500 block w-full bg-white border border-gray-200 text-gray-600 focus:text-gray-900 rounded-md p-5 mb-5",
      style: { minHeight: "100px", maxWidth: `100%` }
    }, children);
  };
  const modeTogglePlugin = {
    name: "wysiwygModeToggle",
    MenuItem: () => /* @__PURE__ */ React__namespace.createElement(EditorModeMenu, null)
  };
  const Wysiwyg = ({
    imageProps: passedInImageProps,
    input,
    form,
    plugins = [],
    format = "markdown",
    sticky,
    className
  }) => {
    const cms = tinacms.useCMS();
    const { value, onChange } = input;
    const pluginList = format === "markdown" ? [...plugins, modeTogglePlugin] : plugins;
    const imageProps = useImageProps(cms, form, passedInImageProps);
    return /* @__PURE__ */ React__namespace.createElement(EditorModeProvider, null, /* @__PURE__ */ React__namespace.createElement(EditorModeConsumer, null, ({ mode }) => /* @__PURE__ */ React__namespace.createElement(BrowserFocusProvider, null, mode === "markdown" ? /* @__PURE__ */ React__namespace.createElement(MarkdownEditor, {
      value,
      onChange,
      imageProps,
      plugins: pluginList,
      sticky
    }) : /* @__PURE__ */ React__namespace.createElement(ProsemirrorEditor, {
      input: {
        value,
        onChange
      },
      plugins: pluginList,
      sticky,
      format,
      imageProps,
      className
    }))));
  };
  const defaultParse = (media) => media.id;
  function useImageProps(cms, form, passedInImageProps) {
    return React__namespace.useMemo(() => {
      const parse = (passedInImageProps == null ? void 0 : passedInImageProps.parse) || defaultParse;
      const uploadDir = (passedInImageProps == null ? void 0 : passedInImageProps.uploadDir) && form ? passedInImageProps.uploadDir(form.values) : "";
      return {
        upload: async (files) => {
          const filesToUpload = files.map((file) => ({
            directory: uploadDir,
            file
          }));
          const allMedia = await cms.media.persist(filesToUpload);
          return allMedia.map((media) => {
            if (parse) {
              return parse(media);
            } else {
              return media.filename;
            }
          });
        },
        previewSrc: (src) => {
          return cms.media.previewSrc(src);
        },
        mediaDir: uploadDir,
        parse
      };
    }, [
      cms.media.store,
      passedInImageProps == null ? void 0 : passedInImageProps.uploadDir,
      passedInImageProps == null ? void 0 : passedInImageProps.previewSrc,
      passedInImageProps == null ? void 0 : passedInImageProps.upload
    ]);
  }
  const HTMLField = (props) => {
    return /* @__PURE__ */ React__default["default"].createElement(Wysiwyg, __spreadProps(__spreadValues({}, props), {
      sticky: false,
      format: "html",
      imageProps: props.field.imageProps
    }));
  };
  const HtmlFieldPlugin = {
    __type: "field",
    name: "html",
    Component: HTMLField,
    parse: (value) => value || ""
  };
  const MarkdownField = tinacms.wrapFieldsWithMeta((props) => /* @__PURE__ */ React__default["default"].createElement(Wysiwyg, __spreadProps(__spreadValues({}, props), {
    sticky: false,
    format: "markdown",
    imageProps: props.field.imageProps
  })));
  const MarkdownFieldPlugin = {
    __type: "field",
    name: "markdown",
    Component: MarkdownField,
    parse: (value) => value || ""
  };
  exports2.HTMLField = HTMLField;
  exports2.HtmlFieldPlugin = HtmlFieldPlugin;
  exports2.MarkdownField = MarkdownField;
  exports2.MarkdownFieldPlugin = MarkdownFieldPlugin;
  exports2.Wysiwyg = Wysiwyg;
  Object.defineProperty(exports2, "__esModule", { value: true });
  exports2[Symbol.toStringTag] = "Module";
});
